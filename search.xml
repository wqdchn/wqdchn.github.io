<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>再见五月·人与物与事</title>
      <link href="/how-is-going-2020-05-31.html"/>
      <url>/how-is-going-2020-05-31.html</url>
      <content type="html"><![CDATA[<h3 id="最近的人"><a href="#最近的人" class="headerlink" title="最近的人"></a>最近的人</h3><p>认识了一些有趣的网友，隔着网线隔着屏幕也能感受到对方所说的种种有趣的事，真是神奇。这是网上冲浪最大的乐趣了吧，不再关心那些国家大事，世界风云。就看看沙雕网友们又在讨论什么好吃的，好玩的，哈哈哈哈哈就挺好的。不过在资本掌控舆论的时代，这些没有流量的小事很难被人发现吧，真正寻找到这样的网友，看到他们在自己的一亩三分地上说说闹闹，也不太容易。</p><h3 id="最近的物"><a href="#最近的物" class="headerlink" title="最近的物"></a>最近的物</h3><p>五月中下旬的时候，杨梅已经上市了，昨天在水果店买了一盒杨梅，真的难吃，感觉是放了好久没卖出的、不新鲜的杨梅。等六月的时候，我一定要补回来，不能错过杨梅这样的好东西！</p><h3 id="最近的事"><a href="#最近的事" class="headerlink" title="最近的事"></a>最近的事</h3><p>2020 年也快过去小一半了，恍惚间有些不太真实，我真的有认真度过每一天吗。如果有的话，我怎么看不太明白身边发生的事呢。一场疫情，从全世界都盯着中国，发展到现在各个国家都自顾不暇。太平洋对岸最近还发生了暴乱，他们倒是很利索地就出动了武装力量平乱，完全没有当初香港暴乱时劝告中国政府时的那种异常理智与冷静了，思之令人发笑。</p><p>但是重点并不在比较当初他们是怎么做的和现在他们是怎么做的，我相信有比我更加聪明的人会研究这些事情。我所关心的是，作为一个普通人，该如何在扰乱的信息流中获取自己的喘息之机。每天都有那么多新闻，国内的国外的，有些肮臜事令人愤怒而气血上涌，有些破烂事前后反复反转令人迷茫而不知所措。一个普通人，看到这些事情的时候，总觉得自己能做些什么，但是其实好像什么也做不了。而当自己觉得做不了什么的时候，又会觉得这样好像就让什么人得逞了一样。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础：类加载过程</title>
      <link href="/java-basic-classloader.html"/>
      <url>/java-basic-classloader.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>一般来说，Java 的类加载过程分为三个主要步骤：加载、链接、初始化，细节部分在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Java 虚拟机规范</a>中有详细介绍。</p><p>Java 的语言类型可以分为基本类型和引用类型。基本类型是 Java 虚拟机预先定义好的。引用类型中，Java将其细分为：类、接口、数组类和泛型参数，泛型参数在编译过程中会被擦除（没看懂啥意思？？），数组类是 JVM 直接生成的，另外两种则有对应的字节流。</p><p>最常见的字节流就是 Java 编译生成的 class 文件，Java 将来自不同数据源的字节流读取到 JVM 中生成类或接口就是类加载过程，这里的数据源可能是 jar 包、class文件等等。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载，是指查找字节流，并根据字节流创建类的过程。JVM 中有三种类加载器：启动类加载器、扩展类加载器、应用类加载器，每种类加载器加载一部分类。加载阶段，类的唯一性通过类加载器名称和类全面来共同确定，因此不同类加载器加载同一串字节流也会生成两个不同的类。</p><p>启动类加载器（Bootstrap Class Loader）加载最基础、最重要的类，比如 lib/ 目录下 jar 包中的类。</p><p>扩展类加载器（Extension Class Loader）的父-类加载器是启动类加载器，它负责加载 lib/ext/ 目录下的 jar 包，即所谓的 extension 机制。</p><p>应用类加载器（Application Class Loader）的父-类加载器是扩展类加载器，它负责加载应用程序路径下的类，这个应用程序路径一般是环境变量 classpath 指定的路径。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接是指将创建成的类合并到 JVM 中，使之能够被执行的过程，这是类加载的核心步骤。链接阶段又可分为验证、准备、解析三个子阶段。</p><p>验证阶段要核验字节信息是否符合JVM 规范，保证加载类能够满足JVM 的约束条件。</p><p>准备阶段，创建并为被加载的类的静态字段分配内存，注意，这里并不会做一般意义上的显式初始化，而只是创建变量并为变量开辟内存空间，做默认的初始化。例如我们 int a = 1，那么在链接的准备阶段，这个 a 的值是 0，并不会赋值为 1。</p><p>在准备阶段，还有一个重要的工作，就是为类构造相关的数据结构，例如实现动态绑定的方法表。在 class 文件被加载至 JVM 之前，一个类无法知道自己和其他类的其方法、字段所对应的具体地址。Java编译时会生成一个符号引用，通过符号引用来无歧义得定位到具体目标上。</p><p>举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。</p><p>解析阶段就是要将符号引用解析为直接引用或实际引用。但是解析阶段的发生是不确定的，它可能在初始化步骤之前，也可能在初始化步骤之后。同时，在类加载的过程中，所有步骤、阶段是按顺序开始，但并不是一定按顺序进行或完成的。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类加载的最后一步是初始化，这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p><p>JVM 规范枚举了下述多种触发情况：</p><ol><li>当虚拟机启动时，初始化用户指定的主类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><p>只有初始化完成之后，一个类才能真正成为可执行的状态。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>双亲委派模型，简单说就是当类加载器（Class Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h3 id="NoClassDefFoundError-和-ClassNotFoundException"><a href="#NoClassDefFoundError-和-ClassNotFoundException" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException"></a>NoClassDefFoundError 和 ClassNotFoundException</h3><p>NoClassDefFoundError 在官方文档中解释是要使用的类的编译时还找得到，但是到了运行的时候找不到了，那么此时就会抛出这个异常。例如，我编译了一个类 B，在类 A 中调用类 B 的方法，但是编译之后我删除了类 B 的 class 文件，此时运行类 A 就会报错 NoClassDefFoundError。</p><p>ClassNotFoundException 情况就比较多了，当通过以下方法来加载类的时候，</p><ol><li>类 Class 中的 forName() 方法</li><li>类 ClassLoader 中的 findSystemClass() 方法</li><li>类 ClassLoader 中的 loadClass() 方法</li></ol><p>但是没有找到具体指定的名称的类的定义，就会报错 ClassNotFoundException。</p><p>从类加载过程来看 NoClassDefFoundError 和 ClassNotFoundException。在加载阶段，如果从 classpath 等路径中找不到所需的类，那么就会报错 ClassNotFoundException，除了上面的三种原因之外，还有可能是因为类被不同类加载器重复加载了导致的。而 NoClassDefFoundError 是在链接步骤中，从内存找不到所需的类，那么就会报错 NoClassDefFoundError。</p><p>总结就是，加载时从外存储器找不到需要的 class 就出现 ClassNotFoundException ，链接时从内存找不到需要的 class 就出现 NoClassDefFoundError 。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础：多态</title>
      <link href="/java-basic-polymorphism.html"/>
      <url>/java-basic-polymorphism.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>我们知道，面向对象的基本要素是封装、继承、多态。其中多态也叫动态绑定，是指程序在执行期间，判断所引用的对象的实际类型，根据实际类型来调用其相应的方法。以下面的代码为例，</p><pre><code class="Java">public class PolymorphTest {  public static void main(String[] args) {    Animal animal = new Dog(&quot;小白&quot;, &quot;白色&quot;);    Animal animal2 = new Cat(&quot;小橘&quot;, &quot;黑色&quot;);    animal.eat();    animal2.eat();  }}class Animal {  private String name;  Animal(String name) {    this.name = name;  }  public void eat() {    System.out.println(&quot;动物在吃东西&quot;);  }}class Dog extends Animal {  private String Color; // 肤色  Dog(String name, String Color) {    super(name);    this.Color = Color;  }  public void eat() {    System.out.println(&quot;小狗在吃骨头&quot;);  }}class Cat extends Animal {  private String eyeColor; // 眼睛色  Cat(String name, String eyeColor) {    super(name);    this.eyeColor = eyeColor;  }  public void eat() {    System.out.println(&quot;小猫在吃小鱼干&quot;);  }}输出：小狗在吃骨头小猫在吃小鱼干</code></pre><p>程序在执行 Animal animal = new Dog(“小白”, “白色”) 时，栈空间内会有一个变量 animal ，animal 指向堆空间中 new 出来的 Dog 对象。在 new 这个 Dog 对象的时候，首先会调用父类 Animal 的构造方法，把名字小白传递给构造方法 Animal(String name) ，然后再初始化自己的私有成员变量 Color。这样，当 Dog 对象的构造方法 Dog(String name, String Color) 执行完毕之后，内存空间中就出现了一个 Dog 对象和一个 Dog 对象的引用 animal 变量，这个 Dog 对象有自己的私有成员变量 Color，同时，Dog 对象中还包含了一个父类的 Animal 对象，这个 Animal 对象中包含了 Dog 对象的名字。</p><p>在方法区中，则存在两个 eat() 方法，分别是父类 Animal 对象的 eat() 方法和子类 Dog 对象的 eat() 方法，当我们执行 animal 的 eat 方法调用时，多态就发挥作用了，它会根据实际 new 出来的对象去取得对应的方法，并执行，所以我们看见了 小狗在吃骨头 而不是 动物在吃东西。</p><p>这里，我们小结一下，多态是指程序在执行期间，判断所引用的对象的实际类型，根据实际类型来调用其相应的方法，实现多态需要三个条件，分别是要有继承，子类要重写 Override 父类的方法，父类引用指向子类对象。</p><h3 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h3><p>那么多态是怎么实现的呢？回想一下类的加载机制，在类加载的准备阶段，Java 虚拟机会为类的静态字段分配内存，同时构造与该类相关联方法表，这个方法表就是实现动态绑定也就是多态的关键所在。</p><p>方法表本质是一个数组，它存储了当前类及其父类中非私有的实例方法。在动态绑定过程中，程序会访问栈空间上的调用者，根据其指向的对象取得调用者的实际类型，然后读取该类型的方法表，进而读取方法表中某个索引下对应的目标方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于多态更加细致的实现暂时先不讨论了，先了解到这里吧。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对比Hashtable、HashMap、TreeMap有什么不同？</title>
      <link href="/java-hashtable-hashmap-treemap.html"/>
      <url>/java-hashtable-hashmap-treemap.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="Map容器"><a href="#Map容器" class="headerlink" title="Map容器"></a>Map容器</h3><p>Map 通常被包括在 Java 集合框架中，但是其本身并不是真正的 Collection 集合类型。 Hashtable 、 HashMap 、 TreeMap 都是 Map 的实现，是以键值对的形式存储和操作数据的容器类型。</p><p><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/java-hashtable-hashmap-treemap/Java Map.png" alt="Java Map"></p><p> Hashtable 继承自  Dictionary 类，而 HashMap 与 TreeMap 继承 AbstractMap 类，它们的类结构上是不同的，不同的实现表明了它们不同的设计目的。</p><p> Hashtable 是 Java 类库关于哈希表的一个早期实现，它的方法都使用 synchronized 进行同步，是线程安全的。 Hashtable 不允许 key 为 null ，不允许 value 为 null 。   </p><p> HashMap 是使用最广的一种哈希表实现，大部分方法与 Hashtable 是相似的，但是减少了同步开销，因此是线程不安全的。 HashMap 允许 key 为 null ，允许 value 为 null 。</p><p> TreeMap 是基于红黑树的一种提供顺序访问的 Map ，与前两者不同，它的 put() 、 get() 等操作的时间复杂度都是 O(log(n)) 。其顺序可以通过 Comparator 来决定，或者根据键值的自然顺序 Comparable 来决定。它也是线程不安全的。 TreeMap 不允许 key 为 null ，允许 value 为 null 。</p><p>对于 TreeMap ，当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对 null 情况实现了特别处理，则可以 put() 存入，但是却不能正常使用 get() 访问，只能通过遍历去访问。</p><p>因此，建议遵循设计的规范，不要做这种使用错误。例如 HashMap 明确声明是线程不安全的，如果不加考虑，直接简单地应用在多线程场景中，总是要出问题的。</p><h3 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h3><p> HashMap 的底层是数组和链表组成的复合结构，数组被分成桶 bucket ，里面存放哈希值，通过哈希值来确定数组寻址时的数组下标。哈希值相同的键值对则以链表的形式存储，如果链表的长度超过阈值 TREEIFY_THRESHOLD = 8 ，则对链表进行改造，转化为红黑树。当红黑树的节点小于阈值 UNTREEIFY_THRESHOLD = 6 时，则对红黑树进行改造，转化为链表。我想这是为了避免链表在阈值附近频繁地转换造成过大的开销而设置的两个临界点。</p><h3 id="HashMap的工作流程"><a href="#HashMap的工作流程" class="headerlink" title="HashMap的工作流程"></a>HashMap的工作流程</h3><h4 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h4><p>存储对象时，将键值对 K/V 传给 put() 方法：</p><pre><code class="Java">public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}</code></pre><p>然后调用 hash() 方法计算 K 的哈希值：</p><pre><code class="Java">static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>这里进行了一个 hashCode() 高位数据移位到低位 h &gt;&gt;&gt; 16 并进行异或运算 ^ 的操作。将高位和低位进行异或运算，只要有高位或低位中有一位的变化，整个 hash() 返回的哈希值就会发生变化，尽可能地减少哈希碰撞。</p><p>在计算得到数组下标之后，通过 putVal() 方法进行存储， putVal() 方法本身的逻辑非常密集，从初始化、扩容、树化都与它有关：</p><pre><code class="Java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p>如果哈希表为 null ， resize() 方法会负责初始化 tab = resize() 。</p><p>当哈希表容量不足时，出现 ++size &gt; threshold ， resize() 方法还会进行扩容。默认的初始化容量参数和最大容量参数如下。</p><pre><code class="Java">/**    * The default initial capacity - MUST be a power of two.    */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16， 2的4次方static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 2的30次方</code></pre><p>如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞。</p><p>如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true ，则更新键值对。</p><p>如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。</p><h4 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h4><p>获取对象时，将 K 传给 get() 方法：</p><p>调用 hash(K) 方法，计算 K 的 hash 值，从而获取该键值所在链表的数组下标。</p><pre><code class="Java">public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}</code></pre><p>然后顺序遍历链表，根据equals()方法查找相同 Node 链表中 K 值对应的 V 值。</p><pre><code class="Java">final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>扩容的方法比较复杂</p><pre><code class="Java">static final float DEFAULT_LOAD_FACTOR = 0.75f; // 负载因子final Node&lt;K,V&gt;[] resize() {    // ...    else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACIY &amp;&amp;                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)        newThr = oldThr &lt;&lt; 1; // double there       // ...     else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {          // zero initial threshold signifies using defaultsfults        newCap = DEFAULT_INITIAL_CAPAITY;        newThr = (int)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；    }    if (newThr ==0) {        float ft = (float)newCap * loadFator;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);    }    threshold = neThr;    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newap];    table = n；    // 移动到新的数组结构e数组结构 }</code></pre><p>如果负载因子 * 容量 &gt; 元素数量，则会进行扩容。扩容时创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小。</p><h4 id="树化改造"><a href="#树化改造" class="headerlink" title="树化改造"></a>树化改造</h4><p>在使用 put() 方法进行存储对象时，除了会遇到扩容方法，还有可能遇到树化改造：</p><pre><code class="Java">static final int MIN_TREEIFY_CAPACITY = 64;final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}</code></pre><p>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。</p><p>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</p><p>HashMap 之所以要进行树化改造，是因为底层结构中链表的遍历时间复杂度是 O(N) 的，在哈希碰撞较为严重的时候，链表较长，其存取性能较低，还可能有额外的安全隐患。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>hashCode 是所有 Java 对象的固有方法，如果不重载的话，返回的实际上是该对象在 JVM 的堆上内存地址，而不同对象的内存地址肯定不同，所以这个 hashCode 也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。</p><h3 id="equals-的特性。"><a href="#equals-的特性。" class="headerlink" title="equals 的特性。"></a>equals 的特性。</h3><p>自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br>对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br>传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br>一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br>非空性：对于任何非空引用值 x，x.equals(null) 都应返回 false。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大部分使用 Map 的场景，通常就是放入、访问或者删除，而对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。HashMap 的性能表现非常依赖于哈希码的有效性，请务必遵守 hashCode 和 equals 的一些基本约定：</p><ul><li>equals 相等，hashCode 一定要相等。</li><li>重写了 hashCode 也要重写 equals。</li><li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li></ul><p>以上内容都基于 jdk1.8.0_161 。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650125459&amp;idx=1&amp;sn=56a14e497b5644eba72f034ac791a4d9&amp;chksm=f36ba9b2c41c20a43611ef0d54747abdaf12f1f867ab23f2f0fc8eac87c657353c734f926cbb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">为啥 HashMap 的默认容量是16？</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651486554&amp;idx=1&amp;sn=23a0786a8c401c799042ac7a9aa0e811&amp;chksm=bd2515258a529c3312285c2536a92a7eb56805ded2eb726b72ab06beabe8e167d00d20789333&amp;scene=126&amp;sessionid=1585703424&amp;key=e7b22394d9386bca990226e723bf6055c836e7d8b7dabe02034009cb225b77c844a21b5027ec82bfa738aa258fea0d41ca89603c0b8e93de1540103a2ec25a970c5c796cb2d499aaa6fce20c5e2772c3&amp;ascene=1&amp;uin=MTIzMjgzNDMyNw%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AxuN6zS95LSdyZL9KQG5Oj0%3D&amp;pass_ticket=LGstMxzdbnh6CyV6rurD3W6ylR1d9GRkDMmoMP80xAWiS91bl%2B2xlMkQ2wePQ23q" target="_blank" rel="noopener">我说我了解集合类，面试官竟然问我为啥 HashMap 的负载因子不设置成1！？</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对比Vector、ArrayList、LinkedList有何区别？</title>
      <link href="/java-vector-arraylist-linkedlist.html"/>
      <url>/java-vector-arraylist-linkedlist.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="Java的集合框架"><a href="#Java的集合框架" class="headerlink" title="Java的集合框架"></a>Java的集合框架</h3><p> Java 提供的主要容器类型分别是集合框架与 Map ，集合通常是指 Collection 接口下的 List 、 Set 、 Queue 三类集合。一般认为 Collection 接口是 Java 集合框架的根，其子集构成了集合框架。 Map 并不属于 Collection 接口的子集，但是在概念是也当做集合来使用，但是它本身并不是真正的集合。注意，所有集合中都不能存放基础数据类型，只能存放对象的引用。</p><p><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/java-vector-arraylist-linkedlist/Java Collection.png" alt="Java Collection"></p><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p> Vector 、 ArrayList 、 LinkedList 是 List 的实现，都是有序集合。它们都提供了诸如随机访问、添加、删除等常用操作，以及迭代器遍历、排序等方法，在功能上较为相近。但是其具体的设计存在一定区别，因此在性能、线程安全等方面有所不同。</p><p>常用方法：</p><ul><li>size() 集合元素个数</li><li>add()/addAll() 添加元素</li><li>remove()/removeAll() 删除元素</li><li>get() 获取元素</li><li>set() 修改元素</li><li>sort() 集合元素排序</li><li>toArray() 转换</li><li>clear() 清空集合</li></ul><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p> Vector 是 Java 早期提供的线程安全的动态数组，内部使用对象数组类保存数据，其线程安全通过 synchronized 实现。</p><pre><code class="Java">public synchronized boolean add(E e) {    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = e;    return true;}public synchronized E remove(int index) {    modCount++;    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    E oldValue = elementData(index);    int numMoved = elementCount - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                            numMoved);    elementData[--elementCount] = null; // Let gc do its work    return oldValue;}</code></pre><p> Vector 默认创建一个大小为 10 的 Object 数组，并将动态扩展大小 capacityIncrement 设置为 0 。 Vector 能够根据需要进行自动扩容，当数组已满时，会创建新的数组，并拷贝原有数据。在初始化时若指定了容量的动态扩展大小 capacityIncrement &gt; 0 则依据指定的大小进行扩容，否则默认扩展一倍的容量。</p><pre><code class="Java">private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                        capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}public Vector() {    this(10);}public Vector(int initialCapacity, int capacityIncrement) {    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                            initialCapacity);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;}</code></pre><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p> ArrayList 是应用最多的动态数组，由于它没有了同步开销，因此性能更加良好。相应的，它不是线程安全的。 ArrayList 也支持动态扩容，但是与 Vector 默认扩容一倍不同， ArrayList 扩容时是增加当前容量的 50% ，其默认容量是 10 。</p><pre><code class="Java">private static final int DEFAULT_CAPACITY = 10;private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p> ArrayList 在执行插入操作时，若元素个数超过当前数组预定义容量的最大值，数组需要扩容，扩容过程需要调用底层 System.arraycopy() 方法进行大量的数组复制操作。它在删除元素时并不会减少数组的容量，但是如果需要缩小数组容量，可以调用 trimToSize() 方法。在查找元素时要遍历数组，对于非 null 的元素采取 equals 的方式寻找。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p> LinkedList 是双向链表，它不需要进行调整容量，它也不是线程安全的。 LinkedList 在插入元素时，须创建一个新的 Entry 对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。</p><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><p> Vector 、 ArrayList 、 LinkedList 内部都实现了排序操作，允许进行自定义排序。</p><pre><code class="Java">public class Test {  public static void main(String[] args) {    LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();    linkedList.add(&quot;c&quot;);    linkedList.add(&quot;b&quot;);    linkedList.add(&quot;a&quot;);    linkedList.sort(new Comparator&lt;String&gt;() {      @Override      public int compare(String o1, String o2) {        return o1.compareTo(o2);      }    });    linkedList.forEach((s) -&gt; {      System.out.print(s + &quot; &quot;);    });  }}输出 a b c </code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> Vector 、 ArrayList 、 LinkedList 是 List 的实现，都是有序集合。 Vector 、 ArrayList 使用数组实现，有需要时可以进行动态扩容， LinkedList 使用双向链表实现，不需要动态扩容。 Vector 是线程安全的，而 ArrayList 、 LinkedList 是线程不安全的。在分析以上三类集合的读写效率时，还应注意的一点是是否需要考尾部的情况。</p><p>以上内容都基于 jdk1.8.0_161 。</p><p><del>JDK源码是四个空格缩进，而我用的是Google Style两个空格缩进，有点不协调orz。</del></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651485602&amp;idx=2&amp;sn=569035c3b6bd1a1028df03517418e84a&amp;chksm=bd2519dd8a5290cb32f88a88fc8f57799b5d25e79452bc66749f83c40f593509931506603623&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575123269344&amp;sharer_shareid=3c5653a301d37ee49e0cb689e723404f#rd" target="_blank" rel="noopener">Java问答：用ArrayList还是LinkedList</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>R语言新手教程：我在哪，我的数据在哪</title>
      <link href="/beginner-guide-to-r-demo1.html"/>
      <url>/beginner-guide-to-r-demo1.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="R语言与RStudio"><a href="#R语言与RStudio" class="headerlink" title="R语言与RStudio"></a>R语言与RStudio</h4><p>我知道新手那种对未知的知识，陌生的工具的恐惧和焦虑，一些对于老手来说就是几条命令行，几条代码的事，对于新手来说可能要摸索好几天才能找到头绪。虽说都有这么一个过程，但是能够尽快走过这个阶段总是好的。</p><p>今天我在一个<code>R</code>语言的群里看到一个新手同学为一个很简单的问题而困恼，不禁想起了我刚接触<code>R</code>语言的时候。不过我本身是计算机专业的学生，可能比较容易学习新的工具。但是对很多非计算机专业的学生来说，学习<code>R</code>语言可能是一件不那么容易的事。</p><p><code>R</code>语言自带了一个<code>GUI</code>，也就是编程时的用户界面了，不过它的风格非常朴素，功能也很朴素，不太适合作为新手上手的工具。因此，我强烈建议使用<code>RStudio</code>，这里并不介绍<code>RStudio</code>的安装、启动，以及<code>RStudio</code>面板上各个窗口表示的内容。相信知乎、简书等网站上有很多详细的中文教程。</p><p>那么这篇文章要介绍什么东西呢？</p><p>很简单，就是如何在<code>RStudio</code>命令窗口中使用<code>R</code>语言，命令它告诉我，我在哪。</p><h4 id="我在哪，我的数据在哪"><a href="#我在哪，我的数据在哪" class="headerlink" title="我在哪，我的数据在哪"></a>我在哪，我的数据在哪</h4><p>我执行了读取文件的命令，但是却显示错误，请问是怎么回事啊？？？</p><p>这是我在群里最容易看到的一个问题。一看新手同学贴出来的<code>R</code>代码可能类似这样：</p><pre><code class="R">&gt; read_csv(&quot;data.csv&quot;)Error: &#39;data.csv&#39; does not exist in current working directory (&#39;F:/Documents&#39;).</code></pre><p>报错信息提示我们，文件<code>data.csv</code>不在工作路径<code>F:/Documents</code>下。也就是说，我现在在的这个地方没有这个东西。那么，首先要知道的就是，我现在在哪里。在<code>R</code>中，可以通过<code>getwd()</code>命令来获取当前所在的工作路径。</p><pre><code class="R">&gt; getwd()[1] &quot;F:/Documents&quot;</code></pre><p>输出的信息提示我们，我现在处于文件夹<code>F:/Documents</code>目录下。然后我又发现，我的<code>data.csv</code>文件其实是在文件夹<code>F:/Documents/test</code>目录下的。那么我该怎么让<code>R</code>读取到它呢？一种方法是改变工作路径，我的数据在哪里，我就要把哪里里当做工作路径。这可以通过<code>setwd()</code>命令来实现。注意，我们需要为该命令指定相应的路径参数，否则该命令将报错，因为你没有告诉<code>R</code>到底去哪里。</p><pre><code class="R">&gt; getwd()[1] &quot;F:/Documents&quot;&gt; setwd(&quot;F:/Documents/test&quot;)&gt; getwd()[1] &quot;F:/Documents/test&quot;</code></pre><p>现在我们来到了文件夹<code>F:/Documents/test</code>目录下，这时，最初那条执行错误的命令可以顺利执行了。</p><pre><code class="R">&gt; read_csv(&quot;data.csv&quot;)Parsed with column specification:cols(  .default = col_double(),  diagnosis = col_character())See spec(...) for full column specifications.# A tibble: 569 x 32</code></pre><p>你看，我们读取到了一个<code>569 x 32</code>的数据框，数据成功地进入了<code>R</code>环境中。这是为什么呢？首先通过如下命令来查看<code>read_csv()</code>的参数。</p><pre><code class="R">&gt; args(read.csv)function (file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\&quot;&quot;, dec = &quot;.&quot;,     fill = TRUE, comment.char = &quot;&quot;, ...) NULL</code></pre><p>可以看到，<code>read_csv()</code>命令中第一个参数是文件。最初的时候，我们位于<code>F:/Documents</code>工作路径，我们指定的<code>data.csv</code>只告诉了文件名，那么<code>read_csv()</code>就会到<strong>相对路径</strong>中寻找。因为<code>read_csv()</code>并不清楚这个东西到底在哪里，那没办法了，就在工作路径里找找看，有就有，没有拉倒吧，别的地方我是不会去找的。此时，这个相对路径就是工作路径。而我的<code>data.csv</code>文件其实是在文件夹<code>F:/Documents/test</code>目录下的，那结果当然是找不到了。</p><p>这时候我们灵机一动，如果我在<code>read_csv()</code>命令中第一个参数中指定<code>data.csv</code>的真实位置和文件名呢？我们依然回到最初的地点，将<code>F:/Documents</code>设置为工作路径，再告诉<code>read_csv()</code>命令<code>data.csv</code>的真实位置和文件名。</p><pre><code class="R">&gt; setwd(&quot;F:/Documents&quot;)&gt; getwd()[1] &quot;F:/Documents&quot;&gt; read_csv(&quot;F:/Documents/test/data.csv&quot;)Parsed with column specification:cols(  .default = col_double(),  diagnosis = col_character())See spec(...) for full column specifications.# A tibble: 569 x 32</code></pre><p>结果顺利地读取到了这个文件。这又是为什么呢？？？这是因为，我们这次告诉<code>read_csv()</code>命令的是<strong>绝对路径</strong>：你必须到这个地方找到这个东西，于是<code>read_csv()</code>就乖乖去找了。</p><p>对于老手来说，可能会觉得这种问题很可笑。但是偏偏就是这些不起眼的问题，常常给新手同学造成很大的烦恼。</p><p>我在哪，我的数据在哪，一切的一切都从这里出发，绽放出耀眼的光彩。</p>]]></content>
      
      <categories>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> RStudio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode股票买卖系列</title>
      <link href="/leetcode-best-time-to-by-and-sell-stock.html"/>
      <url>/leetcode-best-time-to-by-and-sell-stock.html</url>
      <content type="html"><![CDATA[<h4 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h4><p>来看<code>LeetCode</code>的股票买卖系列问题的第一题<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a>。这一题要求在一系列股票价格中，通过一次买卖交易获得最大的收益。假设有这么一组股票价格<code>[7,1,5,3,6,4]</code>，我们只能在买进之后再卖出来赚取收益。很显然，我们需要在第二天的时候以<code>1</code>元的价格买进，然后在第五天的时候以<code>6</code>元的价格卖出，这样得到最大的收益<code>5</code>元。这可以用暴力法通过两层<code>for</code>循环遍历实现，但是还有一个比较好的办法，更加贴近人的思维。</p><p>首先，我们知道，买进时的股价是代价，卖出时的股价和代价之间的差价是收益。我们的目的是希望代价最低，收益最高。以上面的股价序列为例，如果我们在第一天以<code>7</code>元的价格买入股票，这时代价是<code>7</code>，收益是<code>0</code>。到了第二天，现在的股价是<code>1</code>，意味着此时代价可以是<code>1</code>，而收益是<code>1-7</code>等于<code>-6</code>。所以我们更新一下代价，但是不更新收益，此时代价是<code>1</code>，收益是<code>0</code>。从人类的思维来说，这是选择在第二天买进，然后等等看。到了第三天，现在的股价是<code>5</code>，此时的代价可以是<code>5</code>，而收益是此时的股价减去之前的代价<code>5-1</code>等于<code>4</code>。所以我们选择更新收益，但是不更新代价，此时代价是<code>1</code>，收益是<code>4</code>。以此类推，有更小的代价就更新代价，有更高的收益就更新收益。</p><pre><code class="Java">class Solution {  public int maxProfit(int[] prices) {    if (prices.length &lt; 2) {      return 0;    }    int cost = Integer.MAX_VALUE;    int profit = 0;    for (int price : prices) {      cost = Math.min(cost, price);      profit = Math.max(profit, price - cost);    }    return profit;  }}</code></pre><h4 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h4><p>来看<code>LeetCode</code>的股票买卖系列问题的第三题<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III</a>。这一题要求在一系列股票价格中获得最大的收益，最多可以通过两次买卖交易，但是需要第一次买卖交易完成之后才能进行第二次买卖交易。</p><p>与第一题类似，只是可以多一次交易。进行第二次交易时，我们可以把第一次交易的收益当做代价。</p><pre><code class="Java">class Solution {  public int maxProfit(int[] prices) {    if (prices.length &lt; 2) {      return 0;    }    int cost1 = Integer.MAX_VALUE;    int profit1 = 0;    int cost2 = Integer.MAX_VALUE;    int profit2 = 0;    for (int price : prices) {      cost1 = Math.min(cost1, price);      profit1 = Math.max(profit1, price - cost1);      cost2 = Math.min(cost2, price - profit1);      profit2 = Math.max(profit2, price - cost2);    }    return profit2;  }}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>股市有风险，入行需谨慎。股民如何在最好的时机买进股票，并在最好的时机卖出股票，这是一个玄学问题。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>R语言获取标准中国地图</title>
      <link href="/get-china-map-with-R.html"/>
      <url>/get-china-map-with-R.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="地图在哪里"><a href="#地图在哪里" class="headerlink" title="地图在哪里"></a>地图在哪里</h3><p>空间数据分析离不开基础地理数据的支持，比如省市县乡等各级行政区划的数据。然而我国的基础地理数据处于一种薛定谔的状态，往往找不到一个能给出基础地理数据的政府部门的官网。有些网站会共享一部分基础地理数据，但是申请数据的手续有时非常复杂， 即要注册提交个人信息，又要手持身份证拍照，还要写下申请书。于是在大部分情况下只能转向万能的某宝，说多了都是泪。</p><p>最近突然发现，民政部的官网悄咪咪的提供了一个接口可以获取到一些基础地理数据。既然是民政部门提供的数据，那当然是最权威的，再也不用担心有些数据中存在的南海九段线缺失，台湾岛没有等问题啦。</p><h3 id="获取全国县级地图"><a href="#获取全国县级地图" class="headerlink" title="获取全国县级地图"></a>获取全国县级地图</h3><p>民政部提供了省级与县级的 json 格式地图数据，我们可以使用 R 语言的 sf 包读取需要的数据，然后使用 tmap 包来绘制地图。</p><pre><code class="R">library(sf)library(tmap)# 民政部官网url &lt;- &quot;http://xzqh.mca.gov.cn/data/&quot;# 获取全国县级地图xian_quanguo &lt;- sf::st_read(  dsn = paste0(url, &quot;xian_quanguo.json&quot;),  stringsAsFactors = FALSE)# 简单检查一下数据head(xian_quanguo)st_crs(xian_quanguo) &lt;- st_crs(&quot;+proj=longlat +datum=WGS84&quot;)# tmap绘制地图tm_shape(xian_quanguo) +   tm_polygons() +   tm_compass(position = c(&quot;left&quot;, &quot;bottom&quot;)) + # 指北针  tm_scale_bar(position = c(&quot;left&quot;, &quot;bottom&quot;)) # 比例尺</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sf 包的计算效率非常高，是当前 R 语言空间数据分析过程中不可缺少的重要工具，强烈 push。 tmap 包是我接触的比较友好的一种地图可视化包，使用也很简洁，更新也比较及时。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/r-spatial/sf" target="_blank" rel="noopener">sf: A package that provides simple features access for R</a></p><p><a href="https://github.com/mtennekes/tmap" target="_blank" rel="noopener">tmap: R package for thematic maps</a></p>]]></content>
      
      <categories>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 地图 </tag>
            
            <tag> tmap </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说一说二分查找</title>
      <link href="/bin-search.html"/>
      <url>/bin-search.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找也称折半查找，思想很简单，对于一个有序数组，查找数组中是否存在指定元素，只需比较指定元素与数组中间元素的大小关系，通过这种比较来判断下一次查找的范围，直到完成整个查找。尽管二分查找的基本思想相对简单，但有时它的细节可以令人难以招架。</p><h3 id="一个简单的二分查找实现"><a href="#一个简单的二分查找实现" class="headerlink" title="一个简单的二分查找实现"></a>一个简单的二分查找实现</h3><pre><code class="Java"> public int binSearch(int[] nums, int key) {    int left = 0;    int right = nums.length - 1;    while (left &lt;= right) {      int mid = left + ((right - left) &gt;&gt;&gt; 1);      if (nums[mid] &gt; key) {        right = mid - 1;      } else if (nums[mid] &lt; key) {        left = mid + 1;      } else {        return mid;      }    }    return -1;  }</code></pre>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第204题Count Primes</title>
      <link href="/leetcode-count-primes.html"/>
      <url>/leetcode-count-primes.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Count-Primes"><a href="#Count-Primes" class="headerlink" title="Count Primes"></a>Count Primes</h4><p><a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="noopener">Count Primes</a>给出一个数，计算小于这个数的所有的素数个数。例如，输入<code>10</code>，则<code>10</code>以内的素数有四个，分别为<code>2</code>，<code>3</code>，<code>5</code>，<code>7</code>，故返回<code>4</code>。</p><p>求素数的问题相信很多计算机专业的同学在大一刚接触编程的时候一定会碰上，求素数也不难。但是在这里是求素数的个数，一个很简单的思路是调用素数判断的函数，如果是素数则计数加一，最后返回结果。</p><pre><code class="Java"> //Runtime: 548 ms, faster than 13.15% of Java online submissions for Count Primes. public static int countPrimes(int n) {    int count = 0;    for (int i = 1; i &lt; n; i++) {      if (isPrime(i)) {        count++;      }    }    return count;  }  public static boolean isPrime(int n) {    if (n &lt;= 1) {      return false;    }    for (int i = 2; i * i &lt;= n; i++) {      if (n % i == 0) {        return false;      }    }    return true;  }</code></pre><p>但是你也看到了，这样的效率并不高，有没有办法让它更高更快更强呢，答案是有的。</p><p>首先我们知道，所有的偶数都不是素数，也就是说，我们的<code>n</code>中有一半都不是素数，即我们的<code>count</code>最多也就是<code>n/2</code>。</p><p>其次，我们只需要在剩下的一半中寻找素数，或者反向操作寻找不是素数的，然后令<code>count</code>不断地减减。</p><pre><code class="Java">  // Runtime: 6 ms, faster than 99.32% of Java online submissions for Count Primes.  public static int countPrimes2(int n) {    if (n &lt; 3) {      return 0;    }    int count = n / 2;    boolean not_prime[] = new boolean[n];    // i从奇数开始，从奇数中取    // i会取3，5，7，9...    for (int i = 3; i * i &lt; n; i += 2) {      if (not_prime[i] == true) {        continue;      }      // j从奇数开始，从奇数中取，我们要剔除的是i的奇数倍      // j会取 3*3， 3*(3+2)，3*(3+4)，3*(3+6)...      for (int j = i * i; j &lt; n; j += i * 2) {        // 找到count个奇数中的合数，count--，并标记为非素数        if (not_prime[j] == false) {          not_prime[j] = true;          count--;        }      }    }    return count;  }</code></pre><p>是不是更高更快更强了呢。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>素数真好玩。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再见二零一九</title>
      <link href="/goodbye-2019.html"/>
      <url>/goodbye-2019.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="久违的更新"><a href="#久违的更新" class="headerlink" title="久违的更新"></a>久违的更新</h4><p>好久不见，有好多话想说，但是还是决定留在心里，且做后来故事。</p><p>今天是除夕，祝愿大家春节愉快，平安健康。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 成长 </tag>
            
            <tag> 春节 </tag>
            
            <tag> 新年 </tag>
            
            <tag> 久违的更新 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第322题Coin Change</title>
      <link href="/leetcode-coin-change.html"/>
      <url>/leetcode-coin-change.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h4><p><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Coin Change</a>给出不同币值的硬币和一个目标金额，求组成目标金额所需最少的硬币数量，注意，这里可供取用的硬币数据量是不限制的，如果没有可用的硬币，则返回-1即可。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: coins = [2], amount = 3<br>Output: -1</p></blockquote><p>这一题使用暴力法会超时，因此需要改换策略，实际上就是要求使用动态规划来完成。动态规划最头痛的就是递推方程，要了解每一次方程的状态是如何转移的，简直让我选择放弃，好在这一题是找零钱，仿佛小学生奥数似的，稍有些趣味性，不妨挑战一下。</p><p>以示例一为例，我们现在有1，2，5三种币值的硬币，且任意取用。当我们需要11块钱的时候，我们可以选择摸11个一块钱，也可以选择摸5个两块钱和1个一块钱，当然，最少的是摸2个五块钱和1个一块钱。那么这里就存在一种规律了，比如说我们恰好摸了2个五块钱和1个一块钱，完成了任务，可是这个过程中，我们是摸了2个五块钱和1个一块钱的<del>这不是废话嘛！！！</del>注意了，这个2个五块钱和1个一块钱可不简单，它们分别是十块钱和一块钱<del>这又是什么废话啊！！！</del><br>嗯，到这里暗示已经结束，该明示了。就是说，组合11块钱的任务是由组合10块钱和组合1块钱来完成的，而两个组合也恰好是最少的，不仅是组合成11块钱是最少的，他们本身组合成10块钱和组合成1块钱也是最少的。因此，我们的动态规划递推方程中，当前的组合金额<code>(11)</code>还有币值<code>(1,2,5)</code>与之前的组合金额<code>(10,1)</code>是有关联的，我们最终会推到<code>0</code>，也就是什么都不做。</p><p>简单的数学公式是这样的：<br><code>F(11) = min(F(11-1),F(11-2),F(11-5)) + 1</code><br><code>F(11) = min(F(10),F(9),F(6)) + 1</code><br>然后呢我们分别再求<code>F(10)</code>、<code>F(9)</code>、<code>F(6)</code>….</p><p>这个<code>F</code>函数就是我们要实现的摸硬币操作。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><p>注意：外层循环表示可用的硬币组合，内层循环则表示在当前可用的硬币组合下，完成目标金额数所需要的硬币数量。</p><pre><code class="Java">class Solution {  public static int coinChange(int[] coins, int amount) {    if (amount == 0) {      return 0;    }    int[] dp = new int[amount + 1];    Arrays.fill(dp, amount + 1);    dp[0] = 0;    for (int coin : coins) {      for (int i = coin; i &lt; amount + 1; i++) {        dp[i] = Math.min(dp[i], dp[i - coin] + 1);      }    }    return dp[amount] != amount + 1 ? dp[amount] : -1;  }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def coinChange(self, coins, amount):        dp = [0] + [float(&#39;inf&#39;)] * amount        for coin in coins:            for i in range(coin, amount + 1):                dp[i] = min(dp[i], dp[i - coin] + 1)        return dp[-1] if dp[-1] != float(&#39;inf&#39;) else -1 </code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第322题是中等题，除了找零钱有些趣味，动态规划实在打扰了。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>R语言ggplot2绘图转PDF中文乱码问题</title>
      <link href="/r-ggplot2-to-pdf-with-chinese.html"/>
      <url>/r-ggplot2-to-pdf-with-chinese.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="ggplot2与中文乱码的Solution"><a href="#ggplot2与中文乱码的Solution" class="headerlink" title="ggplot2与中文乱码的Solution"></a>ggplot2与中文乱码的Solution</h4><h5 id="字体文件"><a href="#字体文件" class="headerlink" title="字体文件"></a>字体文件</h5><p>首先假设你有一个<code>Windows</code>系统，其次进行R语言编程所使用的<code>IDE</code>是<code>RStudio</code><del>非常好用的集成开发环境</del>。</p><p>然后在<code>Windows</code>系统中找到中文字体，比如宋体或黑体，再找到一个英文字体，比如<code>Times New Roman</code>。它们大概在<code>C盘</code>的<code>Windows/Fonts</code>路径下。</p><p>找出所需的字体文件，比如宋体的字体文件是<code>simsun.ttc</code>，黑体的字体文件是<code>simhei.ttf</code>，<code>Times New Roman</code>的字体文件是<code>times.ttf</code>。</p><p>找到字体文件就是成功的一半了，然后我把它们随便放到一个地方准备加载。</p><h5 id="showtext包"><a href="#showtext包" class="headerlink" title="showtext包"></a>showtext包</h5><p>然后需要在<code>R</code>中调用<code>showtext</code>包，如果没有这个包，请安装它。</p><pre><code class="R"># 调用showtext包library(showtext)showtext_auto(enable = TRUE)# 载入黑体font_add(&quot;heiti&quot;, regular = &quot;F:\\font\\simhei.ttf&quot;)# 载入宋体font_add(&quot;songti&quot;, regular = &quot;F:\\font\\simsun.ttc&quot;)# 载入Times New Roman字体font_add(&quot;newrom&quot;, regular = &quot;F:\\font\\times.ttf&quot;)</code></pre><p>在上面，我们载入了三种字体，并重命名<del>请随意命名</del>后供<code>ggplot2</code>调用。</p><p>注意载入的路径，在<code>Windows</code>下好像要使用反斜杠。</p><p>注意，使用字体的过程中，可能会出现提示没有这种字体！！！！！！无妨，重新执行一下上面的命令可以解决。</p><h5 id="ggplot2绘图带中文"><a href="#ggplot2绘图带中文" class="headerlink" title="ggplot2绘图带中文"></a>ggplot2绘图带中文</h5><pre><code class="R">p &lt;- ggplot() + geom_point() + ... +        theme(axis.title.x = element_text(family=&quot;newrom&quot;), axis.title.y = element_text(family = &quot;songti&quot;)) +        xlab(&quot;Hello World&quot;) +         ylab(&quot;你好世界&quot;)</code></pre><p>在上面的命令中，我们把<code>X</code>轴的字体指定为<code>Times New Roman</code>，<code>Y</code>轴的字体指定为宋体。</p><h5 id="转换为PDF"><a href="#转换为PDF" class="headerlink" title="转换为PDF"></a>转换为PDF</h5><pre><code class="R">p &lt;- ggplot() + geom_point() + ... +        theme(axis.title.x = element_text(family=&quot;newrom&quot;), axis.title.y = element_text(family = &quot;songti&quot;)) +        xlab(&quot;Hello World&quot;) +         ylab(&quot;你好世界&quot;)ggsave(&quot;Fig_p.pdf&quot;, plot = p)</code></pre><p>在上面的命令中，我们把<code>p</code>转换为了<code>PDF</code>。再次提醒，这个过程中，可能会出现提示没有这种字体！！！！！！无妨，重新执行一下上面的字体加载命令即可解决。</p><p>然后我们查看一下生成的<code>PDF</code>，应该会得到一个<code>X</code>轴字体是<code>Times New Roman</code>的英文<code>Hello World</code>，<code>Y</code>轴字体是宋体的中文你好世界。</p><p>如果你使用<code>RStudio</code>的图片预览功能，并且尝试<code>Save as PDF</code>，那么可能依然会出现中文乱码问题。</p><p>去试试看吧！</p><h4 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h4><p>上面的内容只能解决文字中不包含中英文混合的情况。如果需要中英文混合，那么可能需要把某两种中英文字体文件合并生成新的字体文件，然后加载进来才行。</p>]]></content>
      
      <categories>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> RStudio </tag>
            
            <tag> ggplot2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第104题Maximum Depth of Binary Tree</title>
      <link href="/leetcode-maximum-depth-of-binary-tree.html"/>
      <url>/leetcode-maximum-depth-of-binary-tree.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h4><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a>求二叉树的最大深度。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5]<br>Output: 4</p></blockquote><p>二叉树的深度可以通过深度优先搜索和广度优先搜索两种方式来遍历，并记录树的层次。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    // dfs    public int maxDepth(TreeNode root) {        return root == null ? 0 : 1 + Math.max(maxDepth(root.left),maxDepth(root.right));    }    // bfs    public int maxDepth(TreeNode root) {        if (root == null) return 0;        Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);        int depth = 0;        while (!q.isEmpty()){            int size = q.size();            while (size-- &gt; 0){                TreeNode node = q.poll();                if (node.left != null){                    q.offer(node.left);                }                if (node.right != null){                    q.offer(node.right);                }            }            depth++;        }        return depth;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # dfs    def maxDepth(self, root: TreeNode) -&gt; int:        if not root: return 0        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))    # bfs    def maxDepth(self, root):        if not root: return 0        q = collections.deque([(root, 1)])        while q:            curr, depth = q.popleft()            if not curr.left and not curr.right and not q:                return depth            if curr.left:                q.append((curr.left, depth + 1))            if curr.right:                q.append((curr.right, depth + 1))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第104题是简单题，只需熟悉二叉树的深度优先搜索与广度优先搜索，并记录对应的层次即可。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第111题Minimum Depth of Binary Tree</title>
      <link href="/leetcode-minimum-depth-of-binary-tree.html"/>
      <url>/leetcode-minimum-depth-of-binary-tree.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h4><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a>求二叉树的最小深度。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5]<br>Output: 3</p></blockquote><p>二叉树的深度可以通过深度优先搜索和广度优先搜索两种方式来遍历，并记录树的层次。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    // dfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        int left = minDepth(root.left);        int right = minDepth(root.right);        return (left == 0 || right ==0) ? left + right + 1 : Math.min(left, right) + 1;    }    // bfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);        int depth = 1;        while (!q.isEmpty()){            int size = q.size();            while (size-- &gt; 0){                TreeNode node = q.poll();                if (node.left == null &amp;&amp; node.right == null){                   return depth;                }                if (node.left != null){                    q.offer(node.left);                }                if (node.right != null){                    q.offer(node.right);                }            }            depth++;        }        return depth;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # dfs    def minDepth(self, root: TreeNode):        if not root:            return 0        if not root.left and not root.right:            return 1        if root.left and not root.right:            return 1 + self.minDepth(root.left)        if root.right and not root.left:            return 1 + self.minDepth(root.right)        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))    # bfs    def minDepth(self, root):        if not root: return 0        q = collections.deque([(root, 1)])        while q:            curr, depth = q.popleft()            if not curr.left and not curr.right:                return depth            if curr.left:                q.append((curr.left, depth + 1))            if curr.right:                q.append((curr.right, depth + 1))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第111题是简单题，只需熟悉二叉树的深度优先搜索与广度优先搜索，并记录对应的层次即可。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第235题Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html"/>
      <url>/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Search Tree</a>给定一个二叉<strong>搜索</strong>树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p></blockquote><p>这一题和236题<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>有些相似，二叉搜索树是二叉树的一种，所以236题的解法也适用于这题。特别的是，二叉搜索树中根节点的值大于左子树的节点值，小于右子树的节点值，这是可以利用的一个性质：</p><ul><li>我们记<code>LCA(2,8) = 6</code>，此时节点<code>p</code>和<code>q</code>是2和8，我们将节点值与根节点值6进行比较，发现<code>p</code>和<code>q</code>分别位于根节点左右两侧，此时根节点6是最近祖先。</li><li>我们记<code>LCA(7,9) = 8</code>，此时节点<code>p</code>和<code>q</code>是7和9，我们将节点值与根节点值6进行比较，发现<code>p</code>和<code>q</code>都大于根节点，都位于右子树，于是，我们进入右子树进行遍历，此时原来右子树的根节点8成为新的根节点，继续遍历比较。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        int parentVal = root.val;        int pVal = p.val;        int qVal = q.val;        if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {            return lowestCommonAncestor(root.right, p, q);        } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {            return lowestCommonAncestor(root.left, p, q);        } else {            return root;        }    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q):        if p.val &lt; root.val &gt; q.val:            return self.lowestCommonAncestor(root.left, p, q)        if p.val &gt; root.val &lt; q.val:            return  self.lowestCommonAncestor(root.right, p, q)        return  root</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第235题是简单题，利用二叉<strong>搜索</strong>树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019年国庆节</title>
      <link href="/national-day-of-the-people-s-republic-of-china.html"/>
      <url>/national-day-of-the-people-s-republic-of-china.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="国庆·1949-2019"><a href="#国庆·1949-2019" class="headerlink" title="国庆·1949-2019"></a>国庆·1949-2019</h4><p>今年的国庆节似乎有些特别，从大面上来说，我感受到非常高涨的热情，无论是朋友圈还是微博，也许是这一年发生太多以往没有发生的事，让普通群众们了解到了周边生活之外的零零碎碎，激发起了内心朴素的那一份感情：希望这个国家好。当然，我也清楚地知道，恨不得这个国家立即从地球上消失的也大有人在，怎么说呢，求同存异吧，我认为对于普通人来说，只要过好手头的日子，做好自己的工作，爱护自己的家人朋友，就是最大的爱国。别的嘛，牢骚太盛防肠断，风物长宜放眼量。我相信未来会越来越好，从深渊回望，莫回头，莫回头。</p><h4 id="阅兵·游行·联欢"><a href="#阅兵·游行·联欢" class="headerlink" title="阅兵·游行·联欢"></a>阅兵·游行·联欢</h4><p>今年的国庆阅兵、群众游行、国庆联欢晚会三部曲都非常出乎我的意料，实在是太惊喜了，组织度这么高，组织能力这么强足以说明我国的体制在集中力量办大事这方面有着无与匹敌的优势，只要方向正确，中国人民总是能干出惊天动地的事业，这一点，从我中国人民解放军军史上就有许多明证。例如阅兵中给我印象最深刻的就是战旗方队，一百面英雄的旗帜，无数英勇的先烈们。其中有些部队本身可能出身于解放战争后期国民党方面的队伍，战斗力差，战斗意志弱，而起义、投诚、收编到了解放军中之后，仿佛脱胎换骨一般，这里面岂无值得深思的地方？</p><p>祝愿伟大祖国繁荣昌盛，期待建国一百周年，那时候的世界，又会是怎样一番天地呢。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 时事 </tag>
            
            <tag> 国庆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第236题Lowest Common Ancestor of a Binary Tree</title>
      <link href="/leetcode-lowest-common-ancestor-of-a-binary-tree.html"/>
      <url>/leetcode-lowest-common-ancestor-of-a-binary-tree.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>给定一个二叉树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="Lowest Common Ancestor of a Binary Tree Example1"></p><blockquote><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.</p></blockquote><p>如何寻找最近公共祖先呢，我们可以通过遍历目标结点<code>q</code>和<code>p</code>的路径，得到其中重合的最近的部分，这很直接，比较好理解。这里我们使用递归的方式来遍历，从根节点开始分别遍历左右子树，如果目标结点仅存在于左子树内，那么最近公共节点必然位于左子树内，如果目标结点同时存在于左右子树内，那么最近公共节点必然是根节点。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root == null || root == p || root == q) return root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        return left == null ? right : right == null ? left : root;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q)        if root in {None, p, q}:            return root        left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        return root if (left and right) else (left or right)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第236题是中等题，利用二叉树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第242题Valid Anagram</title>
      <link href="/leetcode-valid-anagram.html"/>
      <url>/leetcode-valid-anagram.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h4><p><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">Valid Anagram</a>给出两个字符串<code>s</code>和<code>t</code>，查看字符串<code>t</code>是否是字符串<code>s</code>的异位词。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: s = “anagram”, t = “nagaram”<br>Output: true</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: s = “rat”, t = “car”<br>Output: false</p></blockquote><p>这一题很简单，只需要用哈希的方法来解决，我们使用一个一维数组，数组的长度是26，里面我们存放26个字母的计数，如果字符<code>c</code>同时存在与字符串<code>s</code>与字符串<code>t</code>中，则该字符在数组中<code>+1</code>再<code>-1</code>记为零，只要数组中存在不为零的元素，则字符串<code>s</code>和字符串<code>t</code>不是有效的异位词。</p><p>还可以使用字符数组排序的方法，如果字符串<code>s</code>和字符串<code>t</code>是有效异位词，那么两者包含的字符在唯一性上是相等的，排序后的序列也必定相等。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) return false;        int[] counter = new int[26];        for (int i = 0; i &lt; s.length(); i++) {            counter[s.charAt(i) - &#39;a&#39;]++;            counter[t.charAt(i) - &#39;a&#39;]--;        }        for (int count : counter) {            if (count != 0) {                return false;            }        }        return true;    }    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) {            return false;        }        char[] str1 = s.toCharArray();        char[] str2 = t.toCharArray();        Arrays.sort(str1);        Arrays.sort(str2);        return Arrays.equals(str1, str2);    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        if len(s) != len(t): return False        count = collections.defaultdict(int)        for c in s:            count[c] += 1        for c in t:            count[c] -= 1            if count[c] &lt; 0:                return False        return True</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第242题是简单题，冲鸭！</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第239题Sliding Window Maximum</title>
      <link href="/leetcode-sliding-window-maximum.html"/>
      <url>/leetcode-sliding-window-maximum.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Sliding-Window-Maximum"><a href="#Sliding-Window-Maximum" class="headerlink" title="Sliding Window Maximum"></a>Sliding Window Maximum</h4><p><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a>，给定一个数组<code>num</code>，一个大小为<code>k</code>的滑动窗口，该窗口从数组的最左边移到最右边，得出窗口内的最大值。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3<br>Output: [3,3,5,5,6,7]<br>Explanation: </p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">Max</th></tr></thead><tbody><tr><td style="text-align:center"><strong>[1</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>-1]</strong></td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>-1</strong></td><td style="text-align:center"><strong>-3]</strong></td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center"><strong>[-1</strong></td><td style="text-align:center"><strong>-3</strong></td><td style="text-align:center"><strong>5]</strong></td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center"><strong>[-3</strong></td><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>3]</strong></td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center"><strong>[5</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>6</strong>]</td><td style="text-align:center">7</td><td style="text-align:center"><strong>6</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>7]</strong></td><td style="text-align:center"><strong>7</strong></td></tr></tbody></table><p>这一题和<a href="https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html">Kth Largest Element in a Stream</a>寻找一个整数流中第<code>K</code>大的元素非常相似，也可以使用队列来完成。这里使用一个双端队列<code>Deque</code>，队列中存放当前窗口最大值的数组下标，每当滑动窗口的时候，就记录一次结果。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || k &lt;= 0) return new int[0];        int[] res = new int[nums.length - k + 1];//保存结果        ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;();//双端队列        int index = 0;        for (int i = 0; i &lt; nums.length; i++){            while (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){//越界                deque.poll();            }            while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]){                deque.pollLast();//从右向左剔除，确保最左是当前窗口最大值            }            deque.offer(i);//存放的是位置索引            if (i &gt;= k - 1){                res[index++] = nums[deque.peek()];            }        }        return res;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:            if not nums: return []        window , res = [], []        for i, x in enumerate(nums):            if i &gt;= k and window[0] &lt;= i - k:                window.pop(0)            while window and nums[window[-1]] &lt;= x:                window.pop()            window.append(i)            if i &gt;= k -1:                res.append(nums[window[0]])        return res</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第239题是难题，但是使用合适的数据结构和对应的逻辑，就能很好的完成，自带API真香。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 队列 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第703题Kth Largest Element in a Stream</title>
      <link href="/leetcode-kth-largest-element-in-a-stream.html"/>
      <url>/leetcode-kth-largest-element-in-a-stream.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Kth-Largest-Element-in-a-Stream"><a href="#Kth-Largest-Element-in-a-Stream" class="headerlink" title="Kth Largest Element in a Stream"></a>Kth Largest Element in a Stream</h4><p><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">Kth Largest Element in a Stream</a>寻找一个整数流中第<code>K</code>大的元素，<code>K</code>是固定的，整数流包含一个构造函数<code>add</code>，每次往流中添加新元素时，就返回新的第<code>K</code>大的元素。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8</p></blockquote><p>这道题可以使用优先队列<code>PriorityQueue</code>来做，在<code>Java</code>中优先队列默认通过二叉小顶堆实现。我们可以令这个优先队列的长度为<code>K</code>，这个队列的头部就是整数流中第<code>K</code>大的元素，每当新的元素进来时，我们就把新的元素和队列头部元素（也就是堆顶）进行比较，如果新的元素比较大，则纳入新的元素。优先队列会自动维护小顶堆的性质，保证队列头部元素始终是我们需要的第<code>K</code>大的元素。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class KthLargest {       PriorityQueue&lt;Integer&gt; q;    int k;    public KthLargest(int k, int[] nums) {        this.k = k;        q = new PriorityQueue&lt;&gt;(k);        for (int n : nums){            add(n);        }           }    public int add(int val) {        if (q.size() &lt; k){            q.offer(val);        }else if (q.peek() &lt; val){            q.poll();            q.offer(val);        }        return q.peek();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class KthLargest:    def __init__(self, k, nums):        self.pool = nums        self.k = k        heapq.heapify(self.pool)        while len(self.pool) &gt; k:            heapq.heappop(self.pool)    def add(self, val):        if len(self.pool) &lt; self.k:            heapq.heappush(self.pool, val)        elif val &gt; self.pool[0]:            heapq.heapreplace(self.pool, val)        return self.pool[0]</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第703题是简单题，学会利用已有的数据结构，加一点简单的逻辑，能做很多神奇的事，再也不要暴力循环了鸭。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 队列 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第225题Implement Stack using Queues</title>
      <link href="/leetcode-implement-stack-using-queues.html"/>
      <url>/leetcode-implement-stack-using-queues.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Implement-Stack-using-Queens"><a href="#Implement-Stack-using-Queens" class="headerlink" title="Implement Stack using Queens"></a>Implement Stack using Queens</h4><p><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">Implement Stack using Queens</a>用队列实现栈。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>MyStack stack = new MyStack();<br>stack.push(1);<br>stack.push(2);<br>stack.top();   // returns 2<br>stack.pop();   // returns 2<br>stack.empty(); // returns false</p></blockquote><p>栈的特性是先进后出，队列的特性是先进先出，我们要实现栈的三个操作，分别是<code>push</code>、<code>pop</code>、<code>top</code>，还有一个栈状态检查<code>empty</code>。类似用栈实现队列时，使用两个栈互相倒腾，这里用队列实现栈也可以使用两个队列来实现栈，燃鹅本文选择使用一个队列来实现栈，非炫技也，实有趣耳。</p><p>使用一个队列时，<code>push</code>操作很平常，就把元素压入队列中即可，即压入栈中。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table><p>执行<code>pop</code>操作时，由于栈是先进后出的，先前<code>push</code>入队的队列头部元素应该在栈底，而队列尾部元素是栈顶。也就是说，我们要<code>pop</code>的是队列尾部元素，那么怎么将尾部元素<code>pop</code>出去呢？</p><p>很简单，我们让除了队列末尾元素之外的其他队列元素出队，那原来的队尾元素不就变成新的队首元素了吗，让这个新的队首元素出队就是栈的<code>pop</code>操作，而出队的其他元素则再依次入队，保证栈<code>pop</code>之后其他元素没有丢失。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><p>执行<code>top</code>操作时和<code>pop</code>类似，只不过我们返回队首元素即可，注意，由于这个队首元素是原来的队尾元素，所以我们在使用过它之后，要让它出队再入队，保证它依然处于队尾，也就是栈顶。</p><p>状态检查只需查看队列是否为空即可。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        q.offer(x);    }    /** Removes the element on top of the stack and returns that element. */    public int pop() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        return q.poll();    }    /** Get the top element. */    public int top() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        int top = q.peek();        q.offer(q.poll());        return top;    }    /** Returns whether the stack is empty. */    public boolean empty() {        return q.isEmpty();    }}</code></pre><p>下面是相似的<code>Java</code>代码，请关注两者的区别：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        queue.add(x);        for (int i=1; i&lt;queue.size(); i++)            queue.add(queue.remove());    }    /** Removes the element on top of the stack and returns that element. */    public void pop() {        queue.remove();    }    /** Get the top element. */    public int top() {        return queue.peek();    }    /** Returns whether the stack is empty. */    public boolean empty() {        return queue.isEmpty();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class MyStack:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.queue = []    def push(self, x: int) -&gt; None:        &quot;&quot;&quot;        Push element x onto stack.        &quot;&quot;&quot;        self.queue.append(x)    def pop(self) -&gt; int:        &quot;&quot;&quot;        Removes the element on top of the stack and returns that element.        &quot;&quot;&quot;        return self.queue.pop()    def top(self) -&gt; int:        &quot;&quot;&quot;        Get the top element.        &quot;&quot;&quot;        return self.queue[-1]    def empty(self) -&gt; bool:        &quot;&quot;&quot;        Returns whether the stack is empty.        &quot;&quot;&quot;        return self.queue == []</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第225题是简单题，用一个队列实现栈其实也不难，关键依然是理解先进先出和先进后出之间的关联。这里<code>Python</code>的逻辑和分析中有所区别，主要是<code>Python</code>的内置函数太强大了，完全不需要多余的操作。。。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第232题Implement Queen using Stacks</title>
      <link href="/leetcode-implement-queen-using-stacks.html"/>
      <url>/leetcode-implement-queen-using-stacks.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Implement-Queen-using-Stacks"><a href="#Implement-Queen-using-Stacks" class="headerlink" title="Implement Queen using Stacks"></a>Implement Queen using Stacks</h4><p><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">Implement Queen using Stacks</a>用栈实现一个队列。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // returns 1<br>queue.pop();   // returns 1<br>queue.empty(); // returns false</p></blockquote><p>队列的特性是先进先出，栈的特性是先进后出，我们要实现队列的三个操作，分别是<code>push</code>、<code>pop</code>、<code>peek</code>，还有一个队列状态检查<code>empty</code>。可以使用两个栈来实现，分别是<code>input</code>、<code>output</code>，两者的分工非常清楚：</p><ul><li>所有的<code>push</code>操作，进队列的元素通通丢到<code>input</code>栈中。</li><li>所有的<code>pop</code>、<code>peek</code>操作，出队列的元素通通在<code>output</code>栈中输出。</li><li>状态检查时，只需要检查两个栈是否都为空，如果是，则队列为空。</li></ul><p>需要注意的地方是，两个栈之间如何互相“倒腾”元素。例如我们<code>push</code>了4次得到一个队列<code>[1，2，3，4]</code>，然后<code>pop</code>一次弹出元素<code>[1]</code>，队列中剩下<code>[2，3，4]</code>，我们再往里<code>push</code>元素<code>[5]</code>，得到队列<code>[2，3，4，5]</code>。那么这个过程中，<code>input</code>栈与<code>output</code>栈之间需要“倒腾”一下，4次<code>push</code>很简单，元素通通压入了<code>input</code>栈，此时<code>output</code>栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr></tbody></table><p>当我们执行<code>pop</code>时，需要把<code>input</code>栈中的元素“倒腾”到<code>output</code>栈中，再从<code>output</code>栈中<code>pop</code>出栈顶元素，此时<code>input</code>栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">4</td></tr></tbody></table><p>再往队列中<code>push</code>元素<code>[5]</code>时，需要把<code>output</code>栈中的元素“倒腾”到<code>input</code>栈中，再将新元素<code>[5]</code>给<code>push</code>到栈顶，此时<code>output</code>栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr></tbody></table><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class MyQueue {    Stack&lt;Integer&gt; input ;    Stack&lt;Integer&gt; output ;    /** Initialize your data structure here. */    public MyQueue() {        input = new Stack&lt;&gt;();        output = new Stack&lt;&gt;();    }    /** Push element x to the back of queue. */    public void push(int x) {        if (input.isEmpty()){            while (!output.isEmpty()){                input.push(output.pop());            }        }        input.push(x);    }    /** Removes the element from in front of queue and returns that element. */    public int pop() {        if (output.isEmpty()){            while (!input.isEmpty()){                output.push(input.pop());            }        }        return output.pop();    }    /** Get the front element. */    public int peek() {        if (output.isEmpty()){            while (!input.isEmpty()){                output.push(input.pop());            }        }        return output.peek();    }    /** Returns whether the queue is empty. */    public boolean empty() {        return input.isEmpty() &amp;&amp; output.isEmpty();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class MyQueue:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.input = []        self.output = []    def push(self, x: int) -&gt; None:        &quot;&quot;&quot;        Push element x to the back of queue.        &quot;&quot;&quot;        if len(self.input) == 0:            while len(self.output) != 0:                self.input.append(self.output.pop())        self.input.append(x)    def pop(self) -&gt; int:        &quot;&quot;&quot;        Removes the element from in front of queue and returns that element.        &quot;&quot;&quot;        if len(self.output) == 0:            while len(self.input) != 0:                self.output.append(self.input.pop())        return self.output.pop()    def peek(self) -&gt; int:        &quot;&quot;&quot;        Get the front element.        &quot;&quot;&quot;        if len(self.output) == 0:            while len(self.input) != 0:                self.output.append(self.input.pop())        return self.output[-1]    def empty(self) -&gt; bool:        &quot;&quot;&quot;        Returns whether the queue is empty.        &quot;&quot;&quot;        return len(self.input) == 0 and len(self.output) == 0</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第232题是简单题，两个数据结构的特性也非常清楚，关键在于理清先进先出与先进后出两个特性之间的关联。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第141题Linked List Cycle</title>
      <link href="/leetcode-linked-list-cycle.html"/>
      <url>/leetcode-linked-list-cycle.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h4><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a>判断链表是否有环。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p></blockquote><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example"></p><p>方法有两种：</p><ul><li>一种是使用<code>Set</code>的数据结构来遍历整个链表，只要链表中存在环，那么Set中必定会出现重复值，通过这种重复的冲突就可以判断链表中有无环。</li><li>另一种方法是使用<code>两个标兵</code>来遍历，一个跑得比香港记者还要快，一个跑得比香港记者慢，如果链表中存在环，那么快的标兵必定会在跑完一圈之后追上慢的标兵，通过这种追赶也能判断链表中有无环。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */class Solution {    public boolean hasCycle(ListNode head) {// Set        Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();        while (head != null) {            if (nodesSeen.contains(head)) {                return true;            } else {                nodesSeen.add(head);            }            head = head.next;        }        return false;    }    public boolean hasCycle(ListNode head) {// 标兵        if (head == null || head.next == null) {            return false;        }        ListNode slow = head;        ListNode fast = head.next;        while (slow != fast) {            if (fast == null || fast.next == null) {                return false;            }            slow = slow.next;            fast = fast.next.next;        }        return true;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def hasCycle(self, head): # Set        nodeset = set()        while head:            if head in nodeset:                return True            else:                nodeset.add(head)            head = head.next        return False    def hasCycle(self, head): # 标兵        fast = slow = head        while slow and fast and fast.next:            slow = slow.next            fast = fast.next.next            if slow is fast:                return True        return False</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第141题是简单题，<code>Set</code>的方法比较容易想到，<code>Set</code>也非常适合做重复检测的工作。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第206题Reverse Linked List</title>
      <link href="/leetcode-reverse-linked-list.html"/>
      <url>/leetcode-reverse-linked-list.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h4><p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a>反转单链表。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><p>我们需要三个指针，<code>prev</code>-&gt;<code>curr</code>-&gt;<code>next</code>，从头指针开始反转，令<code>curr</code>-&gt;<code>prev</code>，完成一个元素的反转之后，令其下一个元素为<code>curr</code>指针指向的对象，直到当前元素<code>curr</code>为空，可以使用遍历或递归的方式来实现。</p><table><thead><tr><th style="text-align:center">prev</th><th style="text-align:center">curr</th><th style="text-align:center">next</th><th style="text-align:center">…</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">…</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">…</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">…</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">…</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td><td style="text-align:center">…</td></tr></tbody></table><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseList(ListNode head) {// 遍历        ListNode re_head = null;        for (ListNode curr = head; curr != null; ){            ListNode temp = curr.next;            curr.next = re_head;            re_head = curr;            curr = temp;        }        return re_head;    }    public ListNode reverseList(ListNode head) {// 递归        if (head == null || head.next == null) return head;        ListNode re_head = reverseList(head.next);        head.next.next = head;        head.next = null;        return re_head;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reverseList(self, head):  # 遍历        re_head, curr = None, head        while curr:            curr.next, re_head, curr = re_head, curr, curr.next        return re_head    def reverseList(self, head: ListNode) -&gt; ListNode: # 递归        if head == None or head.next == None:            return head        temp = head.next        re_head = self.reverseList(temp)        head.next = None        temp.next = head        return re_head</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>LeetCode</code>题目的难度是变动的，这一题之前还是中等题，最近变成了简单题，可能是练习的人多了，<code>Accepted</code>高了，说明基础还是很重要的。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第24题Swap Nodes in Pairs</title>
      <link href="/leetcode-swap-nodes-in-pairs.html"/>
      <url>/leetcode-swap-nodes-in-pairs.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h4><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a>给定一个链表，交换两个相邻节点，注意，不能修改列表节点中的值，只能更改节点本身的顺序。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p></blockquote><p>链表的结点交换或反转没有什么特别的地方，就是一把梭。<code>LeeCode</code>已经给我们定义好了结点<code>Node</code>：一个指针，一个结点值，交换函数传入参数的是头指针。当结点数是偶数的时候，没有问题，当结点数是奇数的时候，最后一个结点的下一个结点是<code>Null</code>，就不能交换或反转。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode swapPairs(ListNode head) {        if (head == null) return null;        if (head.next == null) return head;        ListNode temp = head.next;        head.next = head.next.next;        temp.next = head;        head = temp;        head.next.next = swapPairs(head.next.next);        return head;           }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        pre, pre.next = self, head        while pre.next and pre.next.next:            a = pre.next            b = a.next            pre.next, b.next, a.next = b, a, b.next            pre = a        return  self.next</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第24题是中等题，逻辑很简单，但是编码上有一些细节，别把自己绕晕了。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第22题Generate Parentheses</title>
      <link href="/leetcode-generate-parentheses.html"/>
      <url>/leetcode-generate-parentheses.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h4><p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">Generate Parentheses</a>给定一个正整数，生成有效括号的所有组合，这里只需要生成小括号即可。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>Input: n = 3<br>Output: [<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><p>可见，当<code>n</code>确定时，生成的解的长度是固定的<code>2n</code>，并且解的开头一定是左括号，如果是右括号则是无效的解，左括号与右括号的数量必定是一样的，都是<code>n</code>个，这些是分析题目要求得到的“先验知识”了，接下来开始<code>Code</code><del>贝叶斯推断bushi</del>。</p><p>怎么办呢，可以用递归或者说深度优先搜索的方法来遍历，每一个解看成一个长度<code>2n</code>的一维数组，我们往里面填充左括号和右括号，起始值都是<code>n</code>个，用掉一个就减去一个。如果当前还有左括号，就使用一个左括号，同时，如果右括号的数量比左括号多，则为左括号匹配一个右括号，直到两者都用完为止。</p><h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {  public List&lt;String&gt; generateParenthesis(int n) {    List&lt;String&gt; res = new ArrayList&lt;&gt;();    generate(&quot;&quot;, res, n, n);    return res;  }  public void generate(String sublist, List&lt;String&gt; res, int left, int right) {    if (left == 0 &amp;&amp; right == 0) {      res.add(sublist);      return;    }    if (left &gt; 0) {      generate(sublist + &quot;(&quot;, res, left - 1, right);    }    if (right &gt; left) {      generate(sublist + &quot;)&quot;, res, left, right - 1);    }  }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        def generate(p, left, right, parens=[]):            if left:                generate(p + &#39;(&#39;, left - 1, right)            if right &gt; left:                generate(p + &#39;)&#39;, left, right - 1)            if not right:                parens += p,            return parens        return generate(&#39;&#39;, n, n)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第22题是一个中等题，难度还不算非常大，递归的方法也非常简洁易懂，加油↖(^ω^)↗</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第20题Valid Parentheses</title>
      <link href="/leetcode-valid-parentheses.html"/>
      <url>/leetcode-valid-parentheses.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h4><p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a>的要求是匹配括号的合法性。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: “()”<br>Output: true</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: “()[]{}”<br>Output: true</p></blockquote><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h5><blockquote><p>Input: “(]”<br>Output: false</p></blockquote><p><del>解法明天再写，回去洗洗睡先。</del></p><p>方法是使用一个栈的数据结构来匹配括号，我们将每一个元素和三种括号分别进行匹配，如果是<code>“(”</code>那么就往栈里<code>push</code>进一个它的“解”也就是<code>“)”</code>，中括号和大括号也类似，也就是说我们匹配到一个左括号就往栈里<code>push</code>进一个“解”—右括号。</p><p>假设当前的括号序列是<code>“()[]{}”</code>，当匹配到第一个元素<code>“(”</code>的时候，栈里面就<code>push</code>进一个<code>“)”</code>，当匹配走到第二个元素<code>“)”</code>的时候，由于它不是待匹配的左括号，而是“解”，所以我们<code>pop</code>栈中的内容，刚好发现栈里面有一个<code>“)”</code>,于是将它<code>pop</code>出去，同理解决余下的元素，最后发现，栈是空的，且所有元素都匹配完了，说明没有非法的括号。如果中途栈就空了，而当前待匹配的不是左括号而是“解”—右括号，则说明已经无解了。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public boolean isValid(String s) {        if (s == null || s.length() == 0) return true;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (Character ch : s.toCharArray()) {            if (ch == &#39;(&#39;){                stack.push(&#39;)&#39;);            } else if (ch == &#39;[&#39;){                stack.push(&#39;]&#39;);            } else if (ch == &#39;{&#39;){                stack.push(&#39;}&#39;);            } else {                if (stack.isEmpty() || stack.pop() != ch){                    return false;                }            }        }        return stack.isEmpty();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def isValid(self, s: str) -&gt; bool:        stack = []        paren_map = {&#39;)&#39;:&#39;(&#39;, &#39;]&#39;:&#39;[&#39;, &#39;}&#39;:&#39;{&#39;}        for c in s:            if c not in paren_map:                stack.append(c)            elif not stack or paren_map[c] != stack.pop():                return False        return not stack</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第20题是简单题，只要对栈这种数据结构稍微熟悉就能知道该怎么办，数据结构与算法的课程讲到栈这一节的时候也提到过括号匹配的问题<del>我猜大部分同学用的是严蔚民老师的那本经典教材</del>。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第15题Three Sum</title>
      <link href="/leetcode-three-sum.html"/>
      <url>/leetcode-three-sum.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Three-Sum"><a href="#Three-Sum" class="headerlink" title="Three Sum"></a>Three Sum</h4><p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">Three Sum</a>和<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">TwoSum</a>属于类似的题目，<code>ThreeSum</code>要求是，给定一个数组和一个目标值，求得数组中<code>a</code>+<code>b</code>+<code>c</code>=<code>0</code>的三个数<code>a</code>，<code>b</code>，<code>c</code>，这里目标数定为了零。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Given array nums = [-1, 0, 1, 2, -1, -4]</p></blockquote><blockquote><p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><p>解法如下，首先对数组进行从小到大排序，假定当前这个数<code>nums[i]</code>为<code>a</code>，我们在后面的数中寻找<code>b</code>和<code>c</code>，使得<code>a</code>+<code>b</code>+<code>c</code>=<code>0</code>。记住，我们已经排序过了，所以可以从两头进行夹逼，遍历满足条件的<code>b</code>和<code>c</code>，当<code>a</code>+<code>b</code>+<code>c</code>&gt;<code>0</code>的时候，剩余数的末尾<code>nums[length-1]</code>向左走，当<code>a</code>+<code>b</code>+<code>c</code>&lt;<code>0</code>的时候，剩余数的开头<code>nums[i+1]</code>向右走，。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        Arrays.sort(nums);        for (int i = 0; i + 2 &lt; nums.length; i++) {            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {//一次循环过后要么找到一组解，要么无解                continue;//此处跳过重复解            }            int j = i + 1;            int k = nums.length - 1;            int target = -nums[i];            while (j &lt; k) {                if (nums[j] + nums[k] == target) {                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));                    j++;                    k--;                    while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++;                    while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--;                } else if (nums[j] + nums[k] &gt; target) {                    k--;                } else {                    j++;                }            }        }        return res;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def threeSum(self, nums):        if len(nums) &lt; 0: return []        nums.sort()        res = set()        for i, v in enumerate(nums[:-2]):            if i &gt;= 1 and v == nums[i-1]:                continue            d = {}            for x in nums[i+1:]:                if x not in d:                    d[-v-x] = 1                else:                    res.add((v, -v-x, x))        return list(map(list, res))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第15题是中等题，解法依然很挠头，一遍写不出系列，Keep Moving T_T</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第7题Reverse Integer</title>
      <link href="/leetcode-reverse-integer.html"/>
      <url>/leetcode-reverse-integer.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h4><p><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Reverse Integer</a>的题目要求很简单，给定32位有符号整数，返回该整数翻转后的结果，结果中零在第一位的省略零。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: 123<br>Output: 321</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: -123<br>Output: -321</p></blockquote><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h5><blockquote><p>Input: 120<br>Output: 21</p></blockquote><p>同样，考虑一个简单粗暴的方法，将整数转换成字符串，将字符串转换成数组，对数组做逆序操作。当然要先判断这个整数的正负，然后考虑翻转后有没有零。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">Class Solution{    public static int reverse(int n) {        if (n &gt; Integer.MAX_VALUE || n &lt; Integer.MIN_VALUE) {            return 0;        }        String s = String.valueOf(n);        if (n &lt; 0) {            s = s.substring(1, s.length());            char[] array = s.toCharArray();            String reverse = &quot;-&quot;;            for (int i = array.length - 1; i &gt;= 0; i--) {                reverse += array[i];            }            s = reverse;        } else {            char[] array = s.toCharArray();            String reverse = &quot;&quot;;            for (int i = array.length - 1; i &gt;= 0; i--) {                reverse += array[i];            }            while (reverse.length() &gt; 1 &amp;&amp; reverse.charAt(0) == &#39;0&#39;) {                reverse = reverse.substring(1, reverse.length());            }            s = reverse;        }        int i = 0;        try {            i = Integer.parseInt(s.toString().trim());        } catch (Exception e) {            return 0;        }        return i;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def reverse(self, x: int) -&gt; int:        if x &gt;= 0:            res = int(str(x)[::-1])        else:            res = int(&#39;-&#39; + str(x)[:0:-1])        return res if -2147483648 &lt;= res &lt;= 2147483647 else 0</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第7题是简单题，<code>LeetCode</code>给出的标准解法有点挠头，先不管了<del>我好菜啊</del>。另外不得不说<code>Python</code>的内置函数真的太强大了T_T。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第1题Two Sum</title>
      <link href="/leetcode-two-sum.html"/>
      <url>/leetcode-two-sum.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h4><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a>的题目要求是，给定一个数组和一个目标值，求得数组中两数<code>num1</code>和<code>num2</code>相加等于目标值<code>target</code>的两个数的下标。解法有两种，一是暴力法，一个个比较过来；二是哈希，把数组存在<code>map</code>里，存放的过程中只要发现<code>map</code>里面存有<code>num1</code>对应的目标解<code>num2</code>=<code>target</code>-<code>num1</code>，则返回下标即可。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public int[] twoSum(int[] nums,int target){        int[] result = new int[2];        for (int i = 0; i &lt; nums.length; i++){            for (int j = i + 1;j &lt; nums.length; j++){                if(nums[i] + nums[j] == target){                    result[0] = i;                    result[1] = j;                }            }        }        return result;    }}</code></pre><pre><code class="Java">class Solution {    public int[] twoSum(int[] nums,int target){        int[] result = new int[2];        Map&lt;Integer,Integer&gt; mp = new HashMap&lt;Integer, Integer&gt;();        for (int i  = 0; i &lt; nums.length; i++){            if(mp.containsKey(target - nums[i])){                result[0] = mp.get(target - nums[i]);                result[1] = i;                return  result;            }            mp.put(nums[i],i);        }        return result;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def twoSum(self, nums, target: int):        mp = {}        for i, x in enumerate(nums):            if x in mp:                return mp[x], i            else:                mp[target - x] = i        return -1</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第1题是简单题，迈出了第一步，以后也不要停下噢！</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>西恩刀塔与Ti9</title>
      <link href="/cn-dota-worst-dota.html"/>
      <url>/cn-dota-worst-dota.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="不浪能输？？？"><a href="#不浪能输？？？" class="headerlink" title="不浪能输？？？"></a>不浪能输？？？</h4><p>我就是在棺材里，也要发出声音，西恩刀塔亡了。</p><p>昨天的比赛看得很难受，<code>LGD</code>的韧性还是差了一截，一碾二翻三被碾，强行上演了一出经典剧情，能说什么呢。再看李逵和<code>OG</code>争冠军的比赛，不得不承认非常精彩，换成<code>LGD</code>去打，在那种局面下不一定绷的住，或者说很难绷的住，<code>OG</code>最终夺得了冠军，实至名归「硬实力」。</p><p>希望我们的队伍能好好磨练吧，无论是英雄池还是体系还是对版本的理解，多希望他们赢啊。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 成长 </tag>
            
            <tag> 老物 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>夏日</title>
      <link href="/summer-day.html"/>
      <url>/summer-day.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="夏天的风物"><a href="#夏天的风物" class="headerlink" title="夏天的风物"></a>夏天的风物</h4><p>喜欢夏天，热烈的风，热烈的阳光，那天看到夕阳的余晖，想着这大概是我学生生涯最后一个夏天了吧，一时竟有些伤感。四月份的时候非常期待夏天的杨梅，但是这个夏天的杨梅没有给我特别的欢喜，端午节回家吃的猛了，以至于一晚上红着眼睛没有睡好。真像个什么都没吃过的小孩，喜欢的时候一定要吃干抹净。</p><p>夏天还有什么呢，我好像没有那么喜欢西瓜，大概是因为外公种过西瓜，小时候只记得吃，长大了却容易想起外公，又害怕掉眼泪，就不怎么吃西瓜了。</p><p>夏天最有意思的还是小伙伴，无论是抓鱼、打牌、捉迷藏，还是玩什么，一群人玩的满头大汗，欢喜的异常，这段时光无忧无虑，没有烦恼，除了偶尔埋怨一下太阳太毒，好像没有别的不满意的地方。</p><p>现在好像没有简单的快乐了，每一天和以前一样平淡，但是快乐却没有以前那样容易了。我又在说什么奇怪的话。</p><p>这个夏天，希望会有好运，是一个快乐的夏天。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工作996生病ICU</title>
      <link href="/996-icu.html"/>
      <url>/996-icu.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="996ICU"><a href="#996ICU" class="headerlink" title="996ICU"></a>996ICU</h4><p>之前关于<code>996ICU</code>的讨论已经非常引人注目，<code>996ICU</code>的<code>Github</code>仓库已经有了21万的Star，这两天马云和刘强东又有相关的表态，更是引起新的议论。所谓的「996」就是每天早上9点到岗，工作到晚上9点，每周工作6天的一种工作制，显然，这是违反《劳动法》的。但是由于特殊的国情，这种违法现象非常的普遍。</p><p><code>996ICU</code>的背后确实很复杂，企业和社会之间的博弈，老板和员工之间的博弈，员工之间的博弈，员工自身精神与肉体之间的博弈，但是归结到底还是「钱」的问题。</p><p>我想如果能给到相应的薪酬水平，大部分人是愿意接受996的。因为大部分人都是普通人，是被生活中的柴米油盐围绕着、被房车压迫着的普通人，大家都太需要钱了，尽管我还是认为996是一种不健康的行业生态。从这种层面上来说，工作只是「谋生」的手段，什么改变世界，创造未来对于大部分人都太遥远而缥缈了。</p><p>而当资本家们拿出这套「996才是拼搏」的说辞的时候，似乎有很多人愿意捧着。我不觉得这部分人他们是不明白背后的故事，只是现实如此不得不低头罢了吧。以我浅薄的看法，我觉得这也不要紧，都是为了家人能有更好的生活。但是如果因此长起志气为资本家冲锋陷阵去和同僚们斗起法来博一个幸进，恐怕是有点扭曲了。</p><p>同样的，我看到一些让我唏嘘的言论。比如某些科研工作者，居然说「996居然能引起热议，我们科研民工都是XXX的」之类的话，如果是单纯的调侃，我觉得也已经到了边界。同样是被剥削，为什么要因为剥削的程度不同而分起等级来仿佛要论个高下呢？书都读到狗肚子里了吗？</p><p>我相信老板们也有很多苦衷，员工们也有很多苦衷，那么和解的方式应该是法律。这是人类社会有关契约最大的公约数吧，所有人都要遵守法律。这样想好像又太幼稚了，如果《劳动法》真的在所有时候管用，也不会出现<code>996ICU</code>这个词了。法律只能保护大多数人，不能保护所有人，同样的只能在大多数时候保护大多数人，不能在所有时候保护所有人。这个思想好像有点危险，还有点歪楼了，嘿嘿。</p><p>另外就是，未来一段时间走上社会的大部分都是独生子女，家庭结构实在太单薄了。如果他们一人倒下了，背后跟着受罪的是两家年老的父母以及一个新生的家庭，这也是<code>996ICU</code>最恐怖的后果。</p><h4 id="政治课本背后的话"><a href="#政治课本背后的话" class="headerlink" title="政治课本背后的话"></a>政治课本背后的话</h4><p>作为资本家，他只是人格化的资本。他的灵魂就是资本的灵魂。而资本只有一种生活本能，这就是增值自身，获取剩余价值，用自己的不变部分即生产资料尽可能多的吮吸剩余劳动。资本是死劳动，它像吸血鬼一样，只有吮吸活劳动才有生命。</p><p>马克思的剥削理论指出，资本主义剥削是一种典型的市场剥削，这种剥削的存在依赖一定意义上自由、自愿的而非强迫的交换，“自由”的概念包括两种含义：一种是“积极的自由”即实在自由，另一种是“消极的自由”即形式自由。</p><p>实在自由是劳动者的自我实现，是作为自主权的自由，它意味着目标的积极能力；而形式自由则是一种意识形态幻觉，它包括作为消费者的自由、作为生产者的自由以及劳动者在劳动市场中的自由，这种形式是表面现象，而且是骗人是表面现象，罗马的奴隶是由锁链，雇佣工人则由看不见的线系在自己的所有者手里。</p><p>工人在自愿、平等交换的面纱下被迫地、不平等地出卖劳动力。</p><p>高中、大学的政治课堂上还是教了一些有用的东西的吧，书本上那些工人和资本家斗争的历史文字是生动的，直到今天依然没有过时，人类社会有时候还挺可笑的。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><blockquote><p><a href="https://996.icu/#/zh_CN" target="_blank" rel="noopener">996.ICU</a><br><a href="https://github.com/996icu/996.ICU" target="_blank" rel="noopener">996ICU的Github仓库</a><br><a href="http://www.cctb.net/llyj/llgc/foreignmarx/201402/t20140224_301628.htm" target="_blank" rel="noopener">剥削是合乎正义的吗</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 时事 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清明和春日</title>
      <link href="/qingming-and-spring.html"/>
      <url>/qingming-and-spring.html</url>
      <content type="html"><![CDATA[<a id="more"></a><!-- more --><h4 id="清明节"><a href="#清明节" class="headerlink" title="清明节"></a>清明节</h4><p>小时候喜欢清明节，因为小孩还不懂得生死，只知道每年到这个时候要给祖先们拜拜，大家聚在一起还会有好吃的东西分，在山上也很新奇，上山的路上风光亮眼，还有小溪，走累了捧一把清水洗洗脸歇一歇，有时捉捉鱼虾，老家还有几片竹林，大人们会乘着时节去采挖竹笋，小孩子们挥不动锄头，不过还可以拿草刀劈几根竹子玩一玩，甚有乐趣。而如今却有些怕清明节，长辈们一年年老去，祖辈也大多离开了人世，心中难免感慨，不愿意多想，借用一句诗：故园肠断处，日夜柳条新。</p><h4 id="一部悬疑片"><a href="#一部悬疑片" class="headerlink" title="一部悬疑片"></a>一部悬疑片</h4><p>三天小长假，没有回家去拜山，我想着端午节再回家好了，下午去看了一部印度的烧脑片《调音师》，虽然是翻拍，但是给我非常新奇的感受，别的不说，印度的音乐的确很有特色。</p><p>男主阿卡什本身是一个有音乐梦想的钢琴师，或者说艺术家，艺术家都有疯狂的点子，他为了好玩为了试验而假扮盲人钢琴师，他以为这样可以变得专注，的确他弹得曲子很动听。</p><p>他的现实身份是一个普通的盲人，却不幸目睹了杀人案，他想告发但是对方能量太强大了，他想假装没看见但是对方要灭他口，剧情在这里纠结往复，跌宕起伏，不断高潮和反转。</p><p>结尾的地方，阿卡什去到了他念念不忘的伦敦，还在那里遇到了女主，我本以为这是一个劝人正向的大团圆结尾，谁料最后才是高潮，阿卡什告诉女主自己没有拿走一千万和眼角膜，自己真的变成了盲人，女主好像是相信了，对阿卡什说如果我是你，我就…阿卡什打断了她的话，接过了服务员递过来的兔头拐杖，这里有一个细节，服务员问先生这是不是你的手杖，阿卡什还没上手摸到手杖就直接回答是，而后两人分离，阿卡什在路过一个转角的时候非常懊恼地一棍子扫飞了眼前的易拉罐！电影在这里终结。</p><p>我的天，他到底有没有说真话，他是不是他告诉女主的那个故事里的温柔的阿卡什，或者说他还是拿走了一千万和眼角膜，全片只有女主一个是普通人是好人，其他人都或多或少作了恶，而阿卡什，从一个假扮盲人的普通人真的变成了盲人，他会愤怒，他会恐惧，当有一千万可以让他逃离这个是非之地，当有一个眼角膜可以让他恢复光明，而他要做的只是在报复仇人的同时获得这些东西，他到底做了什么？电影最后留下了一个想象的空间。</p><p>全片剧情非常紧凑，笑中有泪，只想说卧槽，我觉得应该叫它《节奏大师》</p><h4 id="春日"><a href="#春日" class="headerlink" title="春日"></a>春日</h4><p>四月的杭州，风光非常美丽，游人如织，阳光明媚的日子里整个世界都变得明亮而温暖，从古至今每一年都是这样吗？那也太美妙了，不知道我能看到几时啊，我好爱。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 久违的更新 </tag>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你好，三月九日</title>
      <link href="/womens-right.html"/>
      <url>/womens-right.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="国际劳动妇女节"><a href="#国际劳动妇女节" class="headerlink" title="国际劳动妇女节"></a>国际劳动妇女节</h4><p>昨天是三月八号，国际劳动妇女节，这是各国女性为女性权益斗阵的胜利纪念日，本文的附图来自当天的<code>Google</code>首页涂鸦，永远不要被他人有限的想象力所束缚，特别是我们的女同胞们，要为争取平等的权益战斗到底。</p><p>微博上看到许多关于三月八号妇女节女王节女女神节，乃至三月七号女生节的讨论，很多人清醒的认识到用消费主义陷阱掩盖这个节日的战斗意义是有多么的无耻，不幸的是也有一部分人持“事多儿”、“有什么关系”、“吵来吵去烦不烦”等态度对这些内容冷眼相看，其中有部分人甚至是女生，这实在是一种悲哀，尤其是在这些烦不烦的人是在为了你的权益斗争的时候。</p><p>我始终相信，女性的地位不是男人嘴里的一句女王大人、女神大人就能提高的，平等是权益，不是怜悯，是理所应当不是恻隐之心，女性的地位只来自女性群体的平均受教育水平和平均收入水平，只有这样才能让女性保持独立和自由，这样才能让女性争取公平和正义。</p><p>我们的女同胞们要擦亮眼睛，小心吹捧，戴高帽不解决本质问题，这是一个光荣的节日，是流血牺牲换来的胜利日，不是听两句便宜的好话就疯狂掏钱的购物节，从某种意义上讲，正是有前人前赴后继的斗争为女性得来了受教育权、劳动权等等一系列权利，前人栽树后人乘凉，到今天，才有这些精明的商家愿意为了你口袋里的钱设计种种甜言蜜语，一定要分得清辨得明。</p><p>当然，我同意为心爱的女性同胞送花送礼物，这不冲突^_^</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><blockquote><p><a href="http://www.un.org/zh/events/womensday/background.shtml" target="_blank" rel="noopener">联合国·国际妇女节</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E5%A6%87%E5%A5%B3%E8%8A%82" target="_blank" rel="noopener">维基百科·国际妇女节</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 久违的更新 </tag>
            
            <tag> 女权 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再见二零一八</title>
      <link href="/goodbye-2018.html"/>
      <url>/goodbye-2018.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="久违的更新"><a href="#久违的更新" class="headerlink" title="久违的更新"></a>久违的更新</h4><p>这半年来遇到了许多人许多事，以至于我无暇顾及这个博客，违背了初心实在有些内疚，一声叹息。<code>2018</code>年马上就要过去，新的一年祝愿爱我的人和我爱的人平安喜乐，万事如意。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 成长 </tag>
            
            <tag> 新年 </tag>
            
            <tag> 久违的更新 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冲鸭！西恩刀塔</title>
      <link href="/cn-dota-best-dota.html"/>
      <url>/cn-dota-best-dota.html</url>
      <content type="html"><![CDATA[<a id="more"></a><h4 id="永远不要低估一颗冠军的心"><a href="#永远不要低估一颗冠军的心" class="headerlink" title="永远不要低估一颗冠军的心"></a>永远不要低估一颗冠军的心</h4><p>早上起床看了<code>ZSMJ</code>的斗鱼直播，马甲哥在解说<code>Ti8</code>，我对马甲哥的了解只停步于他真三时代的传说，<del>因为在那以后进没机会玩游戏了</del>。马甲哥的成名之战是真三时代他的郭嘉神之一C，对于不了解真三这款上古老物的朋友来说这句话估计看不懂，稍作解释，郭嘉的大招C冰河爆裂破是一个远程技能，效果是打出一条直线的冰爆控制住在直线范围内的敌方英雄并造成伤害，这样一个控制类技能被马甲哥玩的炉火纯青，常常是一个C技能控制住对方多个英雄，给队友制造输出时间和空间，此外，马甲哥的控车也是一绝，对于普通玩家来说一般是控车人亡，控人车亡，双控双亡，我玩了那么久的真三，依然是一个普通玩家。真三这款游戏被人诟病的一个地方就是能出投石车，投石车对建筑物的伤害较高，对于队伍的推进非常有利，而马甲哥常常一个人就出到一队十二辆之多的车，或配合郭嘉大招控人后投石击杀，或带队快速推进，还形成了前期速推流的战术,风靡一时。此外马甲哥的赵云也非常犀利，撑起无双玄武进场就是一打五，当然，马甲哥的队友很给力也是一个重要原因。</p><p>马甲哥出身于饭团战队，这是在真三时代造就了饭团王朝的一支顶级战队，不过那时候国内电竞发展处于起步摸索的阶段，很多优秀的选手迫于家庭、生活等原因不得不离开自己喜爱的游戏，可以说非常的可惜。现在来看，中国的游戏圈如此火爆真是让人意想不到啊，毕竟从小到大的社会舆论对游戏都是不分青红皂白一概棒杀，今年<code>LOL</code>国家队出战亚运会为国争光，<code>Ti8</code>上来自中国俱乐部的战队坚持战斗，写下这段文字的时候，<code>LGD</code>正在和<code>OG</code>对决<code>BO5</code>赛点局，线上、现场的观看人数不可计数，真真是换了人间。</p><p>马甲哥在他的微博自我介绍上写着永远不要低估一颗冠军的心，奈何自古名将如美人，不许人间见白头，对于很多电竞游戏玩家来说，马甲哥是一个符号，是我们逝去的青春。</p><h4 id="老物"><a href="#老物" class="headerlink" title="老物"></a>老物</h4><p>这里是一个关于真三的视频，年代比较久远，在优酷上找到了一份，<del>外链引出后没有带<code>HTTPS</code>，然后我就强行给他改成<code>HTTPS</code>，可能会出问题</del>。</p><iframe height="498" width="510" src="https://player.youku.com/embed/XMTQ0MzA2MDE0NA==" frameborder="0" 'allowfullscreen'=""></iframe><h4 id="Ti8比赛结果"><a href="#Ti8比赛结果" class="headerlink" title="Ti8比赛结果"></a>Ti8比赛结果</h4><p>老干爹输的太可惜了，浪输的，无言，明年<code>Ti9</code>赛场在上海，希望家门口能有好消息。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 成长 </tag>
            
            <tag> 老物 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>成长学</title>
      <link href="/song-of-grow-up.html"/>
      <url>/song-of-grow-up.html</url>
      <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=483380284&auto=0&height=66"></iframe><h4 id="长大以后"><a href="#长大以后" class="headerlink" title="长大以后"></a>长大以后</h4><p><strong> 这个世界，好像既不温柔也不正确呢，</strong>如果你不够强大的话。在某部日漫里看见过类似的台词，现在想来有点感受了，生活果然对我动手了啊。最近家里的事不是太顺，而我又帮不上什么忙，看着父母温暖的脸庞上岁月的痕迹已经掩盖不住，我心里就忍不住流泪，这些话也不会对别人说，只能在这个地方悄悄地叹一口气，时间过得好快，而我要做到的，还有太多，太多，加油，加油。</p><h4 id="八月廿日"><a href="#八月廿日" class="headerlink" title="八月廿日"></a>八月廿日</h4><p>今天吃饭的时候父亲又提起了考公务员的事，我只说能考，父亲有点失望，只说我已经长大，事情自己多考虑，他也已经不懂了，然后便不再多说。其实这是最让我难受的地方，心里模模糊糊的有一种崩坏的感觉，这种感觉，就像身处线式战术时代的战场，一阵排枪过后，等到眼前硝烟散尽，赫然发现身前再也没有遮挡，自己已然位于战阵的第一排。我还不适应这种角色的转换吧，说句没头脑的话，我好害怕我做下错误的决定，伤害到父母伤害到自己。</p><p>我是一个不称职的儿子，我不了解我父亲，平时我们话也不多，现在的我更不知道该如何是好，印象中，父亲流露出这种失望和伤感的情绪还是在大三的暑假，也可能不是，我在家收拾书房的东西，发现柜子里的一台录音机，就把它拿出来檫了一下，很普通的一个手提式录音机，父亲正好看见，走过来爱惜地摸了摸，说了一句我至今难忘的话：这台录音机是你上初中的时候买的，给你读英语，没读咯。可能是那时起，我下定决心要做些什么，不过现在来看，我做的并不算好，至少我心里清楚，我远没有父亲期望的那样强大，我好不争气啊。</p><h4 id="九月十三日"><a href="#九月十三日" class="headerlink" title="九月十三日"></a>九月十三日</h4><p>迟迟没有更新，主要是太懒了，第二点就是仍旧不能很好的处理自己的时间，接下来几天有一个高强度的任务，希望能够做的好一点，时间真的是过得非常的快呢，认识了两位新朋友<del>姑且这么说吧</del>，最近又开始重新看柯南。今天看到第38集，这集真的触动到我了，女主本来有一个美满的未来，但是在和男朋友开车出去游玩的时候由于一对杀马特情侣故意别车而发生意外翻车，男朋友不幸地葬身于火海，女主假借爱慕的名义拜托毛利小五郎寻找男朋友，其实是试图寻找杀马特情侣两人复仇，不明内情的毛利找到了杀马特情侣的地址，女主开车去复仇的路上回忆起和男友从初识、一起工作、互相帮助、加班、合作谈判，二人情愫暗生，告白，可是一切却毁在了那场意外，命运真是无常啊，间奏的插曲非常动人，将这种心酸无处可诉的悲伤感觉诠释地恰到好处，明明只是一集动画片，而我看完之后却久久不能释怀。</p><h4 id="关于这首歌"><a href="#关于这首歌" class="headerlink" title="关于这首歌"></a>关于这首歌</h4><p><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/song-of-grow-up/song-of-grow-up.png" alt="成长学"></p><h4 id="我们快乐吗"><a href="#我们快乐吗" class="headerlink" title="我们快乐吗"></a>我们快乐吗</h4><blockquote><p>街上车来车往却落寞<br>空气也变得有些脆弱<br>它是否无处寄托着 也想诉说着什么<br>看来我 还是没能抚平内心的皱折<br>什么时候才能找回 曾经的我<br>我曾失落 书店角落 深夜某个时候<br>眼底竟是他们的不倦笑容<br>我曾迷惑 独自揣度 无非自己浅薄<br>而现在是否能读懂几分成熟<br>记忆之中 喜泪交错<br>多少事何止恍然如梦概括<br>又有多少人看似洒脱却不快乐<br>许多年以后 多少人为生活迁就<br>只为心中那不变的守候</p></blockquote><blockquote><p>我曾失落 书店角落 深夜某个时候<br>眼底竟是他们的不倦笑容<br>我曾迷惑 独自揣度 无非自己浅薄<br>而现在是否能读懂几分成熟<br>记忆之中 喜泪交错<br>多少事何止恍然如梦概括<br>又有多少人看似洒脱却不快乐<br>许多年以后 多少人为生活迁就<br>只为心中那不变的守候<br>记忆之中 喜泪交错<br>多少事何止恍然如梦概括<br>又有多少人看似洒脱却不快乐<br>许多年以后 多少人为生活迁就<br>只为心中那不变的守候</p></blockquote>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> 成长 </tag>
            
            <tag> 网易云音乐 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2015年数模研赛D题研读</title>
      <link href="/review-of-gmcm2015-problem-D.html"/>
      <url>/review-of-gmcm2015-problem-D.html</url>
      <content type="html"><![CDATA[<h4 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h4><p>问题一：单列车运行的节能优化控制</p><ol><li><p>建立计算速度距离曲线的数学模型，寻找一条列车从<code>A6</code>站出发到达<code>A7</code>站的最节能的速度距离曲线，限定列车在两站的运行时间为110秒。</p></li><li><p>建立新的计算速度距离曲线的数学模型，寻找一条列车从<code>A6</code>站出发到达<code>A8</code>站的最节能的速度距离曲线，其中要求列车在<code>A7</code>站停靠45秒，限定列车在<code>A6</code>站到<code>A8</code>站的总运行时间为220秒(不包括停靠时间)。</p></li></ol><p>问题二：多列车运行的节能优化控制</p><ol><li><p>当100列列车以间隔\(H=\lbrace h_{1},…,h_{99} \rbrace\)从<code>A1</code>站出发，追踪运行，依次经过<code>A2</code>，<code>A3</code>，……到达<code>A14</code>站，中间在各个车站停站最少\(D_{min}\)秒，最多\(D_{max}\)秒。间隔\(H\)各分量的变化范围是\(H_{min}\)秒至\(H_{max}\)秒。请建立优化模型并寻找使所有列车运行总能耗最低的间隔\(H\)。要求第一列列车发车时间和最后一列列车的发车时间之间的间隔为\(T_{0}\)=63900秒，且从A1站到A14站的总运行时间不变，均为2086秒(包括停站时间)。</p></li><li><p><del>接上问，如果高峰时间(早高峰7200秒至12600秒，晚高峰43200至50400秒)发车间隔不大于2.5分钟且不小于2分钟，其余时间发车间隔不小于5分钟，每天240列。请重新为它们制定运行图和相应的速度距离曲线。</del></p></li></ol><p>问题三：列车延误后的运行优化控制</p><ol><li><p><del>接上问，若列车\(i\)在车站\(A_{j}\)延误\(DT_j^i\)（10秒）发车，请建立控制模型，找出在确保安全的前提下，首先使所有后续列车尽快恢复正点运行，其次恢复期间耗能最少的列车运行曲线。</del></p></li><li><p><del>假设\(DT_j^i\)为随机变量，普通延误（0&lt;\(DT_j^i\)&lt;10s）概率为20%，严重延误（\(DT_j^i\) &gt;10s）概率为10%（超过120秒，接近下一班，不考虑调整），无延误（\(DT_j^i\)= 0）概率为70%。若允许列车在各站到、发时间与原时间相比提前不超过10秒，根据上述统计数据，如何对第二问的控制方案进行调整？</del></p></li></ol><p>补充说明：问题二中，列车追踪运行时，为保证安全，跟踪列车(后车)速度不能超过限制速度\(V_{limit}\)，以免后车无法及时制动停车，发生追尾事故。其计算方式可简化如下：\(V_{limit}=min⁡(V_{line},√(2LB_e))\)。其中\(V_{line}\)是列车当前位置的线路限速(单位\(km/h\))，\(L\)是当前时刻前后车之间的距离(单位\(m\))，\(B_e\)是列车制动的最大减速度(单位\(m/s^2\))。</p><h4 id="数据与特性说明"><a href="#数据与特性说明" class="headerlink" title="数据与特性说明"></a>数据与特性说明</h4><h5 id="列车参数"><a href="#列车参数" class="headerlink" title="列车参数"></a>列车参数</h5><table><thead><tr><th>属性</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td>列车长度(单位\(m\))</td><td style="text-align:center">115</td></tr><tr><td>列车重量(单位\(t\))</td><td style="text-align:center">194.295</td></tr><tr><td>列车基本阻力参数\(A\)</td><td style="text-align:center">2.031</td></tr><tr><td>列车基本阻力参数\(B\)</td><td style="text-align:center">0.0622</td></tr><tr><td>列车基本阻力参数\(C\)</td><td style="text-align:center">0.001807</td></tr><tr><td>最大加速度(单位\(m/s^2\))</td><td style="text-align:center">1</td></tr><tr><td>最大减速度(单位\(m/s^2\))</td><td style="text-align:center">1</td></tr><tr><td>最小停站时间\(D_{min}\) (单位\(sec\))</td><td style="text-align:center">30</td></tr><tr><td>最大停站时间\(D_{max}\) (单位\(sec\))</td><td style="text-align:center">45</td></tr><tr><td>最小发车时间\(H_{min}\) (单位\(min\))</td><td style="text-align:center">2</td></tr><tr><td>最大发车时间\(H_{max}\) (单位\(min\))</td><td style="text-align:center">11</td></tr><tr><td>第一列列车和最后一列列车的发车间隔\(T_{0}\)(单位\(min\))</td><td style="text-align:center">900</td></tr></tbody></table><h5 id="列车牵引和制动特性方程"><a href="#列车牵引和制动特性方程" class="headerlink" title="列车牵引和制动特性方程"></a>列车牵引和制动特性方程</h5><p>最大牵引力(单位\(kN\)) </p><p>\(F_{max}=\begin{cases}<br>203,\quad 0\leq v\leq 51.5 km/h \\<br>-0.002032v^3+0.4928v^2-42.13v+1343,\quad 51.5&lt; v \leq 80km/h<br>\end{cases}<br>\)</p><p>最大制动力(单位\(kN\)) </p><p>\(B_{max}=\begin{cases}<br>166,\quad 0\leq v\leq 77 km/h \\<br>0.134v^2-25.07v+1300,\quad 77&lt; v \leq 80km/h<br>\end{cases}<br>\)</p><p>基本阻力(单位\(kN\)) </p><p>\(w_{0}=(A+Bv+Cv^2)mg\)</p><p>其中\(v\)是列车当前时刻的速度,\(m\)是列车的质量，\(g\)是重力加速度。</p><h5 id="列车动力学模型"><a href="#列车动力学模型" class="headerlink" title="列车动力学模型"></a>列车动力学模型</h5><p>列车在站间运行时会根据线路条件、自身列车特性、前方线路状况计算出一个限制速度。列车运行过程中不允许超过此限制速度。限制速度会周期性更新。在限制速度的约束下列车通常包含四种运行工况： 牵引、巡航、惰行和制动。</p><p>如果车站间距离较短，列车一般采用“牵引-惰行-制动”的策略运行。如果站间距离较长，列车通常会采用牵引到接近限制速度后，交替使用惰行、巡航、牵引三种工况，直至接近下一车站时采用制动进站停车。</p><p>列车在运行过程中，实际受力状态非常复杂。采用单质点模型是一种常见的简化方法。单质点模型将列车视为单质点，列车运动符合牛顿运动学定律。其受力可分为四类：重力\(G\)在轨道垂直方向上的分力与受到轨道的托力抵消，列车牵引力\(F\)，列车制动力\(B\)和列车运行总阻力\(W\)。</p><ul><li><p>列车牵引力F是由动力传动装置产生的、与列车运行方向相同、驱动列车运行并可由司机根据需要调节的外力。牵引力F在不同速度下存在不同的最大值，牵引力\(F\)克服阻力W和重力\(G\)做功，为了减小建模的复杂度<del>便于划水</del>，我们直接忽视各站之间的坡度，这样就不用考虑重力\(G\)了呢，即只考虑牵引力\(F\)和阻力\(W\)，其中\(W\)取基本阻力。由于牵引过程是个变加速过程，故在计算时我们采取无限逼近的方式，将\(\Delta t\) 内的运动看作是匀加速运动，抽象为如下过程：<br><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/review-of-gmcm2015-problem-D/qianyin.png" alt="抽象后的牵引过程"></p></li><li><p>巡航阶段：列车匀速，列车所受合力为 0，列车是需要牵引还是需要制动取决于列车当时受到的总阻力<del>计算中把巡航这块直接无视了T_T</del>。</p></li><li><p>惰行阶段：列车既不牵引也不制动，列车运行状态取决于受到的列车总阻力，发动机不耗能。列车在速度方向只受阻力和重力的分力作用， 该过程既不产生能量也不消耗能量。由于列车车轮与轨面之间的摩擦会产生热能，从能量转化的角度来看该过程牺牲了动能。惰行过程中列车以很小的减速度不断减速。</p></li><li><p>制动阶段：列车减速，发动机不耗能。如果列车采用再生制动技术，此时可以将动能转换为电能反馈回供电系统供其他用电设备使用。由于制动过程是个变速过程，故在计算时我们采取无限逼近的方式，将每一小时间段 \(\Delta t\)内的运动看作是匀减速运动，抽象为如下过程：<br><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/review-of-gmcm2015-problem-D/zhidong.png" alt="抽象后的制动过程"></p></li><li><p>随着制动技术的进步，目前城市轨道交通普遍采用再生制动。再生制动时，牵引电动机转变为发电机工况，将列车运行的动能转换为电能，发电机产生的制动力使列车减速，此时列车向接触网反馈电能，此部分能量即为再生制动能。列车\(i+1\)在制动时会产生能量\(E_{reg}\)，如果相邻列车\(i\)处于加速状态，其可以利用\(E_{reg}\)，从而减少从变电站获得的能量，达到节能的目的。如果列车\(i+1\)制动时，其所处供电区段内没有其他列车加速，其产生的再生能量除用于本列车空调、照明等设备外，通常被吸收电阻转化为热能消耗掉。<br><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/review-of-gmcm2015-problem-D/ereg-zhidong.png" alt="再生制动过程"><br>再生能量可按照以下假设的公式计算：\(E_{used}=E_{reg}∙t_{overlap}/t_{brake}\)。其中\(t_{overlap}\)是列车\(i+1\)制动的时间与列车\(i\)加速时间的重叠时间，\(t_{brake}\)是列车\(i+1\)的制动时间。即制动时所产生的再生能量与制动时间成正比。</p></li></ul><h5 id="车站线路参数"><a href="#车站线路参数" class="headerlink" title="车站线路参数"></a>车站线路参数</h5><table><thead><tr><th style="text-align:center">站点名</th><th style="text-align:center">公里标</th><th style="text-align:center">与下一站距离</th><th style="text-align:center">限速55km/h</th><th style="text-align:center">限速80km/h</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">22903</td><td style="text-align:center">1334</td><td style="text-align:center">120</td><td style="text-align:center">1214</td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center">21569</td><td style="text-align:center">1286</td><td style="text-align:center">120</td><td style="text-align:center">1166</td></tr><tr><td style="text-align:center">A3</td><td style="text-align:center">20283</td><td style="text-align:center">2086</td><td style="text-align:center">120</td><td style="text-align:center">1966</td></tr><tr><td style="text-align:center">A4</td><td style="text-align:center">18197</td><td style="text-align:center">2265</td><td style="text-align:center">120</td><td style="text-align:center">2145</td></tr><tr><td style="text-align:center">A5</td><td style="text-align:center">15932</td><td style="text-align:center">2338</td><td style="text-align:center">120</td><td style="text-align:center">2218</td></tr><tr><td style="text-align:center">A6</td><td style="text-align:center">13594</td><td style="text-align:center">1354</td><td style="text-align:center">120</td><td style="text-align:center">1234</td></tr><tr><td style="text-align:center">A7</td><td style="text-align:center">12240</td><td style="text-align:center">1280</td><td style="text-align:center">120</td><td style="text-align:center">1160</td></tr><tr><td style="text-align:center">A8</td><td style="text-align:center">10960</td><td style="text-align:center">1538</td><td style="text-align:center">120</td><td style="text-align:center">1418</td></tr><tr><td style="text-align:center">A9</td><td style="text-align:center">9422</td><td style="text-align:center">993</td><td style="text-align:center">120</td><td style="text-align:center">873</td></tr><tr><td style="text-align:center">A10</td><td style="text-align:center">8429</td><td style="text-align:center">1982</td><td style="text-align:center">120</td><td style="text-align:center">1862</td></tr><tr><td style="text-align:center">A11</td><td style="text-align:center">6447</td><td style="text-align:center">2336</td><td style="text-align:center">120</td><td style="text-align:center">2216</td></tr><tr><td style="text-align:center">A12</td><td style="text-align:center">4081</td><td style="text-align:center">1275</td><td style="text-align:center">120</td><td style="text-align:center">1155</td></tr><tr><td style="text-align:center">A13</td><td style="text-align:center">2806</td><td style="text-align:center">2631</td><td style="text-align:center">120</td><td style="text-align:center">2521</td></tr><tr><td style="text-align:center">A14</td><td style="text-align:center">175</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><p>举例说明表中数据的含义，<code>A6</code>车站距离<code>A7</code>车站<code>1354m</code>，从<code>A6</code>车站出发前去<code>A7</code>车站的<code>120m</code>路段内列车限速<code>55km/h</code>，在<code>120m</code>至<code>1234m</code>路段内限速<code>80km/h</code>。<strong>这里特别说明一下，该表在限速路段上的数据与原题给出数据略有出入，对部分分割较为精细的路段限速值进行了粗糙的忽略，统一为限速80km/h，不影响计算结果。</strong></p><h4 id="单节列车节能优化"><a href="#单节列车节能优化" class="headerlink" title="单节列车节能优化"></a>单节列车节能优化</h4><h5 id="A6站至A7站"><a href="#A6站至A7站" class="headerlink" title="A6站至A7站"></a>A6站至A7站</h5><p>根据上述的分析，我们知道单节列车最节能的方式是：以最大的牵引力加速，然后进行惰行，接着以最大的制动力进行制动。</p><p>已知信息如下：列车参数、列车牵引和制动特性、<code>A6</code>站至<code>A7</code>站距离为<code>1354m</code>，运行时间为<code>110s</code>。按照动力学模型中三个主要过程，我们建立计算模型，取\(\Delta t=0.05s\)。列车在牵引阶段由牵引力\(F\)克服阻力\(W\)做功，列车不断加速，到达某一时间点后进入惰行阶段，列车以很小的减速度减速行驶，再到达某一时间点后进入制动阶段，准备进站停车，由此可以得知，列车在起点和终点上速度接近于<code>0</code>，全程的行驶速度受到列车自身限速最高<code>80km/h</code>和不同路段最高限速<code>55km/h</code>或<code>80km/h</code>的约束。</p><p>计算结果如下，实线是列车从<code>A6</code>站运行至<code>A7</code>站最节能的速度距离曲线，虚线是路段的最高限速，实线的两个拐点代表列车进入惰行和制动阶段时的距离和速度，在时间点上分别是20秒和98秒，这时列车消耗的能量约为<code>35161kJ</code>。<br><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/review-of-gmcm2015-problem-D/A6-to-A7-Rplot.jpg" alt="A6-to-A7-Rplot"></p><h5 id="A6站至A8站"><a href="#A6站至A8站" class="headerlink" title="A6站至A8站"></a>A6站至A8站</h5><p>单节列车过一站和过两站的计算方法没有明显区别，可复用前一问的计算模型，要求列车从<code>A6</code>至<code>A8</code>站运行时间为<code>220s</code>，我们可以根据<code>A6</code>站至<code>A7</code>站的距离和<code>A7</code>站至<code>A8</code>站的距离来分配运行时间，结果如下：</p><table><thead><tr><th style="text-align:center">运行路段</th><th style="text-align:center">运行距离</th><th style="text-align:center">运行时间</th><th style="text-align:center">限速55km/h</th><th style="text-align:center">限速80km/h</th><th style="text-align:center">惰行时间点</th><th style="text-align:center">制动时间点</th></tr></thead><tbody><tr><td style="text-align:center">A6至A7</td><td style="text-align:center">1354</td><td style="text-align:center">113</td><td style="text-align:center">120</td><td style="text-align:center">1234</td><td style="text-align:center">20</td><td style="text-align:center">98</td></tr><tr><td style="text-align:center">A7至A8</td><td style="text-align:center">1280</td><td style="text-align:center">107</td><td style="text-align:center">120</td><td style="text-align:center">1160</td><td style="text-align:center">20</td><td style="text-align:center">95</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/review-of-gmcm2015-problem-D/A6-to-A8-Rplot.jpg" alt="A6-to-A8-Rplot"></p><h4 id="多节列车节能优化"><a href="#多节列车节能优化" class="headerlink" title="多节列车节能优化"></a>多节列车节能优化</h4><h5 id="100列列车发车优化控制"><a href="#100列列车发车优化控制" class="headerlink" title="100列列车发车优化控制"></a>100列列车发车优化控制</h5><p>针对单列车来说，要使得列车最节能，则采取的节能控制策略为：牵引-惰行-制动。在整体中，要使得系统最节能，则要充分利用制动产生的再生能量，故需要尽可能地延长牵引和制动的时间，使两者的时间尽可能地重叠，以便提高再生能量的利用率。</p><p>前者提到，列车追踪运行是，为保证行车安全，后车速度不仅受路段限速制约，还要考虑前后车距离限速，不过在本问中，我们分析可知：前后两列车的出发时间间隔平均约为<code>645s</code>，接近最大的出发间隔<code>660s</code>，所以在第一列列车发车时间和最后一列列车的发车时间之间间隔为<code>63900s</code>的限制下，列车几乎不受安全距离限速的影响。因此我们将每节列车作为独立的主题进行最节能分析，则模型回归到单节列车节能运行优化问题，我们只需求得单节列车在全路段的速度距离曲线，然后令100列列车的牵引制动时间重合度最高即可。</p><p>已知单列车<code>A1</code>站至<code>A14</code>站全路段运行总时间为<code>2086s</code>，为了延长牵引和制动时间，我们要尽量压缩停站时间，令停站时间为\(D_{min}\),那么我们得到全路段的实际运行时间\(t=2086-\sum_{i=2}^{13}D_{i}=1726s\)，同样的，根据距离来分配运行时间，求得每个路段最节能的运行曲线，并得到惰行时间点和制动时间点，取\(\Delta t=0.05s\)。</p><table><thead><tr><th style="text-align:center">运行路段</th><th style="text-align:center">运行距离</th><th style="text-align:center">运行时间</th><th style="text-align:center">限速55km/h</th><th style="text-align:center">限速80km/h</th><th style="text-align:center">惰行时间点</th><th style="text-align:center">制动时间点</th></tr></thead><tbody><tr><td style="text-align:center">A1至A2</td><td style="text-align:center">1334</td><td style="text-align:center">101.3</td><td style="text-align:center">120</td><td style="text-align:center">1214</td><td style="text-align:center">22</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">A2至A3</td><td style="text-align:center">1286</td><td style="text-align:center">97.7</td><td style="text-align:center">120</td><td style="text-align:center">1166</td><td style="text-align:center">22</td><td style="text-align:center">84</td></tr><tr><td style="text-align:center">A3至A4</td><td style="text-align:center">2086</td><td style="text-align:center">158.4</td><td style="text-align:center">120</td><td style="text-align:center">1966</td><td style="text-align:center">27</td><td style="text-align:center">148</td></tr><tr><td style="text-align:center">A4至A5</td><td style="text-align:center">2265</td><td style="text-align:center">172.0</td><td style="text-align:center">120</td><td style="text-align:center">2145</td><td style="text-align:center">30</td><td style="text-align:center">162</td></tr><tr><td style="text-align:center">A5至A6</td><td style="text-align:center">2338</td><td style="text-align:center">177.6</td><td style="text-align:center">120</td><td style="text-align:center">2218</td><td style="text-align:center">30</td><td style="text-align:center">168</td></tr><tr><td style="text-align:center">A6至A7</td><td style="text-align:center">1354</td><td style="text-align:center">102.8</td><td style="text-align:center">120</td><td style="text-align:center">1234</td><td style="text-align:center">21</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">A7至A8</td><td style="text-align:center">1280</td><td style="text-align:center">97.2</td><td style="text-align:center">120</td><td style="text-align:center">1160</td><td style="text-align:center">21</td><td style="text-align:center">84</td></tr><tr><td style="text-align:center">A8至A9</td><td style="text-align:center">1538</td><td style="text-align:center">116.8</td><td style="text-align:center">120</td><td style="text-align:center">1418</td><td style="text-align:center">22</td><td style="text-align:center">105</td></tr><tr><td style="text-align:center">A9至A10</td><td style="text-align:center">993</td><td style="text-align:center">75.4</td><td style="text-align:center">120</td><td style="text-align:center">873</td><td style="text-align:center">21</td><td style="text-align:center">60</td></tr><tr><td style="text-align:center">A10至A11</td><td style="text-align:center">1982</td><td style="text-align:center">150.5</td><td style="text-align:center">120</td><td style="text-align:center">1862</td><td style="text-align:center">25</td><td style="text-align:center">140</td></tr><tr><td style="text-align:center">A11至A12</td><td style="text-align:center">2366</td><td style="text-align:center">179.7</td><td style="text-align:center">120</td><td style="text-align:center">2216</td><td style="text-align:center">31</td><td style="text-align:center">170</td></tr><tr><td style="text-align:center">A12至A13</td><td style="text-align:center">1275</td><td style="text-align:center">96.8</td><td style="text-align:center">120</td><td style="text-align:center">1155</td><td style="text-align:center">22</td><td style="text-align:center">83</td></tr><tr><td style="text-align:center">A13至A14</td><td style="text-align:center">2631</td><td style="text-align:center">199.8</td><td style="text-align:center">120</td><td style="text-align:center">2521</td><td style="text-align:center">33</td><td style="text-align:center">191</td></tr></tbody></table><p>但是很惭愧，结果出了一点微小的偏差，最后一段运行速度超过了路段限速<code>80</code>一丢丢，查看了一下数据，最大值大约是<code>81.37</code>，<del>当然选择无视他啦XD。</del></p><p><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/review-of-gmcm2015-problem-D/A1-to-A14-Rplot.jpg" alt="A1-to-A14-Rplot"></p><p>那么我们得到了单列车运行的速度距离曲线、惰行时间点和制动时间点，于是可以得到列车行进时加速和制动的时间段,其中\(T_{F}\)和\(T_{B}\)表示列车在全路段上做牵引和制动的时间集合：</p><p>\(T_{F}= \lbrace (t_{起}^{1},t_{终}^{1}), (t_{起}^{1},t_{终}^{1}),…,(t_{起}^{n},t_{终}^{n})\rbrace \)</p><p>\(T_{B}= \lbrace (\overline{t_{起}^{1}},\overline{t_{终}^{1}}), (\overline{t_{起}^{1}},\overline{t_{终}^{1}}),…,(\overline{t_{起}^{n}},\overline{t_{终}^{n}})\rbrace \)</p><p>下面考虑如何获取制造再生能最多的发车间隔，即列车之间加速和制动时间重合度最高的集合。根据我们的假设：前一列车的再生能仅供后一列车使用，那么每两列车之间的重叠时间仅仅与发车间隔有关。以第一列车发车的时间为时间零点，对不同发车间隔的牵引和制动时间段进行更新，得到：</p><p>\(T_{F}^i=T_{F}+\sum_{j=0}^{i=1}h_{j}\)</p><p>\(T_{B}^i=T_{B}+\sum_{j=0}^{i=1}h_{j}\)</p><p>\(h_{j}\)为第\(j\)列车和第\(j+1\)列车之间的发车间隔，\(T_{F}^i\)和\(T_{B}^i\)分别为第\(i\)列车做牵引和制动的时间集合。</p><p>令第\(i+1\)列车牵引加速时间和第\(i\)列车制动减速时间的重叠时间\(t_{overlap}^i = T_{F}^i \cap T_{B}^i\)，则问题转换为一个令重叠时间最大的多重背包问题：有541种物品(120秒至660秒不同的发车间隔)和一个容量为63900的背包，每种物品的可用数量有一定限制，，每种物品的体积\(h_{j}\)和价值\(t_{overlap}^i\)已知,取得99件物品装入背包恰好塞满整个背包且价值总和最大，满足约束条件如下：</p><ul><li><p>我们的发车间隔要求在120秒至660秒之间，这帮助我们剔除一部分位于发车间隔之外的数据。</p></li><li><p>不同的发车间隔对应的列车车数之和应该等于99，并且他们的乘积之和等于63900秒。</p></li><li><p>我们要求在限定时间63900秒完成全部100列车在全路段的运行，这样一来即使取平均值，发车间隔也在640秒左右，这帮助我们剔除一部分距离均值较远的数据，一来简化我们的计算，二来确保结果的可靠性。</p></li><li><p>要求发车间隔序列下重叠时间最大，这样得到可利用的再生能最多，使得总耗能最小。</p></li></ul><p>这样，我们实际上从541种物品(120秒至660秒不同的发车间隔)筛选出平均值上下的数据(620秒至660秒)，即有41种物品。最后设计的算法<del>一个没有控制不同发车间隔对应列车车数之和为99的粗糙算法</del>计算结果显示出一个趋势，我们总是得到两个不同的发车间隔，他们对应的列车车数接近，且和靠近99，这意味着什么呢，意味着该模型的最优解可能是两个不同的发车间隔，他们对应的列车车数相差不大，且满足第二个约束条件，按照这一思路<del>骚断腿的反向操作</del>，我们直接可以得到最优解为50列发车间隔为641秒，49列发车间隔为650秒，计算重叠时间是3161秒，<del>有种强行凑答案的感觉</del>。</p><h5 id="余下的问题"><a href="#余下的问题" class="headerlink" title="余下的问题"></a>余下的问题</h5><p>待续<del>GG</del>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看了别人的论文感觉真的强啊，看了自己的操作真的头疼，怕是成功参赛奖预定了，不过还是要挣扎一下的，毕竟生命在于折腾。</p><h4 id="如何联系我？"><a href="#如何联系我？" class="headerlink" title="如何联系我？"></a>如何联系我？</h4><p>不如就用邮件吧，请戳左上角。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>感谢阅读完这段内容，谢谢，祝您生活愉快，have a nice day ~</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p><del><code>Youtube</code>上有一个挪威地区列车行进的直播，可以欣赏挪威这个国家沿途的风景</del></p><p>替换为一个相关的视频吧，亦可自行搜索，关键词是<code>train view</code>。</p><iframe width="1903" height="930" src="https://www.youtube.com/embed/OeJ5xXrbkfU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><blockquote><p>赵丹玲, 程然, 杨风波. 面向节能的单/多列车优化控制研究</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 划水 </tag>
            
            <tag> 摸鱼 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你好啊世界</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      <content type="html"><![CDATA[<h3 id="这是哪里？"><a href="#这是哪里？" class="headerlink" title="这是哪里？"></a>这是哪里？</h3><p>欢迎来到我的小站，这里会记录一些东西，可能会很有趣，也可能有些无聊。应该会有关一些技术、乱七八糟的杂书、上古奇闻、突发脑洞或者别的什么<a id="more"></a>，自留地了一刚。</p><h3 id="破站吃枣药丸？"><a href="#破站吃枣药丸？" class="headerlink" title="破站吃枣药丸？"></a>破站吃枣药丸？</h3><p>本站是挂载在 GithubPages 上的一个静态博客，由于某不科学的原因，该博客在兼容国内外互联网资源上存在一定差异，因此特别提示，破站的评论系统 Disqus 、 Post 的内容中引用的 Youtube 视频可能需要魔法上网才能食用。本站的图片迫于原来的图床服务进入维护状态，故选择薅一下田厂的羊毛，使用 GitHub 仓库做一个图床，希望不会被封号。</p><p>在改善访问速度上，之前折腾过一次，给我累够呛，所以域名是不可能域名，备案是不可能备案的，破站还是安安静静的挂在 Github 上好了，这样一来由于 Github 受到某不科学的电磁炮干扰，在国内的访问存在一定<del>很大</del>影响，如果破站加载速度感人那我也没办法啦<del>就不会加钱吗，加钱啊，加钱上域名上 CDN 啊</del>。</p><p>更新的频率就随缘了，这个网站只为了记录我留下的足迹，这世界，我来过，嘿嘿。另外，当前使用的 Hexo 主题似乎停止更新了，不知道后续会不会产生兼容性的问题，但是我会尽可能维护破站的<del>只要 Github 不倒闭</del>。</p><h3 id="2018年8月16日更新"><a href="#2018年8月16日更新" class="headerlink" title="2018年8月16日更新"></a>2018年8月16日更新</h3><p>好的，给破站添加了评论系统 Disqus ，不过可能需要那啥以后才能看见，<del>Hexo 钦定的集成服务，不关我事啊</del>，欢迎留言。</p><h3 id="2019年11月6日更新"><a href="#2019年11月6日更新" class="headerlink" title="2019年11月6日更新"></a>2019年11月6日更新</h3><p>修改了一下英文内容的风格，嗯，想了半天还是变成代码段比较好看。</p><h3 id="如何联系我？"><a href="#如何联系我？" class="headerlink" title="如何联系我？"></a>如何联系我？</h3><p>不如就用邮件吧，请戳左上角。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>感谢阅读完这段内容，谢谢，祝您生活愉快， have a nice day ~ </p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
            <tag> Github </tag>
            
            <tag> 加钱 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/google793086aac06d721f.html"/>
      <url>/google793086aac06d721f.html</url>
      <content type="html"><![CDATA[google-site-verification: google793086aac06d721f.html]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h3 id="这是哪里？"><a href="#这是哪里？" class="headerlink" title="这是哪里？"></a>这是哪里？</h3><p>欢迎来到我的小站，这里会记录一些东西，可能会很有趣，也可能有些无聊。</p><p>应该会有关一些技术、乱七八糟的杂书、上古奇闻、突发脑洞或者别的什么，自留地了一刚<del>更新频率随缘了</del>。</p><h3 id="不更新网站的时候我都在做什么？"><a href="#不更新网站的时候我都在做什么？" class="headerlink" title="不更新网站的时候我都在做什么？"></a>不更新网站的时候我都在做什么？</h3><p>平时闲下来的时候喜欢读一些历史向的书，尤其比较喜欢三国、辽宋夏这两段历史。</p><p>会玩一些策略类游戏，最爱的是暗荣的三国志11，还有无双割草系列。</p><p>可能还会出门逛一逛，看一看热闹的大街。</p><h3 id="如何联系我？"><a href="#如何联系我？" class="headerlink" title="如何联系我？"></a>如何联系我？</h3><p>不如就用邮件吧，请戳左上角。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>感谢阅读完这段内容，谢谢，祝您生活愉快，have a nice day ~</p>]]></content>
    </entry>
    
    <entry>
      <title>图库</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>友链</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>时间轴</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
