<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenQian Dong&#39;s Web</title>
  
  <subtitle>Coder,Java,Linux,Google Fans</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wqdchn.github.io/"/>
  <updated>2020-04-10T00:16:01.137Z</updated>
  <id>https://wqdchn.github.io/</id>
  
  <author>
    <name>WenQian Dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础：多态</title>
    <link href="https://wqdchn.github.io/java-basic-polymorphism.html"/>
    <id>https://wqdchn.github.io/java-basic-polymorphism.html</id>
    <published>2020-04-09T23:09:22.000Z</published>
    <updated>2020-04-10T00:16:01.137Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>我们知道，面向对象的基本要素是封装、继承、多态。其中多态也叫动态绑定，是指程序在执行期间，判断所引用的对象的实际类型，根据实际类型来调用其相应的方法。以下面的代码为例，</p><pre><code class="Java">public class PolymorphTest {  public static void main(String[] args) {    Animal animal = new Dog(&quot;小白&quot;, &quot;白色&quot;);    Animal animal2 = new Cat(&quot;小橘&quot;, &quot;黑色&quot;);    animal.eat();    animal2.eat();  }}class Animal {  private String name;  Animal(String name) {    this.name = name;  }  public void eat() {    System.out.println(&quot;动物在吃东西&quot;);  }}class Dog extends Animal {  private String Color; // 肤色  Dog(String name, String Color) {    super(name);    this.Color = Color;  }  public void eat() {    System.out.println(&quot;小狗在吃骨头&quot;);  }}class Cat extends Animal {  private String eyeColor; // 眼睛色  Cat(String name, String eyeColor) {    super(name);    this.eyeColor = eyeColor;  }  public void eat() {    System.out.println(&quot;小猫在吃小鱼干&quot;);  }}输出：小狗在吃骨头小猫在吃小鱼干</code></pre><p>程序在执行 Animal animal = new Dog(“小白”, “白色”) 时，栈空间内会有一个变量 animal ，animal 指向堆空间中 new 出来的 Dog 对象。在 new 这个 Dog 对象的时候，首先会调用父类 Animal 的构造方法，把名字小白传递给构造方法 Animal(String name) ，然后再初始化自己的私有成员变量 Color。这样，当 Dog 对象的构造方法 Dog(String name, String Color) 执行完毕之后，内存空间中就出现了一个 Dog 对象和一个 Dog 对象的引用 animal 变量，这个 Dog 对象有自己的私有成员变量 Color，同时，Dog 对象中还包含了一个父类的 Animal 对象，这个 Animal 对象中包含了 Dog 对象的名字。</p><p>在方法区中，则存在两个 eat() 方法，分别是父类 Animal 对象的 eat() 方法和子类 Dog 对象的 eat() 方法，当我们执行 animal 的 eat 方法调用时，多态就发挥作用了，它会根据实际 new 出来的对象去取得对应的方法，并执行，所以我们看见了 小狗在吃骨头 而不是 动物在吃东西。</p><p>这里，我们小结一下，多态是指程序在执行期间，判断所引用的对象的实际类型，根据实际类型来调用其相应的方法，实现多态需要三个条件，分别是要有继承，子类要重写 Override 父类的方法，父类引用指向子类对象。</p><h3 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h3><p>那么多态是怎么实现的呢？回想一下类的加载机制，在类加载的准备阶段，Java 虚拟机会为类的静态字段分配内存，同时构造与该类相关联方法表，这个方法表就是实现动态绑定也就是多态的关键所在。</p><p>方法表本质是一个数组，它存储了当前类及其父类中非私有的实例方法。在动态绑定过程中，程序会访问栈空间上的调用者，根据其指向的对象取得调用者的实际类型，然后读取该类型的方法表，进而读取方法表中某个索引下对应的目标方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于多态更加细致的实现暂时先不讨论了，先了解到这里把。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;p&gt;我们知道，面向对象的基本要素是封装、继承、多态。其中多态也叫动态绑定，是指程序在执行期间，判断所引用的对
      
    
    </summary>
    
      <category term="Java" scheme="https://wqdchn.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wqdchn.github.io/tags/Java/"/>
    
      <category term="多态" scheme="https://wqdchn.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>对比Hashtable、HashMap、TreeMap有什么不同？</title>
    <link href="https://wqdchn.github.io/java-hashtable-hashmap-treemap.html"/>
    <id>https://wqdchn.github.io/java-hashtable-hashmap-treemap.html</id>
    <published>2020-04-01T00:14:00.000Z</published>
    <updated>2020-04-01T02:48:48.226Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="Map容器"><a href="#Map容器" class="headerlink" title="Map容器"></a>Map容器</h3><p>Map 通常被包括在 Java 集合框架中，但是其本身并不是真正的 Collection 集合类型。 Hashtable 、 HashMap 、 TreeMap 都是 Map 的实现，是以键值对的形式存储和操作数据的容器类型。</p><p><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/java-hashtable-hashmap-treemap/Java Map.png" alt="Java Map"></p><p> Hashtable 继承自  Dictionary 类，而 HashMap 与 TreeMap 继承 AbstractMap 类，它们的类结构上是不同的，不同的实现表明了它们不同的设计目的。</p><p> Hashtable 是 Java 类库关于哈希表的一个早期实现，它的方法都使用 synchronized 进行同步，是线程安全的。 Hashtable 不允许 key 为 null ，不允许 value 为 null 。   </p><p> HashMap 是使用最广的一种哈希表实现，大部分方法与 Hashtable 是相似的，但是减少了同步开销，因此是线程不安全的。 HashMap 允许 key 为 null ，允许 value 为 null 。</p><p> TreeMap 是基于红黑树的一种提供顺序访问的 Map ，与前两者不同，它的 put() 、 get() 等操作的时间复杂度都是 O(log(n)) 。其顺序可以通过 Comparator 来决定，或者根据键值的自然顺序 Comparable 来决定。它也是线程不安全的。 TreeMap 不允许 key 为 null ，允许 value 为 null 。</p><p>对于 TreeMap ，当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对 null 情况实现了特别处理，则可以 put() 存入，但是却不能正常使用 get() 访问，只能通过遍历去访问。</p><p>因此，建议遵循设计的规范，不要做这种使用错误。例如 HashMap 明确声明是线程不安全的，如果不加考虑，直接简单地应用在多线程场景中，总是要出问题的。</p><h3 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h3><p> HashMap 的底层是数组和链表组成的复合结构，数组被分成桶 bucket ，里面存放哈希值，通过哈希值来确定数组寻址时的数组下标。哈希值相同的键值对则以链表的形式存储，如果链表的长度超过阈值 TREEIFY_THRESHOLD = 8 ，则对链表进行改造，转化为红黑树。当红黑树的节点小于阈值 UNTREEIFY_THRESHOLD = 6 时，则对红黑树进行改造，转化为链表。我想这是为了避免链表在阈值附近频繁地转换造成过大的开销而设置的两个临界点。</p><h3 id="HashMap的工作流程"><a href="#HashMap的工作流程" class="headerlink" title="HashMap的工作流程"></a>HashMap的工作流程</h3><h4 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h4><p>存储对象时，将键值 K/V 对传给 put() 方法：</p><pre><code class="Java">public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}</code></pre><p>然后调用 hash() 方法计算 K 的哈希值：</p><pre><code class="Java">static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>这里进行了一个 hashCode() 高位数据移位到低位 h &gt;&gt;&gt; 16 并进行异或运算 ^ 的操作。将高位和低位进行异或运算，只要有高位或低位中有一位的变化，整个 hash() 返回的哈希值就会发生变化，尽可能地减少哈希碰撞。</p><p>在计算得到数值下标之后，通过 putVal() 方法进行存储， putVal() 方法本身的逻辑非常密集，从初始化、扩容、树化都与它有关：</p><pre><code class="Java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p>如果哈希表为 null ， resize() 方法会负责初始化 tab = resize() 。当哈希表容量不足时，出现 ++size &gt; threshold ， resize() 方法还会进行扩容。默认的初始化容量参数和最大容量参数如下。</p><pre><code class="Java">/**    * The default initial capacity - MUST be a power of two.    */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16， 2的4次方static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 2的30次方</code></pre><p>如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞。</p><p>如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true ，则更新键值对。</p><p>如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。</p><h4 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h4><p>获取对象时，将 K 传给 get() 方法：</p><p>调用 hash(K) 方法，计算 K 的 hash 值，从而获取该键值所在链表的数组下标。</p><pre><code class="Java">public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}</code></pre><p>然后顺序遍历链表，根据equals()方法查找相同 Node 链表中 K 值对应的 V 值。</p><pre><code class="Java">final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>扩容的方法比较复杂</p><pre><code class="Java">static final float DEFAULT_LOAD_FACTOR = 0.75f; // 负载因子final Node&lt;K,V&gt;[] resize() {    // ...    else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACIY &amp;&amp;                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)        newThr = oldThr &lt;&lt; 1; // double there       // ...     else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {          // zero initial threshold signifies using defaultsfults        newCap = DEFAULT_INITIAL_CAPAITY;        newThr = (int)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；    }    if (newThr ==0) {        float ft = (float)newCap * loadFator;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);    }    threshold = neThr;    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newap];    table = n；    // 移动到新的数组结构e数组结构 }</code></pre><p>如果负载因子 * 容量 &gt; 元素数量，则会进行扩容。扩容时创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小。</p><h4 id="树化改造"><a href="#树化改造" class="headerlink" title="树化改造"></a>树化改造</h4><p>在使用 put() 方法进行存储对象时，除了会遇到扩容方法，还有可能遇到树化改造：</p><pre><code class="Java">static final int MIN_TREEIFY_CAPACITY = 64;final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}</code></pre><p>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。</p><p>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</p><p>HashMap 之所以要进行树化改造，是因为底层结构中链表的遍历时间复杂度是 O(N) 的，在哈希碰撞较为严重的时候，链表较长，其存取性能较低，还可能有额外的安全隐患。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>hashCode 是所有 Java 对象的固有方法，如果不重载的话，返回的实际上是该对象在 JVM 的堆上内存地址，而不同对象的内存地址肯定不同，所以这个 hashCode 也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。</p><h3 id="equals-的特性。"><a href="#equals-的特性。" class="headerlink" title="equals 的特性。"></a>equals 的特性。</h3><p>自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br>对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br>传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br>一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br>非空性：对于任何非空引用值 x，x.equals(null) 都应返回 false。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大部分使用 Map 的场景，通常就是放入、访问或者删除，而对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。HashMap 的性能表现非常依赖于哈希码的有效性，请务必遵守 hashCode 和 equals 的一些基本约定：</p><ul><li>equals 相等，hashCode 一定要相等。</li><li>重写了 hashCode 也要重写 equals。</li><li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li></ul><p>以上内容都基于 jdk1.8.0_161 。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650125459&amp;idx=1&amp;sn=56a14e497b5644eba72f034ac791a4d9&amp;chksm=f36ba9b2c41c20a43611ef0d54747abdaf12f1f867ab23f2f0fc8eac87c657353c734f926cbb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">为啥 HashMap 的默认容量是16？</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651486554&amp;idx=1&amp;sn=23a0786a8c401c799042ac7a9aa0e811&amp;chksm=bd2515258a529c3312285c2536a92a7eb56805ded2eb726b72ab06beabe8e167d00d20789333&amp;scene=126&amp;sessionid=1585703424&amp;key=e7b22394d9386bca990226e723bf6055c836e7d8b7dabe02034009cb225b77c844a21b5027ec82bfa738aa258fea0d41ca89603c0b8e93de1540103a2ec25a970c5c796cb2d499aaa6fce20c5e2772c3&amp;ascene=1&amp;uin=MTIzMjgzNDMyNw%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AxuN6zS95LSdyZL9KQG5Oj0%3D&amp;pass_ticket=LGstMxzdbnh6CyV6rurD3W6ylR1d9GRkDMmoMP80xAWiS91bl%2B2xlMkQ2wePQ23q" target="_blank" rel="noopener">我说我了解集合类，面试官竟然问我为啥 HashMap 的负载因子不设置成1！？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Map容器&quot;&gt;&lt;a href=&quot;#Map容器&quot; class=&quot;headerlink&quot; title=&quot;Map容器&quot;&gt;&lt;/a&gt;Map容器&lt;/h3&gt;&lt;p&gt;Map 通常被包括在 Java 集合框架中，但是其本身并不是真正的 Collec
      
    
    </summary>
    
      <category term="Java" scheme="https://wqdchn.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wqdchn.github.io/tags/Java/"/>
    
      <category term="容器" scheme="https://wqdchn.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="集合" scheme="https://wqdchn.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="哈希表" scheme="https://wqdchn.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>对比Vector、ArrayList、LinkedList有何区别？</title>
    <link href="https://wqdchn.github.io/java-vector-arraylist-linkedlist.html"/>
    <id>https://wqdchn.github.io/java-vector-arraylist-linkedlist.html</id>
    <published>2020-03-31T00:24:58.000Z</published>
    <updated>2020-04-08T08:52:43.325Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="Java的集合框架"><a href="#Java的集合框架" class="headerlink" title="Java的集合框架"></a>Java的集合框架</h3><p> Java 提供的主要容器类型分别是集合框架与 Map ，集合通常是指 Collection 接口下的 List 、 Set 、 Queue 三类集合。一般认为 Collection 接口是 Java 集合框架的根，其子集构成了集合框架。 Map 并不属于 Collection 接口的子集，但是在概念是也当做集合来使用，但是它本身并不是真正的集合。注意，所有集合中都不能存放基础数据类型，只能存放对象的引用。</p><p><img src="https://raw.githubusercontent.com/wqdchn/blog-image/master/java-vector-arraylist-linkedlist/Java Collection.png" alt="Java Collection"></p><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p> Vector 、 ArrayList 、 LinkedList 是 List 的实现，都是有序集合。它们都提供了诸如随机访问、添加、删除等常用操作，以及迭代器遍历、排序等方法，在功能上较为相近。但是其具体的设计存在一定区别，因此在性能、线程安全等方面有所不同。</p><p>常用方法：</p><ul><li>size() 集合元素个数</li><li>add()/addAll() 添加元素</li><li>remove()/removeAll() 删除元素</li><li>get() 获取元素</li><li>set() 修改元素</li><li>sort() 集合元素排序</li><li>toArray() 转换</li><li>clear() 清空集合</li></ul><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p> Vector 是 Java 早期提供的线程安全的动态数组，内部使用对象数组类保存数据，其线程安全通过 synchronized 实现。</p><pre><code class="Java">public synchronized boolean add(E e) {    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = e;    return true;}public synchronized E remove(int index) {    modCount++;    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    E oldValue = elementData(index);    int numMoved = elementCount - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                            numMoved);    elementData[--elementCount] = null; // Let gc do its work    return oldValue;}</code></pre><p> Vector 默认创建一个大小为 10 的 Object 数组，并将动态扩展大小 capacityIncrement 设置为 0 。 Vector 能够根据需要进行自动扩容，当数组已满时，会创建新的数组，并拷贝原有数据。在初始化时若指定了容量的动态扩展大小 capacityIncrement &gt; 0 则依据指定的大小进行扩容，否则默认扩展一倍的容量。</p><pre><code class="Java">private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                        capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}public Vector() {    this(10);}public Vector(int initialCapacity, int capacityIncrement) {    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                            initialCapacity);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;}</code></pre><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p> ArrayList 是应用最多的动态数组，由于它没有了同步开销，因此性能更加良好。相应的，它不是线程安全的。 ArrayList 也支持动态扩容，但是与 Vector 默认扩容一倍不同， ArrayList 扩容时是增加当前容量的 50% ，其默认容量是 10 。</p><pre><code class="Java">private static final int DEFAULT_CAPACITY = 10;private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p> ArrayList 在执行插入操作时，若元素个数超过当前数组预定义容量的最大值，数组需要扩容，扩容过程需要调用底层 System.arraycopy() 方法进行大量的数组复制操作。它在删除元素时并不会减少数组的容量，但是如果需要缩小数组容量，可以调用 trimToSize() 方法。在查找元素时要遍历数组，对于非 null 的元素采取 equals 的方式寻找。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p> LinkedList 是双向链表，它不需要进行调整容量，它也不是线程安全的。 LinkedList 在插入元素时，须创建一个新的 Entry 对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。</p><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><p> Vector 、 ArrayList 、 LinkedList 内部都实现了排序操作，允许进行自定义排序。</p><pre><code class="Java">public class Test {  public static void main(String[] args) {    LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();    linkedList.add(&quot;c&quot;);    linkedList.add(&quot;b&quot;);    linkedList.add(&quot;a&quot;);    linkedList.sort(new Comparator&lt;String&gt;() {      @Override      public int compare(String o1, String o2) {        return o1.compareTo(o2);      }    });    linkedList.forEach((s) -&gt; {      System.out.print(s + &quot; &quot;);    });  }}输出 a b c </code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> Vector 、 ArrayList 、 LinkedList 是 List 的实现，都是有序集合。 Vector 、 ArrayList 使用数组实现，有需要时可以进行动态扩容， LinkedList 使用双向链表实现，不需要动态扩容。 Vector 是线程安全的，而 ArrayList 、 LinkedList 是线程不安全的。在分析以上三类集合的读写效率时，还应注意的一点是是否需要考尾部的情况。</p><p>以上内容都基于 jdk1.8.0_161 。</p><p><del>JDK源码是四个空格缩进，而我用的是Google Style两个空格缩进，有点不协调orz。</del></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651485602&amp;idx=2&amp;sn=569035c3b6bd1a1028df03517418e84a&amp;chksm=bd2519dd8a5290cb32f88a88fc8f57799b5d25e79452bc66749f83c40f593509931506603623&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575123269344&amp;sharer_shareid=3c5653a301d37ee49e0cb689e723404f#rd" target="_blank" rel="noopener">Java问答：用ArrayList还是LinkedList</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Java的集合框架&quot;&gt;&lt;a href=&quot;#Java的集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java的集合框架&quot;&gt;&lt;/a&gt;Java的集合框架&lt;/h3&gt;&lt;p&gt; Java 提供的主要容器类型分别是集合框架与 
      
    
    </summary>
    
      <category term="Java" scheme="https://wqdchn.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wqdchn.github.io/tags/Java/"/>
    
      <category term="容器" scheme="https://wqdchn.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="集合" scheme="https://wqdchn.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="数组" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="链表" scheme="https://wqdchn.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>R语言新手教程：我在哪，我的数据在哪</title>
    <link href="https://wqdchn.github.io/beginner-guide-to-r-demo1.html"/>
    <id>https://wqdchn.github.io/beginner-guide-to-r-demo1.html</id>
    <published>2020-03-07T10:17:55.000Z</published>
    <updated>2020-03-31T00:29:23.835Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="R语言与RStudio"><a href="#R语言与RStudio" class="headerlink" title="R语言与RStudio"></a>R语言与RStudio</h4><p>我知道新手那种对未知的知识，陌生的工具的恐惧和焦虑，一些对于老手来说就是几条命令行，几条代码的事，对于新手来说可能要摸索好几天才能找到头绪。虽说都有这么一个过程，但是能够尽快走过这个阶段总是好的。</p><p>今天我在一个<code>R</code>语言的群里看到一个新手同学为一个很简单的问题而困恼，不禁想起了我刚接触<code>R</code>语言的时候。不过我本身是计算机专业的学生，可能比较容易学习新的工具。但是对很多非计算机专业的学生来说，学习<code>R</code>语言可能是一件不那么容易的事。</p><p><code>R</code>语言自带了一个<code>GUI</code>，也就是编程时的用户界面了，不过它的风格非常朴素，功能也很朴素，不太适合作为新手上手的工具。因此，我强烈建议使用<code>RStudio</code>，这里并不介绍<code>RStudio</code>的安装、启动，以及<code>RStudio</code>面板上各个窗口表示的内容。相信知乎、简书等网站上有很多详细的中文教程。</p><p>那么这篇文章要介绍什么东西呢？</p><p>很简单，就是如何在<code>RStudio</code>命令窗口中使用<code>R</code>语言，命令它告诉我，我在哪。</p><h4 id="我在哪，我的数据在哪"><a href="#我在哪，我的数据在哪" class="headerlink" title="我在哪，我的数据在哪"></a>我在哪，我的数据在哪</h4><p>我执行了读取文件的命令，但是却显示错误，请问是怎么回事啊？？？</p><p>这是我在群里最容易看到的一个问题。一看新手同学贴出来的<code>R</code>代码可能类似这样：</p><pre><code class="R">&gt; read_csv(&quot;data.csv&quot;)Error: &#39;data.csv&#39; does not exist in current working directory (&#39;F:/Documents&#39;).</code></pre><p>报错信息提示我们，文件<code>data.csv</code>不在工作路径<code>F:/Documents</code>下。也就是说，我现在在的这个地方没有这个东西。那么，首先要知道的就是，我现在在哪里。在<code>R</code>中，可以通过<code>getwd()</code>命令来获取当前所在的工作路径。</p><pre><code class="R">&gt; getwd()[1] &quot;F:/Documents&quot;</code></pre><p>输出的信息提示我们，我现在处于文件夹<code>F:/Documents</code>目录下。然后我又发现，我的<code>data.csv</code>文件其实是在文件夹<code>F:/Documents/test</code>目录下的。那么我该怎么让<code>R</code>读取到它呢？一种方法是改变工作路径，我的数据在哪里，我就要把哪里里当做工作路径。这可以通过<code>setwd()</code>命令来实现。注意，我们需要为该命令指定相应的路径参数，否则该命令将报错，因为你没有告诉<code>R</code>到底去哪里。</p><pre><code class="R">&gt; getwd()[1] &quot;F:/Documents&quot;&gt; setwd(&quot;F:/Documents/test&quot;)&gt; getwd()[1] &quot;F:/Documents/test&quot;</code></pre><p>现在我们来到了文件夹<code>F:/Documents/test</code>目录下，这时，最初那条执行错误的命令可以顺利执行了。</p><pre><code class="R">&gt; read_csv(&quot;data.csv&quot;)Parsed with column specification:cols(  .default = col_double(),  diagnosis = col_character())See spec(...) for full column specifications.# A tibble: 569 x 32</code></pre><p>你看，我们读取到了一个<code>569 x 32</code>的数据框，数据成功地进入了<code>R</code>环境中。这是为什么呢？首先通过如下命令来查看<code>read_csv()</code>的参数。</p><pre><code class="R">&gt; args(read.csv)function (file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\&quot;&quot;, dec = &quot;.&quot;,     fill = TRUE, comment.char = &quot;&quot;, ...) NULL</code></pre><p>可以看到，<code>read_csv()</code>命令中第一个参数是文件。最初的时候，我们位于<code>F:/Documents</code>工作路径，我们指定的<code>data.csv</code>只告诉了文件名，那么<code>read_csv()</code>就会到<strong>相对路径</strong>中寻找。因为<code>read_csv()</code>并不清楚这个东西到底在哪里，那没办法了，就在工作路径里找找看，有就有，没有拉倒吧，别的地方我是不会去找的。此时，这个相对路径就是工作路径。而我的<code>data.csv</code>文件其实是在文件夹<code>F:/Documents/test</code>目录下的，那结果当然是找不到了。</p><p>这时候我们灵机一动，如果我在<code>read_csv()</code>命令中第一个参数中指定<code>data.csv</code>的真实位置和文件名呢？我们依然回到最初的地点，将<code>F:/Documents</code>设置为工作路径，再告诉<code>read_csv()</code>命令<code>data.csv</code>的真实位置和文件名。</p><pre><code class="R">&gt; setwd(&quot;F:/Documents&quot;)&gt; getwd()[1] &quot;F:/Documents&quot;&gt; read_csv(&quot;F:/Documents/test/data.csv&quot;)Parsed with column specification:cols(  .default = col_double(),  diagnosis = col_character())See spec(...) for full column specifications.# A tibble: 569 x 32</code></pre><p>结果顺利地读取到了这个文件。这又是为什么呢？？？这是因为，我们这次告诉<code>read_csv()</code>命令的是<strong>绝对路径</strong>：你必须到这个地方找到这个东西，于是<code>read_csv()</code>就乖乖去找了。</p><p>对于老手来说，可能会觉得这种问题很可笑。但是偏偏就是这些不起眼的问题，常常给新手同学造成很大的烦恼。</p><p>我在哪，我的数据在哪，一切的一切都从这里出发，绽放出耀眼的光彩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;R语言与RStudio&quot;&gt;&lt;a href=&quot;#R语言与RStudio&quot; class=&quot;headerlink&quot; title=&quot;R语言与RStudio&quot;&gt;&lt;/a&gt;R语言与RStudio&lt;/h4&gt;&lt;p&gt;我知道新手那种对未知的知识，陌生
      
    
    </summary>
    
      <category term="R语言" scheme="https://wqdchn.github.io/categories/R%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="R语言" scheme="https://wqdchn.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
      <category term="RStudio" scheme="https://wqdchn.github.io/tags/RStudio/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode股票买卖系列</title>
    <link href="https://wqdchn.github.io/leetcode-best-time-to-by-and-sell-stock.html"/>
    <id>https://wqdchn.github.io/leetcode-best-time-to-by-and-sell-stock.html</id>
    <published>2020-03-06T01:01:48.000Z</published>
    <updated>2020-03-31T23:48:39.863Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h4><p>来看<code>LeetCode</code>的股票买卖系列问题的第一题<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a>。这一题要求在一系列股票价格中，通过一次买卖交易获得最大的收益。假设有这么一组股票价格<code>[7,1,5,3,6,4]</code>，我们只能在买进之后再卖出来赚取收益。很显然，我们需要在第二天的时候以<code>1</code>元的价格买进，然后在第五天的时候以<code>6</code>元的价格卖出，这样得到最大的收益<code>5</code>元。这可以用暴力法通过两层<code>for</code>循环遍历实现，但是还有一个比较好的办法，更加贴近人的思维。</p><p>首先，我们知道，买进时的股价是代价，卖出时的股价和代价之间的差价是收益。我们的目的是希望代价最低，收益最高。以上面的股价序列为例，如果我们在第一天以<code>7</code>元的价格买入股票，这时代价是<code>7</code>，收益是<code>0</code>。到了第二天，现在的股价是<code>1</code>，意味着此时代价可以是<code>1</code>，而收益是<code>1-7</code>等于<code>-6</code>。所以我们更新一下代价，但是不更新收益，此时代价是<code>1</code>，收益是<code>0</code>。从人类的思维来说，这是选择在第二天买进，然后等等看。到了第三天，现在的股价是<code>5</code>，此时的代价可以是<code>5</code>，而收益是此时的股价减去之前的代价<code>5-1</code>等于<code>4</code>。所以我们选择更新收益，但是不更新代价，此时代价是<code>1</code>，收益是<code>4</code>。以此类推，有更小的代价就更新代价，有更高的收益就更新收益。</p><pre><code class="Java">class Solution {  public int maxProfit(int[] prices) {    if (prices.length &lt; 2) {      return 0;    }    int cost = Integer.MAX_VALUE;    int profit = 0;    for (int price : prices) {      cost = Math.min(cost, price);      profit = Math.max(profit, price - cost);    }    return profit;  }}</code></pre><h4 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h4><p>来看<code>LeetCode</code>的股票买卖系列问题的第三题<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III</a>。这一题要求在一系列股票价格中获得最大的收益，最多可以通过两次买卖交易，但是需要第一次买卖交易完成之后才能进行第二次买卖交易。</p><p>与第一题类似，只是可以多一次交易。进行第二次交易时，我们可以把第一次交易的收益当做代价。</p><pre><code class="Java">class Solution {  public int maxProfit(int[] prices) {    if (prices.length &lt; 2) {      return 0;    }    int cost1 = Integer.MAX_VALUE;    int profit1 = 0;    int cost2 = Integer.MAX_VALUE;    int profit2 = 0;    for (int price : prices) {      cost1 = Math.min(cost1, price);      profit1 = Math.max(profit1, price - cost1);      cost2 = Math.min(cost2, price - profit1);      profit2 = Math.max(profit2, price - cost2);    }    return profit2;  }}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>股市有风险，入行需谨慎。股民如何在最好的时机买进股票，并在最好的时机卖出股票，这是一个玄学问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Best-Time-to-Buy-and-Sell-Stock&quot;&gt;&lt;a href=&quot;#Best-Time-to-Buy-and-Sell-Stock&quot; class=&quot;headerlink&quot; title=&quot;Best Time to Buy and Sell Stoc
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://wqdchn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>R语言获取标准中国地图</title>
    <link href="https://wqdchn.github.io/get-china-map-with-R.html"/>
    <id>https://wqdchn.github.io/get-china-map-with-R.html</id>
    <published>2020-03-04T02:49:48.000Z</published>
    <updated>2020-04-09T23:15:11.849Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="地图在哪里"><a href="#地图在哪里" class="headerlink" title="地图在哪里"></a>地图在哪里</h3><p>空间数据分析离不开基础地理数据的支持，比如省市县乡等各级行政区划的数据。然而我国的基础地理数据处于一种薛定谔的状态，往往找不到一个能给出基础地理数据的政府部门的官网。有些网站会共享一部分基础地理数据，但是申请数据的手续有时非常复杂， 即要注册提交个人信息，又要手持身份证拍照，还要写下申请书。于是在大部分情况下只能转向万能的某宝，说多了都是泪。</p><p>最近突然发现，民政部的官网悄咪咪的提供了一个接口可以获取到一些基础地理数据。既然是民政部门提供的数据，那当然是最权威的，再也不用担心有些数据中存在的南海九段线缺失，台湾岛没有等问题啦。</p><h3 id="获取全国县级地图"><a href="#获取全国县级地图" class="headerlink" title="获取全国县级地图"></a>获取全国县级地图</h3><p>民政部提供了省级与县级的 json 格式地图数据，我们可以使用 R 语言的 sf 包读取需要的数据，然后使用 tmap 包来绘制地图。</p><pre><code class="R">library(sf)library(tmap)# 民政部官网url &lt;- &quot;http://xzqh.mca.gov.cn/data/&quot;# 获取全国县级地图xian_quanguo &lt;- sf::st_read(  dsn = paste0(url, &quot;xian_quanguo.json&quot;),  stringsAsFactors = FALSE)# 简单检查一下数据head(xian_quanguo)st_crs(xian_quanguo) &lt;- st_crs(&quot;+proj=longlat +datum=WGS84&quot;)# tmap绘制地图tm_shape(xian_quanguo) +   tm_polygons() +   tm_compass(position = c(&quot;left&quot;, &quot;bottom&quot;)) + # 指北针  tm_scale_bar(position = c(&quot;left&quot;, &quot;bottom&quot;)) # 比例尺</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sf 包的计算效率非常高，是当前 R 语言空间数据分析过程中不可缺少的重要工具，强烈 push。 tmap 包是我接触的比较友好的一种地图可视化包，使用也很简洁，更新也比较及时。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/r-spatial/sf" target="_blank" rel="noopener">sf: A package that provides simple features access for R</a></p><p><a href="https://github.com/mtennekes/tmap" target="_blank" rel="noopener">tmap: R package for thematic maps</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;地图在哪里&quot;&gt;&lt;a href=&quot;#地图在哪里&quot; class=&quot;headerlink&quot; title=&quot;地图在哪里&quot;&gt;&lt;/a&gt;地图在哪里&lt;/h3&gt;&lt;p&gt;空间数据分析离不开基础地理数据的支持，比如省市县乡等各级行政区划的数据。然而我国
      
    
    </summary>
    
      <category term="R语言" scheme="https://wqdchn.github.io/categories/R%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="R语言" scheme="https://wqdchn.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
      <category term="地图" scheme="https://wqdchn.github.io/tags/%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="tmap" scheme="https://wqdchn.github.io/tags/tmap/"/>
    
      <category term="sf" scheme="https://wqdchn.github.io/tags/sf/"/>
    
  </entry>
  
  <entry>
    <title>说一说二分查找</title>
    <link href="https://wqdchn.github.io/bin-search.html"/>
    <id>https://wqdchn.github.io/bin-search.html</id>
    <published>2020-02-20T13:08:46.000Z</published>
    <updated>2020-03-31T06:56:46.074Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找也称折半查找，思想很简单，对于一个有序数组，查找数组中是否存在指定元素，只需比较指定元素与数组中间元素的大小关系，通过这种比较来判断下一次查找的范围，直到完成整个查找。尽管二分查找的基本思想相对简单，但有时它的细节可以令人难以招架。</p><h3 id="一个简单的二分查找实现"><a href="#一个简单的二分查找实现" class="headerlink" title="一个简单的二分查找实现"></a>一个简单的二分查找实现</h3><pre><code class="Java"> public int binSearch(int[] nums, int key) {    int left = 0;    int right = nums.length - 1;    while (left &lt;= right) {      int mid = left + ((right - left) &gt;&gt;&gt; 1);      if (nums[mid] &gt; key) {        right = mid - 1;      } else if (nums[mid] &lt; key) {        left = mid + 1;      } else {        return mid;      }    }    return -1;  }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h3&gt;&lt;p&gt;二分查找也称折半查找，思想很简单，对于一个有序数组，查找数组中是否存在指定元素，只需比较
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="位运算" scheme="https://wqdchn.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="二分查找" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第204题Count Primes</title>
    <link href="https://wqdchn.github.io/leetcode-count-primes.html"/>
    <id>https://wqdchn.github.io/leetcode-count-primes.html</id>
    <published>2020-02-08T01:33:25.000Z</published>
    <updated>2020-03-31T23:48:49.682Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Count-Primes"><a href="#Count-Primes" class="headerlink" title="Count Primes"></a>Count Primes</h4><p><a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="noopener">Count Primes</a>给出一个数，计算小于这个数的所有的素数个数。例如，输入<code>10</code>，则<code>10</code>以内的素数有四个，分别为<code>2</code>，<code>3</code>，<code>5</code>，<code>7</code>，故返回<code>4</code>。</p><p>求素数的问题相信很多计算机专业的同学在大一刚接触编程的时候一定会碰上，求素数也不难。但是在这里是求素数的个数，一个很简单的思路是调用素数判断的函数，如果是素数则计数加一，最后返回结果。</p><pre><code class="Java"> //Runtime: 548 ms, faster than 13.15% of Java online submissions for Count Primes. public static int countPrimes(int n) {    int count = 0;    for (int i = 1; i &lt; n; i++) {      if (isPrime(i)) {        count++;      }    }    return count;  }  public static boolean isPrime(int n) {    if (n &lt;= 1) {      return false;    }    for (int i = 2; i * i &lt;= n; i++) {      if (n % i == 0) {        return false;      }    }    return true;  }</code></pre><p>但是你也看到了，这样的效率并不高，有没有办法让它更高更快更强呢，答案是有的。</p><p>首先我们知道，所有的偶数都不是素数，也就是说，我们的<code>n</code>中有一半都不是素数，即我们的<code>count</code>最多也就是<code>n/2</code>。</p><p>其次，我们只需要在剩下的一半中寻找素数，或者反向操作寻找不是素数的，然后令<code>count</code>不断地减减。</p><pre><code class="Java">  // Runtime: 6 ms, faster than 99.32% of Java online submissions for Count Primes.  public static int countPrimes2(int n) {    if (n &lt; 3) {      return 0;    }    int count = n / 2;    boolean not_prime[] = new boolean[n];    // i从奇数开始，从奇数中取    // i会取3，5，7，9...    for (int i = 3; i * i &lt; n; i += 2) {      if (not_prime[i] == true) {        continue;      }      // j从奇数开始，从奇数中取，我们要剔除的是i的奇数倍      // j会取 3*3， 3*(3+2)，3*(3+4)，3*(3+6)...      for (int j = i * i; j &lt; n; j += i * 2) {        // 找到count个奇数中的合数，count--，并标记为非素数        if (not_prime[j] == false) {          not_prime[j] = true;          count--;        }      }    }    return count;  }</code></pre><p>是不是更高更快更强了呢。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>素数真好玩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Count-Primes&quot;&gt;&lt;a href=&quot;#Count-Primes&quot; class=&quot;headerlink&quot; title=&quot;Count Primes&quot;&gt;&lt;/a&gt;Count Primes&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="素数" scheme="https://wqdchn.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>再见二零一九</title>
    <link href="https://wqdchn.github.io/goodbye-2019.html"/>
    <id>https://wqdchn.github.io/goodbye-2019.html</id>
    <published>2020-01-24T11:10:09.000Z</published>
    <updated>2020-01-24T11:22:21.048Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="久违的更新"><a href="#久违的更新" class="headerlink" title="久违的更新"></a>久违的更新</h4><p>好久不见，有好多话想说，但是还是决定留在心里，且做后来故事。</p><p>今天是除夕，祝愿大家春节愉快，平安健康。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;久违的更新&quot;&gt;&lt;a href=&quot;#久违的更新&quot; class=&quot;headerlink&quot; title=&quot;久违的更新&quot;&gt;&lt;/a&gt;久违的更新&lt;/h4&gt;&lt;p&gt;好久不见，有好多话想说，但是还是决定留在心里，且做后来故事。&lt;/p&gt;
&lt;p&gt;今天
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wqdchn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://wqdchn.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="成长" scheme="https://wqdchn.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="春节" scheme="https://wqdchn.github.io/tags/%E6%98%A5%E8%8A%82/"/>
    
      <category term="新年" scheme="https://wqdchn.github.io/tags/%E6%96%B0%E5%B9%B4/"/>
    
      <category term="久违的更新" scheme="https://wqdchn.github.io/tags/%E4%B9%85%E8%BF%9D%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第322题Coin Change</title>
    <link href="https://wqdchn.github.io/leetcode-coin-change.html"/>
    <id>https://wqdchn.github.io/leetcode-coin-change.html</id>
    <published>2019-11-29T09:36:35.000Z</published>
    <updated>2020-03-31T23:48:59.634Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h4><p><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Coin Change</a>给出不同币值的硬币和一个目标金额，求组成目标金额所需最少的硬币数量，注意，这里可供取用的硬币数据量是不限制的，如果没有可用的硬币，则返回-1即可。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: coins = [2], amount = 3<br>Output: -1</p></blockquote><p>这一题使用暴力法会超时，因此需要改换策略，实际上就是要求使用动态规划来完成。动态规划最头痛的就是递推方程，要了解每一次方程的状态是如何转移的，简直让我选择放弃，好在这一题是找零钱，仿佛小学生奥数似的，稍有些趣味性，不妨挑战一下。</p><p>以示例一为例，我们现在有1，2，5三种币值的硬币，且任意取用。当我们需要11块钱的时候，我们可以选择摸11个一块钱，也可以选择摸5个两块钱和1个一块钱，当然，最少的是摸2个五块钱和1个一块钱。那么这里就存在一种规律了，比如说我们恰好摸了2个五块钱和1个一块钱，完成了任务，可是这个过程中，我们是摸了2个五块钱和1个一块钱的<del>这不是废话嘛！！！</del>注意了，这个2个五块钱和1个一块钱可不简单，它们分别是十块钱和一块钱<del>这又是什么废话啊！！！</del><br>嗯，到这里暗示已经结束，该明示了。就是说，组合11块钱的任务是由组合10块钱和组合1块钱来完成的，而两个组合也恰好是最少的，不仅是组合成11块钱是最少的，他们本身组合成10块钱和组合成1块钱也是最少的。因此，我们的动态规划递推方程中，当前的组合金额<code>(11)</code>还有币值<code>(1,2,5)</code>与之前的组合金额<code>(10,1)</code>是有关联的，我们最终会推到<code>0</code>，也就是什么都不做。</p><p>简单的数学公式是这样的：<br><code>F(11) = min(F(11-1),F(11-2),F(11-5)) + 1</code><br><code>F(11) = min(F(10),F(9),F(6)) + 1</code><br>然后呢我们分别再求<code>F(10)</code>、<code>F(9)</code>、<code>F(6)</code>….</p><p>这个<code>F</code>函数就是我们要实现的摸硬币操作。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><p>注意：外层循环表示可用的硬币组合，内层循环则表示在当前可用的硬币组合下，完成目标金额数所需要的硬币数量。</p><pre><code class="Java">class Solution {  public static int coinChange(int[] coins, int amount) {    if (amount == 0) {      return 0;    }    int[] dp = new int[amount + 1];    Arrays.fill(dp, amount + 1);    dp[0] = 0;    for (int coin : coins) {      for (int i = coin; i &lt; amount + 1; i++) {        dp[i] = Math.min(dp[i], dp[i - coin] + 1);      }    }    return dp[amount] != amount + 1 ? dp[amount] : -1;  }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def coinChange(self, coins, amount):        dp = [0] + [float(&#39;inf&#39;)] * amount        for coin in coins:            for i in range(coin, amount + 1):                dp[i] = min(dp[i], dp[i - coin] + 1)        return dp[-1] if dp[-1] != float(&#39;inf&#39;) else -1 </code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第322题是中等题，除了找零钱有些趣味，动态规划实在打扰了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Coin-Change&quot;&gt;&lt;a href=&quot;#Coin-Change&quot; class=&quot;headerlink&quot; title=&quot;Coin Change&quot;&gt;&lt;/a&gt;Coin Change&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://wqdchn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>R语言ggplot2绘图转PDF中文乱码问题</title>
    <link href="https://wqdchn.github.io/r-ggplot2-to-pdf-with-chinese.html"/>
    <id>https://wqdchn.github.io/r-ggplot2-to-pdf-with-chinese.html</id>
    <published>2019-10-20T12:53:49.000Z</published>
    <updated>2020-03-31T00:29:17.699Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="ggplot2与中文乱码的Solution"><a href="#ggplot2与中文乱码的Solution" class="headerlink" title="ggplot2与中文乱码的Solution"></a>ggplot2与中文乱码的Solution</h4><h5 id="字体文件"><a href="#字体文件" class="headerlink" title="字体文件"></a>字体文件</h5><p>首先假设你有一个<code>Windows</code>系统，其次进行R语言编程所使用的<code>IDE</code>是<code>RStudio</code><del>非常好用的集成开发环境</del>。</p><p>然后在<code>Windows</code>系统中找到中文字体，比如宋体或黑体，再找到一个英文字体，比如<code>Times New Roman</code>。它们大概在<code>C盘</code>的<code>Windows/Fonts</code>路径下。</p><p>找出所需的字体文件，比如宋体的字体文件是<code>simsun.ttc</code>，黑体的字体文件是<code>simhei.ttf</code>，<code>Times New Roman</code>的字体文件是<code>times.ttf</code>。</p><p>找到字体文件就是成功的一半了，然后我把它们随便放到一个地方准备加载。</p><h5 id="showtext包"><a href="#showtext包" class="headerlink" title="showtext包"></a>showtext包</h5><p>然后需要在<code>R</code>中调用<code>showtext</code>包，如果没有这个包，请安装它。</p><pre><code class="R"># 调用showtext包library(showtext)showtext_auto(enable = TRUE)# 载入黑体font_add(&quot;heiti&quot;, regular = &quot;F:\\font\\simhei.ttf&quot;)# 载入宋体font_add(&quot;songti&quot;, regular = &quot;F:\\font\\simsun.ttc&quot;)# 载入Times New Roman字体font_add(&quot;newrom&quot;, regular = &quot;F:\\font\\times.ttf&quot;)</code></pre><p>在上面，我们载入了三种字体，并重命名<del>请随意命名</del>后供<code>ggplot2</code>调用。</p><p>注意载入的路径，在<code>Windows</code>下好像要使用反斜杠。</p><p>注意，使用字体的过程中，可能会出现提示没有这种字体！！！！！！无妨，重新执行一下上面的命令可以解决。</p><h5 id="ggplot2绘图带中文"><a href="#ggplot2绘图带中文" class="headerlink" title="ggplot2绘图带中文"></a>ggplot2绘图带中文</h5><pre><code class="R">p &lt;- ggplot() + geom_point() + ... +        theme(axis.title.x = element_text(family=&quot;newrom&quot;), axis.title.y = element_text(family = &quot;songti&quot;)) +        xlab(&quot;Hello World&quot;) +         ylab(&quot;你好世界&quot;)</code></pre><p>在上面的命令中，我们把<code>X</code>轴的字体指定为<code>Times New Roman</code>，<code>Y</code>轴的字体指定为宋体。</p><h5 id="转换为PDF"><a href="#转换为PDF" class="headerlink" title="转换为PDF"></a>转换为PDF</h5><pre><code class="R">p &lt;- ggplot() + geom_point() + ... +        theme(axis.title.x = element_text(family=&quot;newrom&quot;), axis.title.y = element_text(family = &quot;songti&quot;)) +        xlab(&quot;Hello World&quot;) +         ylab(&quot;你好世界&quot;)ggsave(&quot;Fig_p.pdf&quot;, plot = p)</code></pre><p>在上面的命令中，我们把<code>p</code>转换为了<code>PDF</code>。再次提醒，这个过程中，可能会出现提示没有这种字体！！！！！！无妨，重新执行一下上面的字体加载命令即可解决。</p><p>然后我们查看一下生成的<code>PDF</code>，应该会得到一个<code>X</code>轴字体是<code>Times New Roman</code>的英文<code>Hello World</code>，<code>Y</code>轴字体是宋体的中文你好世界。</p><p>如果你使用<code>RStudio</code>的图片预览功能，并且尝试<code>Save as PDF</code>，那么可能依然会出现中文乱码问题。</p><p>去试试看吧！</p><h4 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h4><p>上面的内容只能解决文字中不包含中英文混合的情况。如果需要中英文混合，那么可能需要把某两种中英文字体文件合并生成新的字体文件，然后加载进来才行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;ggplot2与中文乱码的Solution&quot;&gt;&lt;a href=&quot;#ggplot2与中文乱码的Solution&quot; class=&quot;headerlink&quot; title=&quot;ggplot2与中文乱码的Solution&quot;&gt;&lt;/a&gt;ggplo
      
    
    </summary>
    
      <category term="R语言" scheme="https://wqdchn.github.io/categories/R%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="R语言" scheme="https://wqdchn.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
      <category term="RStudio" scheme="https://wqdchn.github.io/tags/RStudio/"/>
    
      <category term="ggplot2" scheme="https://wqdchn.github.io/tags/ggplot2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第104题Maximum Depth of Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-maximum-depth-of-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-maximum-depth-of-binary-tree.html</id>
    <published>2019-10-11T07:12:39.000Z</published>
    <updated>2020-03-31T23:53:02.152Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h4><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a>求二叉树的最大深度。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5]<br>Output: 4</p></blockquote><p>二叉树的深度可以通过深度优先搜索和广度优先搜索两种方式来遍历，并记录树的层次。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    // dfs    public int maxDepth(TreeNode root) {        return root == null ? 0 : 1 + Math.max(maxDepth(root.left),maxDepth(root.right));    }    // bfs    public int maxDepth(TreeNode root) {        if (root == null) return 0;        Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);        int depth = 0;        while (!q.isEmpty()){            int size = q.size();            while (size-- &gt; 0){                TreeNode node = q.poll();                if (node.left != null){                    q.offer(node.left);                }                if (node.right != null){                    q.offer(node.right);                }            }            depth++;        }        return depth;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # dfs    def maxDepth(self, root: TreeNode) -&gt; int:        if not root: return 0        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))    # bfs    def maxDepth(self, root):        if not root: return 0        q = collections.deque([(root, 1)])        while q:            curr, depth = q.popleft()            if not curr.left and not curr.right and not q:                return depth            if curr.left:                q.append((curr.left, depth + 1))            if curr.right:                q.append((curr.right, depth + 1))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第104题是简单题，只需熟悉二叉树的深度优先搜索与广度优先搜索，并记录对应的层次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Maximum-Depth-of-Binary-Tree&quot;&gt;&lt;a href=&quot;#Maximum-Depth-of-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Maximum Depth of B
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="深度优先搜索" scheme="https://wqdchn.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="广度优先搜索" scheme="https://wqdchn.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第111题Minimum Depth of Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-minimum-depth-of-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-minimum-depth-of-binary-tree.html</id>
    <published>2019-10-10T05:14:13.000Z</published>
    <updated>2020-03-31T23:52:52.721Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h4><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a>求二叉树的最小深度。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5]<br>Output: 3</p></blockquote><p>二叉树的深度可以通过深度优先搜索和广度优先搜索两种方式来遍历，并记录树的层次。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    // dfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        int left = minDepth(root.left);        int right = minDepth(root.right);        return (left == 0 || right ==0) ? left + right + 1 : Math.min(left, right) + 1;    }    // bfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);        int depth = 1;        while (!q.isEmpty()){            int size = q.size();            while (size-- &gt; 0){                TreeNode node = q.poll();                if (node.left == null &amp;&amp; node.right == null){                   return depth;                }                if (node.left != null){                    q.offer(node.left);                }                if (node.right != null){                    q.offer(node.right);                }            }            depth++;        }        return depth;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # dfs    def minDepth(self, root: TreeNode):        if not root:            return 0        if not root.left and not root.right:            return 1        if root.left and not root.right:            return 1 + self.minDepth(root.left)        if root.right and not root.left:            return 1 + self.minDepth(root.right)        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))    # bfs    def minDepth(self, root):        if not root: return 0        q = collections.deque([(root, 1)])        while q:            curr, depth = q.popleft()            if not curr.left and not curr.right:                return depth            if curr.left:                q.append((curr.left, depth + 1))            if curr.right:                q.append((curr.right, depth + 1))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第111题是简单题，只需熟悉二叉树的深度优先搜索与广度优先搜索，并记录对应的层次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Minimum-Depth-of-Binary-Tree&quot;&gt;&lt;a href=&quot;#Minimum-Depth-of-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Minimum Depth of B
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="深度优先搜索" scheme="https://wqdchn.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="广度优先搜索" scheme="https://wqdchn.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第235题Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html</id>
    <published>2019-10-09T02:23:53.000Z</published>
    <updated>2020-03-31T23:53:21.065Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Search Tree</a>给定一个二叉<strong>搜索</strong>树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p></blockquote><p>这一题和236题<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>有些相似，二叉搜索树是二叉树的一种，所以236题的解法也适用于这题。特别的是，二叉搜索树中根节点的值大于左子树的节点值，小于右子树的节点值，这是可以利用的一个性质：</p><ul><li>我们记<code>LCA(2,8) = 6</code>，此时节点<code>p</code>和<code>q</code>是2和8，我们将节点值与根节点值6进行比较，发现<code>p</code>和<code>q</code>分别位于根节点左右两侧，此时根节点6是最近祖先。</li><li>我们记<code>LCA(7,9) = 8</code>，此时节点<code>p</code>和<code>q</code>是7和9，我们将节点值与根节点值6进行比较，发现<code>p</code>和<code>q</code>都大于根节点，都位于右子树，于是，我们进入右子树进行遍历，此时原来右子树的根节点8成为新的根节点，继续遍历比较。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        int parentVal = root.val;        int pVal = p.val;        int qVal = q.val;        if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {            return lowestCommonAncestor(root.right, p, q);        } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {            return lowestCommonAncestor(root.left, p, q);        } else {            return root;        }    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q):        if p.val &lt; root.val &gt; q.val:            return self.lowestCommonAncestor(root.left, p, q)        if p.val &gt; root.val &lt; q.val:            return  self.lowestCommonAncestor(root.right, p, q)        return  root</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第235题是简单题，利用二叉<strong>搜索</strong>树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Lowest-Common-Ancestor-of-a-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#Lowest-Common-Ancestor-of-a-Binary-Search-Tree&quot; class=&quot;h
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2019年国庆节</title>
    <link href="https://wqdchn.github.io/national-day-of-the-people-s-republic-of-china.html"/>
    <id>https://wqdchn.github.io/national-day-of-the-people-s-republic-of-china.html</id>
    <published>2019-10-04T12:24:51.000Z</published>
    <updated>2019-10-05T02:33:47.570Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="国庆·1949-2019"><a href="#国庆·1949-2019" class="headerlink" title="国庆·1949-2019"></a>国庆·1949-2019</h4><p>今年的国庆节似乎有些特别，从大面上来说，我感受到非常高涨的热情，无论是朋友圈还是微博，也许是这一年发生太多以往没有发生的事，让普通群众们了解到了周边生活之外的零零碎碎，激发起了内心朴素的那一份感情：希望这个国家好。当然，我也清楚地知道，恨不得这个国家立即从地球上消失的也大有人在，怎么说呢，求同存异吧，我认为对于普通人来说，只要过好手头的日子，做好自己的工作，爱护自己的家人朋友，就是最大的爱国。别的嘛，牢骚太盛防肠断，风物长宜放眼量。我相信未来会越来越好，从深渊回望，莫回头，莫回头。</p><h4 id="阅兵·游行·联欢"><a href="#阅兵·游行·联欢" class="headerlink" title="阅兵·游行·联欢"></a>阅兵·游行·联欢</h4><p>今年的国庆阅兵、群众游行、国庆联欢晚会三部曲都非常出乎我的意料，实在是太惊喜了，组织度这么高，组织能力这么强足以说明我国的体制在集中力量办大事这方面有着无与匹敌的优势，只要方向正确，中国人民总是能干出惊天动地的事业，这一点，从我中国人民解放军军史上就有许多明证。例如阅兵中给我印象最深刻的就是战旗方队，一百面英雄的旗帜，无数英勇的先烈们。其中有些部队本身可能出身于解放战争后期国民党方面的队伍，战斗力差，战斗意志弱，而起义、投诚、收编到了解放军中之后，仿佛脱胎换骨一般，这里面岂无值得深思的地方？</p><p>祝愿伟大祖国繁荣昌盛，期待建国一百周年，那时候的世界，又会是怎样一番天地呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;国庆·1949-2019&quot;&gt;&lt;a href=&quot;#国庆·1949-2019&quot; class=&quot;headerlink&quot; title=&quot;国庆·1949-2019&quot;&gt;&lt;/a&gt;国庆·1949-2019&lt;/h4&gt;&lt;p&gt;今年的国庆节似乎有些特别
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wqdchn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://wqdchn.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="时事" scheme="https://wqdchn.github.io/tags/%E6%97%B6%E4%BA%8B/"/>
    
      <category term="国庆" scheme="https://wqdchn.github.io/tags/%E5%9B%BD%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第236题Lowest Common Ancestor of a Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-tree.html</id>
    <published>2019-09-30T00:19:18.000Z</published>
    <updated>2020-03-31T23:53:11.479Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>给定一个二叉树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="Lowest Common Ancestor of a Binary Tree Example1"></p><blockquote><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.</p></blockquote><p>如何寻找最近公共祖先呢，我们可以通过遍历目标结点<code>q</code>和<code>p</code>的路径，得到其中重合的最近的部分，这很直接，比较好理解。这里我们使用递归的方式来遍历，从根节点开始分别遍历左右子树，如果目标结点仅存在于左子树内，那么最近公共节点必然位于左子树内，如果目标结点同时存在于左右子树内，那么最近公共节点必然是根节点。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root == null || root == p || root == q) return root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        return left == null ? right : right == null ? left : root;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q)        if root in {None, p, q}:            return root        left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        return root if (left and right) else (left or right)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第236题是中等题，利用二叉树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Lowest-Common-Ancestor-of-a-Binary-Tree&quot;&gt;&lt;a href=&quot;#Lowest-Common-Ancestor-of-a-Binary-Tree&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第242题Valid Anagram</title>
    <link href="https://wqdchn.github.io/leetcode-valid-anagram.html"/>
    <id>https://wqdchn.github.io/leetcode-valid-anagram.html</id>
    <published>2019-09-28T23:50:14.000Z</published>
    <updated>2020-03-31T23:49:33.091Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h4><p><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">Valid Anagram</a>给出两个字符串<code>s</code>和<code>t</code>，查看字符串<code>t</code>是否是字符串<code>s</code>的异位词。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: s = “anagram”, t = “nagaram”<br>Output: true</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: s = “rat”, t = “car”<br>Output: false</p></blockquote><p>这一题很简单，只需要用哈希的方法来解决，我们使用一个一维数组，数组的长度是26，里面我们存放26个字母的计数，如果字符<code>c</code>同时存在与字符串<code>s</code>与字符串<code>t</code>中，则该字符在数组中<code>+1</code>再<code>-1</code>记为零，只要数组中存在不为零的元素，则字符串<code>s</code>和字符串<code>t</code>不是有效的异位词。</p><p>还可以使用字符数组排序的方法，如果字符串<code>s</code>和字符串<code>t</code>是有效异位词，那么两者包含的字符在唯一性上是相等的，排序后的序列也必定相等。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) return false;        int[] counter = new int[26];        for (int i = 0; i &lt; s.length(); i++) {            counter[s.charAt(i) - &#39;a&#39;]++;            counter[t.charAt(i) - &#39;a&#39;]--;        }        for (int count : counter) {            if (count != 0) {                return false;            }        }        return true;    }    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) {            return false;        }        char[] str1 = s.toCharArray();        char[] str2 = t.toCharArray();        Arrays.sort(str1);        Arrays.sort(str2);        return Arrays.equals(str1, str2);    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        if len(s) != len(t): return False        count = collections.defaultdict(int)        for c in s:            count[c] += 1        for c in t:            count[c] -= 1            if count[c] &lt; 0:                return False        return True</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第242题是简单题，冲鸭！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Valid-Anagram&quot;&gt;&lt;a href=&quot;#Valid-Anagram&quot; class=&quot;headerlink&quot; title=&quot;Valid Anagram&quot;&gt;&lt;/a&gt;Valid Anagram&lt;/h4&gt;&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://wqdchn.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第239题Sliding Window Maximum</title>
    <link href="https://wqdchn.github.io/leetcode-sliding-window-maximum.html"/>
    <id>https://wqdchn.github.io/leetcode-sliding-window-maximum.html</id>
    <published>2019-09-28T00:02:09.000Z</published>
    <updated>2020-03-31T23:51:22.443Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Sliding-Window-Maximum"><a href="#Sliding-Window-Maximum" class="headerlink" title="Sliding Window Maximum"></a>Sliding Window Maximum</h4><p><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a>，给定一个数组<code>num</code>，一个大小为<code>k</code>的滑动窗口，该窗口从数组的最左边移到最右边，得出窗口内的最大值。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3<br>Output: [3,3,5,5,6,7]<br>Explanation: </p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">Max</th></tr></thead><tbody><tr><td style="text-align:center"><strong>[1</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>-1]</strong></td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>-1</strong></td><td style="text-align:center"><strong>-3]</strong></td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center"><strong>[-1</strong></td><td style="text-align:center"><strong>-3</strong></td><td style="text-align:center"><strong>5]</strong></td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center"><strong>[-3</strong></td><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>3]</strong></td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center"><strong>[5</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>6</strong>]</td><td style="text-align:center">7</td><td style="text-align:center"><strong>6</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>7]</strong></td><td style="text-align:center"><strong>7</strong></td></tr></tbody></table><p>这一题和<a href="https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html">Kth Largest Element in a Stream</a>寻找一个整数流中第<code>K</code>大的元素非常相似，也可以使用队列来完成。这里使用一个双端队列<code>Deque</code>，队列中存放当前窗口最大值的数组下标，每当滑动窗口的时候，就记录一次结果。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || k &lt;= 0) return new int[0];        int[] res = new int[nums.length - k + 1];//保存结果        ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;();//双端队列        int index = 0;        for (int i = 0; i &lt; nums.length; i++){            while (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){//越界                deque.poll();            }            while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]){                deque.pollLast();//从右向左剔除，确保最左是当前窗口最大值            }            deque.offer(i);//存放的是位置索引            if (i &gt;= k - 1){                res[index++] = nums[deque.peek()];            }        }        return res;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:            if not nums: return []        window , res = [], []        for i, x in enumerate(nums):            if i &gt;= k and window[0] &lt;= i - k:                window.pop(0)            while window and nums[window[-1]] &lt;= x:                window.pop()            window.append(i)            if i &gt;= k -1:                res.append(nums[window[0]])        return res</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第239题是难题，但是使用合适的数据结构和对应的逻辑，就能很好的完成，自带API真香。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Sliding-Window-Maximum&quot;&gt;&lt;a href=&quot;#Sliding-Window-Maximum&quot; class=&quot;headerlink&quot; title=&quot;Sliding Window Maximum&quot;&gt;&lt;/a&gt;Sl
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="队列" scheme="https://wqdchn.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="优先队列" scheme="https://wqdchn.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第703题Kth Largest Element in a Stream</title>
    <link href="https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html"/>
    <id>https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html</id>
    <published>2019-09-27T10:26:48.000Z</published>
    <updated>2020-03-31T23:53:44.127Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Kth-Largest-Element-in-a-Stream"><a href="#Kth-Largest-Element-in-a-Stream" class="headerlink" title="Kth Largest Element in a Stream"></a>Kth Largest Element in a Stream</h4><p><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">Kth Largest Element in a Stream</a>寻找一个整数流中第<code>K</code>大的元素，<code>K</code>是固定的，整数流包含一个构造函数<code>add</code>，每次往流中添加新元素时，就返回新的第<code>K</code>大的元素。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8</p></blockquote><p>这道题可以使用优先队列<code>PriorityQueue</code>来做，在<code>Java</code>中优先队列默认通过二叉小顶堆实现。我们可以令这个优先队列的长度为<code>K</code>，这个队列的头部就是整数流中第<code>K</code>大的元素，每当新的元素进来时，我们就把新的元素和队列头部元素（也就是堆顶）进行比较，如果新的元素比较大，则纳入新的元素。优先队列会自动维护小顶堆的性质，保证队列头部元素始终是我们需要的第<code>K</code>大的元素。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class KthLargest {       PriorityQueue&lt;Integer&gt; q;    int k;    public KthLargest(int k, int[] nums) {        this.k = k;        q = new PriorityQueue&lt;&gt;(k);        for (int n : nums){            add(n);        }           }    public int add(int val) {        if (q.size() &lt; k){            q.offer(val);        }else if (q.peek() &lt; val){            q.poll();            q.offer(val);        }        return q.peek();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class KthLargest:    def __init__(self, k, nums):        self.pool = nums        self.k = k        heapq.heapify(self.pool)        while len(self.pool) &gt; k:            heapq.heappop(self.pool)    def add(self, val):        if len(self.pool) &lt; self.k:            heapq.heappush(self.pool, val)        elif val &gt; self.pool[0]:            heapq.heapreplace(self.pool, val)        return self.pool[0]</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第703题是简单题，学会利用已有的数据结构，加一点简单的逻辑，能做很多神奇的事，再也不要暴力循环了鸭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Kth-Largest-Element-in-a-Stream&quot;&gt;&lt;a href=&quot;#Kth-Largest-Element-in-a-Stream&quot; class=&quot;headerlink&quot; title=&quot;Kth Largest 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="队列" scheme="https://wqdchn.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="优先队列" scheme="https://wqdchn.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第225题Implement Stack using Queues</title>
    <link href="https://wqdchn.github.io/leetcode-implement-stack-using-queues.html"/>
    <id>https://wqdchn.github.io/leetcode-implement-stack-using-queues.html</id>
    <published>2019-09-26T01:44:11.000Z</published>
    <updated>2020-03-31T23:53:59.640Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Implement-Stack-using-Queens"><a href="#Implement-Stack-using-Queens" class="headerlink" title="Implement Stack using Queens"></a>Implement Stack using Queens</h4><p><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">Implement Stack using Queens</a>用队列实现栈。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>MyStack stack = new MyStack();<br>stack.push(1);<br>stack.push(2);<br>stack.top();   // returns 2<br>stack.pop();   // returns 2<br>stack.empty(); // returns false</p></blockquote><p>栈的特性是先进后出，队列的特性是先进先出，我们要实现栈的三个操作，分别是<code>push</code>、<code>pop</code>、<code>top</code>，还有一个栈状态检查<code>empty</code>。类似用栈实现队列时，使用两个栈互相倒腾，这里用队列实现栈也可以使用两个队列来实现栈，燃鹅本文选择使用一个队列来实现栈，非炫技也，实有趣耳。</p><p>使用一个队列时，<code>push</code>操作很平常，就把元素压入队列中即可，即压入栈中。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table><p>执行<code>pop</code>操作时，由于栈是先进后出的，先前<code>push</code>入队的队列头部元素应该在栈底，而队列尾部元素是栈顶。也就是说，我们要<code>pop</code>的是队列尾部元素，那么怎么将尾部元素<code>pop</code>出去呢？</p><p>很简单，我们让除了队列末尾元素之外的其他队列元素出队，那原来的队尾元素不就变成新的队首元素了吗，让这个新的队首元素出队就是栈的<code>pop</code>操作，而出队的其他元素则再依次入队，保证栈<code>pop</code>之后其他元素没有丢失。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><p>执行<code>top</code>操作时和<code>pop</code>类似，只不过我们返回队首元素即可，注意，由于这个队首元素是原来的队尾元素，所以我们在使用过它之后，要让它出队再入队，保证它依然处于队尾，也就是栈顶。</p><p>状态检查只需查看队列是否为空即可。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        q.offer(x);    }    /** Removes the element on top of the stack and returns that element. */    public int pop() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        return q.poll();    }    /** Get the top element. */    public int top() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        int top = q.peek();        q.offer(q.poll());        return top;    }    /** Returns whether the stack is empty. */    public boolean empty() {        return q.isEmpty();    }}</code></pre><p>下面是相似的<code>Java</code>代码，请关注两者的区别：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        queue.add(x);        for (int i=1; i&lt;queue.size(); i++)            queue.add(queue.remove());    }    /** Removes the element on top of the stack and returns that element. */    public void pop() {        queue.remove();    }    /** Get the top element. */    public int top() {        return queue.peek();    }    /** Returns whether the stack is empty. */    public boolean empty() {        return queue.isEmpty();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class MyStack:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.queue = []    def push(self, x: int) -&gt; None:        &quot;&quot;&quot;        Push element x onto stack.        &quot;&quot;&quot;        self.queue.append(x)    def pop(self) -&gt; int:        &quot;&quot;&quot;        Removes the element on top of the stack and returns that element.        &quot;&quot;&quot;        return self.queue.pop()    def top(self) -&gt; int:        &quot;&quot;&quot;        Get the top element.        &quot;&quot;&quot;        return self.queue[-1]    def empty(self) -&gt; bool:        &quot;&quot;&quot;        Returns whether the stack is empty.        &quot;&quot;&quot;        return self.queue == []</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第225题是简单题，用一个队列实现栈其实也不难，关键依然是理解先进先出和先进后出之间的关联。这里<code>Python</code>的逻辑和分析中有所区别，主要是<code>Python</code>的内置函数太强大了，完全不需要多余的操作。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Implement-Stack-using-Queens&quot;&gt;&lt;a href=&quot;#Implement-Stack-using-Queens&quot; class=&quot;headerlink&quot; title=&quot;Implement Stack us
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="栈" scheme="https://wqdchn.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://wqdchn.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
