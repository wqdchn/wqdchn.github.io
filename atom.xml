<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenQian Dong&#39;s Web</title>
  
  <subtitle>Coder,Java,Linux,Google Fans</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wqdchn.github.io/"/>
  <updated>2019-11-29T10:16:14.895Z</updated>
  <id>https://wqdchn.github.io/</id>
  
  <author>
    <name>WenQian Dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode第322题Coin Change</title>
    <link href="https://wqdchn.github.io/leetcode-coin-change.html"/>
    <id>https://wqdchn.github.io/leetcode-coin-change.html</id>
    <published>2019-11-29T09:36:35.000Z</published>
    <updated>2019-11-29T10:16:14.895Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h4><p><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Coin Change</a>给出不同币值的硬币和一个目标金额，求组成目标金额所需最少的硬币数量，注意，这里可供取用的硬币数据量是不限制的，如果没有可用的硬币，则返回-1即可。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: coins = [2], amount = 3<br>Output: -1</p></blockquote><p>这一题使用暴力法会超时，因此需要改换策略，实际上就是要求使用动态规划来完成。动态规划最头痛的就是递推方程，要了解每一次方程的状态是如何转移的，简直让我选择放弃，好在这一题是找零钱，仿佛小学生奥数似的，稍有些趣味性，不妨挑战一下。</p><p>以示例一为例，我们现在有1，2，5三种币值的硬币，且任意取用。当我们需要11块钱的时候，我们可以选择摸11个一块钱，也可以选择摸5个两块钱和1个一块钱，当然，最少的是摸2个五块钱和1个一块钱。那么这里就存在一种规律了，比如说我们恰好摸了2个五块钱和1个一块钱，完成了任务，可是这个过程中，我们是摸了2个五块钱和1个一块钱的<del>这不是废话嘛！！！</del>注意了，这个2个五块钱和1个一块钱可不简单，它们分别是十块钱和一块钱<del>这又是什么废话啊！！！</del><br>嗯，到这里暗示已经结束，该明示了。就是说，组合11块钱的任务是由组合10块钱和组合1块钱来完成的，而两个组合也恰好是最少的，不仅是组合成11块钱是最少的，他们本身组合成10块钱和组合成1块钱也是最少的。因此，我们的动态规划递推方程中，当前的组合金额<code>(11)</code>还有币值<code>(1,2,5)</code>与之前的组合金额<code>(10,1)</code>是有关联的，我们最终会推到<code>0</code>，也就是什么都不做。</p><p>简单的数学公式是这样的：<br><code>F(11) = min(F(11-1),F(11-2),F(11-5)) + 1</code><br><code>F(11) = min(F(10),F(9),F(6)) + 1</code><br>然后呢我们分别再求<code>F(10)</code>、<code>F(9)</code>、<code>F(6)</code>….</p><p>这个<code>F</code>函数就是我们要实现的摸硬币操作。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><p>注意：外层循环表示可用的硬币组合，内层循环则表示在当前可用的硬币组合下，完成目标金额数所需要的硬币数量。</p><pre><code class="Java">class Solution {  public static int coinChange(int[] coins, int amount) {    if (amount == 0) {      return 0;    }    int[] dp = new int[amount + 1];    Arrays.fill(dp, amount + 1);    dp[0] = 0;    for (int coin : coins) {      for (int i = coin; i &lt; amount + 1; i++) {        dp[i] = Math.min(dp[i], dp[i - coin] + 1);      }    }    return dp[amount] != amount + 1 ? dp[amount] : -1;  }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def coinChange(self, coins, amount):        dp = [0] + [float(&#39;inf&#39;)] * amount        for coin in coins:            for i in range(coin, amount + 1):                dp[i] = min(dp[i], dp[i - coin] + 1)        return dp[-1] if dp[-1] != float(&#39;inf&#39;) else -1 </code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第322题是中等题，除了找零钱有些趣味，动态规划实在打扰了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Coin-Change&quot;&gt;&lt;a href=&quot;#Coin-Change&quot; class=&quot;headerlink&quot; title=&quot;Coin Change&quot;&gt;&lt;/a&gt;Coin Change&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="动态规划" scheme="https://wqdchn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>空间数据分析（一）空间数据分析与空间数据类型</title>
    <link href="https://wqdchn.github.io/r-spatial-demo1.html"/>
    <id>https://wqdchn.github.io/r-spatial-demo1.html</id>
    <published>2019-11-08T11:33:49.000Z</published>
    <updated>2019-11-08T12:03:02.171Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="什么是空间数据分析？"><a href="#什么是空间数据分析？" class="headerlink" title="什么是空间数据分析？"></a>什么是空间数据分析？</h4><p>空间数据是对现实世界中带有空间属性的事物和现象的时空特征及过程的抽象表达和定量描述。而空间数据分析就是寻找空间数据中隐含的信息的一系列方法。简单来说就是我们希望从空间数据中挖掘出空间隐含的价值。</p><h4 id="空间数据的类型"><a href="#空间数据的类型" class="headerlink" title="空间数据的类型"></a>空间数据的类型</h4><p>空间数据的类型可以大致分为三种：</p><ul><li>lattice data/栅格数据，例如某个省的手足口病发病率数据，某个省的GDP数据。</li><li>geostatistical data/地统计数据，例如某个省水文站的降雨数据，某个省环境监测站的空气质量数据。</li><li>point pattern data/点模式数据，例如某个森林内某种树木的位置数据，某个区域内共享单车的位置数据。</li></ul><p>这三种空间数据类型不是绝对的，它们可以根据需要互相转换。例如某个区域内共享单车的位置数据属于点模式数据，但是经过汇总统计，可以将其转换为栅格数据。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>下面给出一些空间数据的例子，以帮助理解。</p><h5 id="栅格数据"><a href="#栅格数据" class="headerlink" title="栅格数据"></a>栅格数据</h5><p>首先加载一个R包，里面带了一份可以作为示例的栅格数据：</p><pre><code class="r">library(DClusterm)data(NY8)</code></pre><p>然后我们查看这个数据的摘要信息，此处省略了输出内容中的无关字段：</p><pre><code class="r">summary(NY8)</code></pre><pre><code>## Object of class SpatialPolygonsDataFrame## Coordinates:##          min       max## r1  358241.9  480393.1## r2 4649755.4 4808545.2## Is projected: TRUE ## proj4string :## [+proj=utm +zone=18 +ellps=WGS84 +units=m +no_defs]## Data attributes:##                   AREANAME          AREAKEY          X          ##  NA                   : 83   36007000100:  1   Min.   :-55.482  ##  Syracuse city        : 63   36007000200:  1   1st Qu.:-19.460  ##  Binghamton city      : 18   36007000300:  1   Median :-12.469  ##  Remainder of Clay tow:  6   36007000400:  1   Mean   :-11.309  ##  Johnson City village :  5   36007000500:  1   3rd Qu.: -1.213  ##  Onondaga town        :  5   36007000600:  1   Max.   : 53.509  ##  (Other)              :101   (Other)    :275                    ##        Y               POP8            Cases    ##  Min.   :-75.29   Min.   :    9   Min.   :0.00014 ##  1st Qu.:-30.60   1st Qu.: 2510   1st Qu.:0.30928 ##  Median : 31.97   Median : 3433   Median :1.88876##  Mean   :  4.98   Mean   : 3764   Mean   :2.10676##  3rd Qu.: 39.12   3rd Qu.: 4889   3rd Qu.:3.08284##  Max.   : 56.41   Max.   :13015   Max.   :9.28601               </code></pre><p>我们用病例数除以总人口数得到发病率，再用发病率乘以人口数得到预期值，最后用病例数除以预期值得到标准发病率，进行疾病制图：</p><pre><code class="r">rate &lt;- sum(NY8$Cases) / sum(NY8$POP8)NY8$Expected &lt;- NY8$POP8 * rateNY8$SMR &lt;- NY8$Cases / NY8$Expectedsyracuse &lt;- which(NY8$AREANAME == &quot;Syracuse city&quot;)</code></pre><p>为简便起见，我们使用<code>spplot</code>函数进行疾病制图的绘制：</p><pre><code class="r">library(viridis)spplot(NY8[syracuse, ], &quot;SMR&quot;, #at = c(0.6, 0.9801, 1.055, 1.087, 1.125, 13),   col.regions = rev(magma(16))) #gray.colors(16, 0.9, 0.4))</code></pre><p><img src="img/r-spatial-demo1_files/figure-gfm/NY8-SMRplot-1.png" alt=""><!-- --></p><h5 id="地统计数据"><a href="#地统计数据" class="headerlink" title="地统计数据"></a>地统计数据</h5><p>地统计数据是指定点监测或提取的数据，例如降雨数据，我们不可能把地球上每一寸地方的降雨量都测算出来，所以通常是设定一个监测站收集降雨数据，然后利用空间插值等方法得到某个区域的降雨情况。</p><p>同样的，我们加载一个包含示例数据的R包，获取示例数据。</p><pre><code class="r">library(INLA)data(PRprec)dim(PRprec)</code></pre><pre><code>## [1] 616 368</code></pre><p>示例数据是巴西某个州的降雨数据，来自616个监测站点，一共365天的降雨量数据，前三列分别是经纬度和海拔，之后是天数的标记，每一列代表每一天。</p><pre><code class="r">PRprec$precMean &lt;- rowMeans(PRprec[, 3 + 1:31], na.rm = TRUE)plot(PRborder, type = &quot;l&quot;, asp = 1, axes = FALSE, main = paste(&quot;Mean of daily accumulated precipitation (mm)&quot;))points(PRprec[1:2], cex = 0.3 + PRprec$precMean / 20)legend(&quot;topright&quot;, format(seq(1, 21, 5)), bty = &quot;n&quot;, pch = 1, pt.cex = 0.3 + seq(1, 21, 5) / 20)lines(PRborder[1034:1078, ], col = &quot;cyan&quot;)</code></pre><p><img src="img/r-spatial-demo1_files/figure-gfm/PRprec-plot-1.png" alt=""><!-- --></p><p>蓝色线段表示海岸线，从图中可见，离海岸近的地方降雨更加充沛一些。</p><h5 id="点模式数据"><a href="#点模式数据" class="headerlink" title="点模式数据"></a>点模式数据</h5><p>和定点监测的地统计数据不同，点模式数据是指空间位置随机的事物或现象,它们呈现出的模式主要有三种：</p><ul><li>随机模式，没有规律可循</li><li>聚集模式，局部的密度远高于总体水平</li><li>规则模式，错落有致，规则分布</li></ul><p>具有代表性的示例数据如下：</p><pre><code class="r">library(spatstat.data)plot(japanesepines)</code></pre><p><img src="img/r-spatial-demo1_files/figure-gfm/point-pattern-1.png" alt=""><!-- --></p><pre><code class="r">plot(redwood)</code></pre><p><img src="img/r-spatial-demo1_files/figure-gfm/point-pattern-2.png" alt=""><!-- --></p><pre><code class="r">plot(cells)</code></pre><p><img src="img/r-spatial-demo1_files/figure-gfm/point-pattern-3.png" alt=""><!-- --></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>空间数据分析的起点就是了解空间数据，包括它的类型，它的属性等等。为了后续的建模分析，起始阶段简单的探索性分析也是必不可少的，而空间数据的特性对可视化有更加强烈的要求，不进行可视化几乎很难捕捉到空间数据的微妙之处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;什么是空间数据分析？&quot;&gt;&lt;a href=&quot;#什么是空间数据分析？&quot; class=&quot;headerlink&quot; title=&quot;什么是空间数据分析？&quot;&gt;&lt;/a&gt;什么是空间数据分析？&lt;/h4&gt;&lt;p&gt;空间数据是对现实世界中带有空间属性的事物
      
    
    </summary>
    
      <category term="数据分析" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="R语言" scheme="https://wqdchn.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
      <category term="空间数据分析" scheme="https://wqdchn.github.io/tags/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="栅格数据" scheme="https://wqdchn.github.io/tags/%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE/"/>
    
      <category term="地统计数据" scheme="https://wqdchn.github.io/tags/%E5%9C%B0%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE/"/>
    
      <category term="点模式数据" scheme="https://wqdchn.github.io/tags/%E7%82%B9%E6%A8%A1%E5%BC%8F%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>R语言ggplot2绘图转PDF中文乱码问题</title>
    <link href="https://wqdchn.github.io/r-ggplot2-to-pdf-with-chinese.html"/>
    <id>https://wqdchn.github.io/r-ggplot2-to-pdf-with-chinese.html</id>
    <published>2019-10-20T12:53:49.000Z</published>
    <updated>2019-11-06T06:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="ggplot2与中文乱码的Solution"><a href="#ggplot2与中文乱码的Solution" class="headerlink" title="ggplot2与中文乱码的Solution"></a>ggplot2与中文乱码的Solution</h4><h5 id="字体文件"><a href="#字体文件" class="headerlink" title="字体文件"></a>字体文件</h5><p>首先假设你有一个<code>Windows</code>系统，其次进行R语言编程所使用的<code>IDE</code>是<code>RStudio</code><del>非常好用的集成开发环境</del>。</p><p>然后在<code>Windows</code>系统中找到中文字体，比如宋体或黑体，再找到一个英文字体，比如<code>Times New Roman</code>。它们大概在<code>C盘</code>的<code>Windows/Fonts</code>路径下。</p><p>找出所需的字体文件，比如宋体的字体文件是<code>simsun.ttc</code>，黑体的字体文件是<code>simhei.ttf</code>，<code>Times New Roman</code>的字体文件是<code>times.ttf</code>。</p><p>找到字体文件就是成功的一半了，然后我把它们随便放到一个地方准备加载。</p><h5 id="showtext包"><a href="#showtext包" class="headerlink" title="showtext包"></a>showtext包</h5><p>然后需要在<code>R</code>中调用<code>showtext</code>包，如果没有这个包，请安装它。</p><pre><code class="R"># 调用showtext包library(showtext)showtext_auto(enable = TRUE)# 载入黑体font_add(&quot;heiti&quot;, regular = &quot;F:\\font\\simhei.ttf&quot;)# 载入宋体font_add(&quot;songti&quot;, regular = &quot;F:\\font\\simsun.ttc&quot;)# 载入Times New Roman字体font_add(&quot;newrom&quot;, regular = &quot;F:\\font\\times.ttf&quot;)</code></pre><p>在上面，我们载入了三种字体，并重命名<del>请随意命名</del>后供<code>ggplot2</code>调用。</p><p>注意载入的路径，在<code>Windows</code>下好像要使用反斜杠。</p><p>注意，使用字体的过程中，可能会出现提示没有这种字体！！！！！！无妨，重新执行一下上面的命令可以解决。</p><h5 id="ggplot2绘图带中文"><a href="#ggplot2绘图带中文" class="headerlink" title="ggplot2绘图带中文"></a>ggplot2绘图带中文</h5><pre><code class="R">p &lt;- ggplot() + geom_point() + ... +        theme(axis.title.x = element_text(family=&quot;newrom&quot;), axis.title.y = element_text(family = &quot;songti&quot;)) +        xlab(&quot;Hello World&quot;) +         ylab(&quot;你好世界&quot;)</code></pre><p>在上面的命令中，我们把<code>X</code>轴的字体指定为<code>Times New Roman</code>，<code>Y</code>轴的字体指定为宋体。</p><h5 id="转换为PDF"><a href="#转换为PDF" class="headerlink" title="转换为PDF"></a>转换为PDF</h5><pre><code class="R">p &lt;- ggplot() + geom_point() + ... +        theme(axis.title.x = element_text(family=&quot;newrom&quot;), axis.title.y = element_text(family = &quot;songti&quot;)) +        xlab(&quot;Hello World&quot;) +         ylab(&quot;你好世界&quot;)ggsave(&quot;Fig_p.pdf&quot;, plot = p)</code></pre><p>在上面的命令中，我们把<code>p</code>转换为了<code>PDF</code>。再次提醒，这个过程中，可能会出现提示没有这种字体！！！！！！无妨，重新执行一下上面的字体加载命令即可解决。</p><p>然后我们查看一下生成的<code>PDF</code>，应该会得到一个<code>X</code>轴字体是<code>Times New Roman</code>的英文<code>Hello World</code>，<code>Y</code>轴字体是宋体的中文你好世界。</p><p>如果你使用<code>RStudio</code>的图片预览功能，并且尝试<code>Save as PDF</code>，那么可能依然会出现中文乱码问题。</p><p>去试试看吧！</p><h4 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h4><p>上面的内容只能解决文字中不包含中英文混合的情况。如果需要中英文混合，那么可能需要把某两种中英文字体文件合并生成新的字体文件，然后加载进来才行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;ggplot2与中文乱码的Solution&quot;&gt;&lt;a href=&quot;#ggplot2与中文乱码的Solution&quot; class=&quot;headerlink&quot; title=&quot;ggplot2与中文乱码的Solution&quot;&gt;&lt;/a&gt;ggplo
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="R语言" scheme="https://wqdchn.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
      <category term="ggplot2" scheme="https://wqdchn.github.io/tags/ggplot2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第104题Maximum Depth of Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-maximum-depth-of-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-maximum-depth-of-binary-tree.html</id>
    <published>2019-10-11T07:12:39.000Z</published>
    <updated>2019-11-08T11:56:12.026Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h4><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a>求二叉树的最大深度。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5]<br>Output: 4</p></blockquote><p>二叉树的深度可以通过深度优先搜索和广度优先搜索两种方式来遍历，并记录树的层次。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    // dfs    public int maxDepth(TreeNode root) {        return root == null ? 0 : 1 + Math.max(maxDepth(root.left),maxDepth(root.right));    }    // bfs    public int maxDepth(TreeNode root) {        if (root == null) return 0;        Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);        int depth = 0;        while (!q.isEmpty()){            int size = q.size();            while (size-- &gt; 0){                TreeNode node = q.poll();                if (node.left != null){                    q.offer(node.left);                }                if (node.right != null){                    q.offer(node.right);                }            }            depth++;        }        return depth;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # dfs    def maxDepth(self, root: TreeNode) -&gt; int:        if not root: return 0        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))    # bfs    def maxDepth(self, root):        if not root: return 0        q = collections.deque([(root, 1)])        while q:            curr, depth = q.popleft()            if not curr.left and not curr.right and not q:                return depth            if curr.left:                q.append((curr.left, depth + 1))            if curr.right:                q.append((curr.right, depth + 1))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第104题是简单题，只需熟悉二叉树的深度优先搜索与广度优先搜索，并记录对应的层次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Maximum-Depth-of-Binary-Tree&quot;&gt;&lt;a href=&quot;#Maximum-Depth-of-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Maximum Depth of B
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="深度优先搜索" scheme="https://wqdchn.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="广度优先搜索" scheme="https://wqdchn.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第111题Minimum Depth of Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-minimum-depth-of-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-minimum-depth-of-binary-tree.html</id>
    <published>2019-10-10T05:14:13.000Z</published>
    <updated>2019-11-08T11:56:15.369Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h4><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a>求二叉树的最小深度。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5]<br>Output: 3</p></blockquote><p>二叉树的深度可以通过深度优先搜索和广度优先搜索两种方式来遍历，并记录树的层次。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    // dfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        int left = minDepth(root.left);        int right = minDepth(root.right);        return (left == 0 || right ==0) ? left + right + 1 : Math.min(left, right) + 1;    }    // bfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);        int depth = 1;        while (!q.isEmpty()){            int size = q.size();            while (size-- &gt; 0){                TreeNode node = q.poll();                if (node.left == null &amp;&amp; node.right == null){                   return depth;                }                if (node.left != null){                    q.offer(node.left);                }                if (node.right != null){                    q.offer(node.right);                }            }            depth++;        }        return depth;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # dfs    def minDepth(self, root: TreeNode):        if not root:            return 0        if not root.left and not root.right:            return 1        if root.left and not root.right:            return 1 + self.minDepth(root.left)        if root.right and not root.left:            return 1 + self.minDepth(root.right)        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))    # bfs    def minDepth(self, root):        if not root: return 0        q = collections.deque([(root, 1)])        while q:            curr, depth = q.popleft()            if not curr.left and not curr.right:                return depth            if curr.left:                q.append((curr.left, depth + 1))            if curr.right:                q.append((curr.right, depth + 1))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第111题是简单题，只需熟悉二叉树的深度优先搜索与广度优先搜索，并记录对应的层次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Minimum-Depth-of-Binary-Tree&quot;&gt;&lt;a href=&quot;#Minimum-Depth-of-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Minimum Depth of B
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="深度优先搜索" scheme="https://wqdchn.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="广度优先搜索" scheme="https://wqdchn.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第235题Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html</id>
    <published>2019-10-09T02:23:53.000Z</published>
    <updated>2019-11-08T11:56:04.091Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Search Tree</a>给定一个二叉<strong>搜索</strong>树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p></blockquote><p>这一题和236题<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>有些相似，二叉搜索树是二叉树的一种，所以236题的解法也适用于这题。特别的是，二叉搜索树中根节点的值大于左子树的节点值，小于右子树的节点值，这是可以利用的一个性质：</p><ul><li>我们记<code>LCA(2,8) = 6</code>，此时节点<code>p</code>和<code>q</code>是2和8，我们将节点值与根节点值6进行比较，发现<code>p</code>和<code>q</code>分别位于根节点左右两侧，此时根节点6是最近祖先。</li><li>我们记<code>LCA(7,9) = 8</code>，此时节点<code>p</code>和<code>q</code>是7和9，我们将节点值与根节点值6进行比较，发现<code>p</code>和<code>q</code>都大于根节点，都位于右子树，于是，我们进入右子树进行遍历，此时原来右子树的根节点8成为新的根节点，继续遍历比较。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        int parentVal = root.val;        int pVal = p.val;        int qVal = q.val;        if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {            return lowestCommonAncestor(root.right, p, q);        } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {            return lowestCommonAncestor(root.left, p, q);        } else {            return root;        }    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q):        if p.val &lt; root.val &gt; q.val:            return self.lowestCommonAncestor(root.left, p, q)        if p.val &gt; root.val &lt; q.val:            return  self.lowestCommonAncestor(root.right, p, q)        return  root</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第235题是简单题，利用二叉<strong>搜索</strong>树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Lowest-Common-Ancestor-of-a-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#Lowest-Common-Ancestor-of-a-Binary-Search-Tree&quot; class=&quot;h
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2019年国庆节</title>
    <link href="https://wqdchn.github.io/national-day-of-the-people-s-republic-of-china.html"/>
    <id>https://wqdchn.github.io/national-day-of-the-people-s-republic-of-china.html</id>
    <published>2019-10-04T12:24:51.000Z</published>
    <updated>2019-10-05T02:33:47.570Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="国庆·1949-2019"><a href="#国庆·1949-2019" class="headerlink" title="国庆·1949-2019"></a>国庆·1949-2019</h4><p>今年的国庆节似乎有些特别，从大面上来说，我感受到非常高涨的热情，无论是朋友圈还是微博，也许是这一年发生太多以往没有发生的事，让普通群众们了解到了周边生活之外的零零碎碎，激发起了内心朴素的那一份感情：希望这个国家好。当然，我也清楚地知道，恨不得这个国家立即从地球上消失的也大有人在，怎么说呢，求同存异吧，我认为对于普通人来说，只要过好手头的日子，做好自己的工作，爱护自己的家人朋友，就是最大的爱国。别的嘛，牢骚太盛防肠断，风物长宜放眼量。我相信未来会越来越好，从深渊回望，莫回头，莫回头。</p><h4 id="阅兵·游行·联欢"><a href="#阅兵·游行·联欢" class="headerlink" title="阅兵·游行·联欢"></a>阅兵·游行·联欢</h4><p>今年的国庆阅兵、群众游行、国庆联欢晚会三部曲都非常出乎我的意料，实在是太惊喜了，组织度这么高，组织能力这么强足以说明我国的体制在集中力量办大事这方面有着无与匹敌的优势，只要方向正确，中国人民总是能干出惊天动地的事业，这一点，从我中国人民解放军军史上就有许多明证。例如阅兵中给我印象最深刻的就是战旗方队，一百面英雄的旗帜，无数英勇的先烈们。其中有些部队本身可能出身于解放战争后期国民党方面的队伍，战斗力差，战斗意志弱，而起义、投诚、收编到了解放军中之后，仿佛脱胎换骨一般，这里面岂无值得深思的地方？</p><p>祝愿伟大祖国繁荣昌盛，期待建国一百周年，那时候的世界，又会是怎样一番天地呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;国庆·1949-2019&quot;&gt;&lt;a href=&quot;#国庆·1949-2019&quot; class=&quot;headerlink&quot; title=&quot;国庆·1949-2019&quot;&gt;&lt;/a&gt;国庆·1949-2019&lt;/h4&gt;&lt;p&gt;今年的国庆节似乎有些特别
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wqdchn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://wqdchn.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="时事" scheme="https://wqdchn.github.io/tags/%E6%97%B6%E4%BA%8B/"/>
    
      <category term="国庆" scheme="https://wqdchn.github.io/tags/%E5%9B%BD%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第236题Lowest Common Ancestor of a Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-tree.html</id>
    <published>2019-09-30T00:19:18.000Z</published>
    <updated>2019-11-08T11:56:07.542Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>给定一个二叉树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="Lowest Common Ancestor of a Binary Tree Example1"></p><blockquote><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.</p></blockquote><p>如何寻找最近公共祖先呢，我们可以通过遍历目标结点<code>q</code>和<code>p</code>的路径，得到其中重合的最近的部分，这很直接，比较好理解。这里我们使用递归的方式来遍历，从根节点开始分别遍历左右子树，如果目标结点仅存在于左子树内，那么最近公共节点必然位于左子树内，如果目标结点同时存在于左右子树内，那么最近公共节点必然是根节点。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root == null || root == p || root == q) return root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        return left == null ? right : right == null ? left : root;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q)        if root in {None, p, q}:            return root        left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        return root if (left and right) else (left or right)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第236题是中等题，利用二叉树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Lowest-Common-Ancestor-of-a-Binary-Tree&quot;&gt;&lt;a href=&quot;#Lowest-Common-Ancestor-of-a-Binary-Tree&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第242题Valid Anagram</title>
    <link href="https://wqdchn.github.io/leetcode-valid-anagram.html"/>
    <id>https://wqdchn.github.io/leetcode-valid-anagram.html</id>
    <published>2019-09-28T23:50:14.000Z</published>
    <updated>2019-11-08T11:56:41.149Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h4><p><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">Valid Anagram</a>给出两个字符串<code>s</code>和<code>t</code>，查看字符串<code>t</code>是否是字符串<code>s</code>的异位词。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: s = “anagram”, t = “nagaram”<br>Output: true</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: s = “rat”, t = “car”<br>Output: false</p></blockquote><p>这一题很简单，只需要用哈希的方法来解决，我们使用一个一维数组，数组的长度是26，里面我们存放26个字母的计数，如果字符<code>c</code>同时存在与字符串<code>s</code>与字符串<code>t</code>中，则该字符在数组中<code>+1</code>再<code>-1</code>记为零，只要数组中存在不为零的元素，则字符串<code>s</code>和字符串<code>t</code>不是有效的异位词。</p><p>还可以使用字符数组排序的方法，如果字符串<code>s</code>和字符串<code>t</code>是有效异位词，那么两者包含的字符在唯一性上是相等的，排序后的序列也必定相等。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) return false;        int[] counter = new int[26];        for (int i = 0; i &lt; s.length(); i++) {            counter[s.charAt(i) - &#39;a&#39;]++;            counter[t.charAt(i) - &#39;a&#39;]--;        }        for (int count : counter) {            if (count != 0) {                return false;            }        }        return true;    }    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) {            return false;        }        char[] str1 = s.toCharArray();        char[] str2 = t.toCharArray();        Arrays.sort(str1);        Arrays.sort(str2);        return Arrays.equals(str1, str2);    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        if len(s) != len(t): return False        count = collections.defaultdict(int)        for c in s:            count[c] += 1        for c in t:            count[c] -= 1            if count[c] &lt; 0:                return False        return True</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第242题是简单题，冲鸭！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Valid-Anagram&quot;&gt;&lt;a href=&quot;#Valid-Anagram&quot; class=&quot;headerlink&quot; title=&quot;Valid Anagram&quot;&gt;&lt;/a&gt;Valid Anagram&lt;/h4&gt;&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="哈希表" scheme="https://wqdchn.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第239题Sliding Window Maximum</title>
    <link href="https://wqdchn.github.io/leetcode-sliding-window-maximum.html"/>
    <id>https://wqdchn.github.io/leetcode-sliding-window-maximum.html</id>
    <published>2019-09-28T00:02:09.000Z</published>
    <updated>2019-11-08T11:56:26.492Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Sliding-Window-Maximum"><a href="#Sliding-Window-Maximum" class="headerlink" title="Sliding Window Maximum"></a>Sliding Window Maximum</h4><p><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a>，给定一个数组<code>num</code>，一个大小为<code>k</code>的滑动窗口，该窗口从数组的最左边移到最右边，得出窗口内的最大值。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3<br>Output: [3,3,5,5,6,7]<br>Explanation: </p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">Max</th></tr></thead><tbody><tr><td style="text-align:center"><strong>[1</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>-1]</strong></td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>-1</strong></td><td style="text-align:center"><strong>-3]</strong></td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center"><strong>[-1</strong></td><td style="text-align:center"><strong>-3</strong></td><td style="text-align:center"><strong>5]</strong></td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center"><strong>[-3</strong></td><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>3]</strong></td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center"><strong>[5</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>6</strong>]</td><td style="text-align:center">7</td><td style="text-align:center"><strong>6</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>7]</strong></td><td style="text-align:center"><strong>7</strong></td></tr></tbody></table><p>这一题和<a href="https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html">Kth Largest Element in a Stream</a>寻找一个整数流中第<code>K</code>大的元素非常相似，也可以使用队列来完成。这里使用一个双端队列<code>Deque</code>，队列中存放当前窗口最大值的数组下标，每当滑动窗口的时候，就记录一次结果。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || k &lt;= 0) return new int[0];        int[] res = new int[nums.length - k + 1];//保存结果        ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;();//双端队列        int index = 0;        for (int i = 0; i &lt; nums.length; i++){            while (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){//越界                deque.poll();            }            while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]){                deque.pollLast();//从右向左剔除，确保最左是当前窗口最大值            }            deque.offer(i);//存放的是位置索引            if (i &gt;= k - 1){                res[index++] = nums[deque.peek()];            }        }        return res;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:            if not nums: return []        window , res = [], []        for i, x in enumerate(nums):            if i &gt;= k and window[0] &lt;= i - k:                window.pop(0)            while window and nums[window[-1]] &lt;= x:                window.pop()            window.append(i)            if i &gt;= k -1:                res.append(nums[window[0]])        return res</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第239题是难题，但是使用合适的数据结构和对应的逻辑，就能很好的完成，自带API真香。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Sliding-Window-Maximum&quot;&gt;&lt;a href=&quot;#Sliding-Window-Maximum&quot; class=&quot;headerlink&quot; title=&quot;Sliding Window Maximum&quot;&gt;&lt;/a&gt;Sl
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
      <category term="优先队列" scheme="https://wqdchn.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第703题Kth Largest Element in a Stream</title>
    <link href="https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html"/>
    <id>https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html</id>
    <published>2019-09-27T10:26:48.000Z</published>
    <updated>2019-11-08T11:55:58.085Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Kth-Largest-Element-in-a-Stream"><a href="#Kth-Largest-Element-in-a-Stream" class="headerlink" title="Kth Largest Element in a Stream"></a>Kth Largest Element in a Stream</h4><p><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">Kth Largest Element in a Stream</a>寻找一个整数流中第<code>K</code>大的元素，<code>K</code>是固定的，整数流包含一个构造函数<code>add</code>，每次往流中添加新元素时，就返回新的第<code>K</code>大的元素。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8</p></blockquote><p>这道题可以使用优先队列<code>PriorityQueue</code>来做，在<code>Java</code>中优先队列默认通过二叉小顶堆实现。我们可以令这个优先队列的长度为<code>K</code>，这个队列的头部就是整数流中第<code>K</code>大的元素，每当新的元素进来时，我们就把新的元素和队列头部元素（也就是堆顶）进行比较，如果新的元素比较大，则纳入新的元素。优先队列会自动维护小顶堆的性质，保证队列头部元素始终是我们需要的第<code>K</code>大的元素。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class KthLargest {       PriorityQueue&lt;Integer&gt; q;    int k;    public KthLargest(int k, int[] nums) {        this.k = k;        q = new PriorityQueue&lt;&gt;(k);        for (int n : nums){            add(n);        }           }    public int add(int val) {        if (q.size() &lt; k){            q.offer(val);        }else if (q.peek() &lt; val){            q.poll();            q.offer(val);        }        return q.peek();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class KthLargest:    def __init__(self, k, nums):        self.pool = nums        self.k = k        heapq.heapify(self.pool)        while len(self.pool) &gt; k:            heapq.heappop(self.pool)    def add(self, val):        if len(self.pool) &lt; self.k:            heapq.heappush(self.pool, val)        elif val &gt; self.pool[0]:            heapq.heapreplace(self.pool, val)        return self.pool[0]</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第703题是简单题，学会利用已有的数据结构，加一点简单的逻辑，能做很多神奇的事，再也不要暴力循环了鸭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Kth-Largest-Element-in-a-Stream&quot;&gt;&lt;a href=&quot;#Kth-Largest-Element-in-a-Stream&quot; class=&quot;headerlink&quot; title=&quot;Kth Largest 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
      <category term="优先队列" scheme="https://wqdchn.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第225题Implement Stack using Queues</title>
    <link href="https://wqdchn.github.io/leetcode-implement-stack-using-queues.html"/>
    <id>https://wqdchn.github.io/leetcode-implement-stack-using-queues.html</id>
    <published>2019-09-26T01:44:11.000Z</published>
    <updated>2019-11-08T11:55:53.057Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Implement-Stack-using-Queens"><a href="#Implement-Stack-using-Queens" class="headerlink" title="Implement Stack using Queens"></a>Implement Stack using Queens</h4><p><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">Implement Stack using Queens</a>用队列实现栈。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>MyStack stack = new MyStack();<br>stack.push(1);<br>stack.push(2);<br>stack.top();   // returns 2<br>stack.pop();   // returns 2<br>stack.empty(); // returns false</p></blockquote><p>栈的特性是先进后出，队列的特性是先进先出，我们要实现栈的三个操作，分别是<code>push</code>、<code>pop</code>、<code>top</code>，还有一个栈状态检查<code>empty</code>。类似用栈实现队列时，使用两个栈互相倒腾，这里用队列实现栈也可以使用两个队列来实现栈，燃鹅本文选择使用一个队列来实现栈，非炫技也，实有趣耳。</p><p>使用一个队列时，<code>push</code>操作很平常，就把元素压入队列中即可，即压入栈中。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table><p>执行<code>pop</code>操作时，由于栈是先进后出的，先前<code>push</code>入队的队列头部元素应该在栈底，而队列尾部元素是栈顶。也就是说，我们要<code>pop</code>的是队列尾部元素，那么怎么将尾部元素<code>pop</code>出去呢？</p><p>很简单，我们让除了队列末尾元素之外的其他队列元素出队，那原来的队尾元素不就变成新的队首元素了吗，让这个新的队首元素出队就是栈的<code>pop</code>操作，而出队的其他元素则再依次入队，保证栈<code>pop</code>之后其他元素没有丢失。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><p>执行<code>top</code>操作时和<code>pop</code>类似，只不过我们返回队首元素即可，注意，由于这个队首元素是原来的队尾元素，所以我们在使用过它之后，要让它出队再入队，保证它依然处于队尾，也就是栈顶。</p><p>状态检查只需查看队列是否为空即可。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        q.offer(x);    }    /** Removes the element on top of the stack and returns that element. */    public int pop() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        return q.poll();    }    /** Get the top element. */    public int top() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        int top = q.peek();        q.offer(q.poll());        return top;    }    /** Returns whether the stack is empty. */    public boolean empty() {        return q.isEmpty();    }}</code></pre><p>下面是相似的<code>Java</code>代码，请关注两者的区别：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        queue.add(x);        for (int i=1; i&lt;queue.size(); i++)            queue.add(queue.remove());    }    /** Removes the element on top of the stack and returns that element. */    public void pop() {        queue.remove();    }    /** Get the top element. */    public int top() {        return queue.peek();    }    /** Returns whether the stack is empty. */    public boolean empty() {        return queue.isEmpty();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class MyStack:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.queue = []    def push(self, x: int) -&gt; None:        &quot;&quot;&quot;        Push element x onto stack.        &quot;&quot;&quot;        self.queue.append(x)    def pop(self) -&gt; int:        &quot;&quot;&quot;        Removes the element on top of the stack and returns that element.        &quot;&quot;&quot;        return self.queue.pop()    def top(self) -&gt; int:        &quot;&quot;&quot;        Get the top element.        &quot;&quot;&quot;        return self.queue[-1]    def empty(self) -&gt; bool:        &quot;&quot;&quot;        Returns whether the stack is empty.        &quot;&quot;&quot;        return self.queue == []</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第225题是简单题，用一个队列实现栈其实也不难，关键依然是理解先进先出和先进后出之间的关联。这里<code>Python</code>的逻辑和分析中有所区别，主要是<code>Python</code>的内置函数太强大了，完全不需要多余的操作。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Implement-Stack-using-Queens&quot;&gt;&lt;a href=&quot;#Implement-Stack-using-Queens&quot; class=&quot;headerlink&quot; title=&quot;Implement Stack us
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第232题Implement Queen using Stacks</title>
    <link href="https://wqdchn.github.io/leetcode-implement-queen-using-stacks.html"/>
    <id>https://wqdchn.github.io/leetcode-implement-queen-using-stacks.html</id>
    <published>2019-09-25T10:41:12.000Z</published>
    <updated>2019-11-08T11:55:48.234Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Implement-Queen-using-Stacks"><a href="#Implement-Queen-using-Stacks" class="headerlink" title="Implement Queen using Stacks"></a>Implement Queen using Stacks</h4><p><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">Implement Queen using Stacks</a>用栈实现一个队列。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // returns 1<br>queue.pop();   // returns 1<br>queue.empty(); // returns false</p></blockquote><p>队列的特性是先进先出，栈的特性是先进后出，我们要实现队列的三个操作，分别是<code>push</code>、<code>pop</code>、<code>peek</code>，还有一个队列状态检查<code>empty</code>。可以使用两个栈来实现，分别是<code>input</code>、<code>output</code>，两者的分工非常清楚：</p><ul><li>所有的<code>push</code>操作，进队列的元素通通丢到<code>input</code>栈中。</li><li>所有的<code>pop</code>、<code>peek</code>操作，出队列的元素通通在<code>output</code>栈中输出。</li><li>状态检查时，只需要检查两个栈是否都为空，如果是，则队列为空。</li></ul><p>需要注意的地方是，两个栈之间如何互相“倒腾”元素。例如我们<code>push</code>了4次得到一个队列<code>[1，2，3，4]</code>，然后<code>pop</code>一次弹出元素<code>[1]</code>，队列中剩下<code>[2，3，4]</code>，我们再往里<code>push</code>元素<code>[5]</code>，得到队列<code>[2，3，4，5]</code>。那么这个过程中，<code>input</code>栈与<code>output</code>栈之间需要“倒腾”一下，4次<code>push</code>很简单，元素通通压入了<code>input</code>栈，此时<code>output</code>栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr></tbody></table><p>当我们执行<code>pop</code>时，需要把<code>input</code>栈中的元素“倒腾”到<code>output</code>栈中，再从<code>output</code>栈中<code>pop</code>出栈顶元素，此时<code>input</code>栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">4</td></tr></tbody></table><p>再往队列中<code>push</code>元素<code>[5]</code>时，需要把<code>output</code>栈中的元素“倒腾”到<code>input</code>栈中，再将新元素<code>[5]</code>给<code>push</code>到栈顶，此时<code>output</code>栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr></tbody></table><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class MyQueue {    Stack&lt;Integer&gt; input ;    Stack&lt;Integer&gt; output ;    /** Initialize your data structure here. */    public MyQueue() {        input = new Stack&lt;&gt;();        output = new Stack&lt;&gt;();    }    /** Push element x to the back of queue. */    public void push(int x) {        if (input.isEmpty()){            while (!output.isEmpty()){                input.push(output.pop());            }        }        input.push(x);    }    /** Removes the element from in front of queue and returns that element. */    public int pop() {        if (output.isEmpty()){            while (!input.isEmpty()){                output.push(input.pop());            }        }        return output.pop();    }    /** Get the front element. */    public int peek() {        if (output.isEmpty()){            while (!input.isEmpty()){                output.push(input.pop());            }        }        return output.peek();    }    /** Returns whether the queue is empty. */    public boolean empty() {        return input.isEmpty() &amp;&amp; output.isEmpty();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class MyQueue:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.input = []        self.output = []    def push(self, x: int) -&gt; None:        &quot;&quot;&quot;        Push element x to the back of queue.        &quot;&quot;&quot;        if len(self.input) == 0:            while len(self.output) != 0:                self.input.append(self.output.pop())        self.input.append(x)    def pop(self) -&gt; int:        &quot;&quot;&quot;        Removes the element from in front of queue and returns that element.        &quot;&quot;&quot;        if len(self.output) == 0:            while len(self.input) != 0:                self.output.append(self.input.pop())        return self.output.pop()    def peek(self) -&gt; int:        &quot;&quot;&quot;        Get the front element.        &quot;&quot;&quot;        if len(self.output) == 0:            while len(self.input) != 0:                self.output.append(self.input.pop())        return self.output[-1]    def empty(self) -&gt; bool:        &quot;&quot;&quot;        Returns whether the queue is empty.        &quot;&quot;&quot;        return len(self.input) == 0 and len(self.output) == 0</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第232题是简单题，两个数据结构的特性也非常清楚，关键在于理清先进先出与先进后出两个特性之间的关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Implement-Queen-using-Stacks&quot;&gt;&lt;a href=&quot;#Implement-Queen-using-Stacks&quot; class=&quot;headerlink&quot; title=&quot;Implement Queen us
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第141题Linked List Cycle</title>
    <link href="https://wqdchn.github.io/leetcode-linked-list-cycle.html"/>
    <id>https://wqdchn.github.io/leetcode-linked-list-cycle.html</id>
    <published>2019-09-25T02:18:10.000Z</published>
    <updated>2019-11-08T11:56:01.052Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h4><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a>判断链表是否有环。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p></blockquote><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example"></p><p>方法有两种：</p><ul><li>一种是使用<code>Set</code>的数据结构来遍历整个链表，只要链表中存在环，那么Set中必定会出现重复值，通过这种重复的冲突就可以判断链表中有无环。</li><li>另一种方法是使用<code>两个标兵</code>来遍历，一个跑得比香港记者还要快，一个跑得比香港记者慢，如果链表中存在环，那么快的标兵必定会在跑完一圈之后追上慢的标兵，通过这种追赶也能判断链表中有无环。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */class Solution {    public boolean hasCycle(ListNode head) {// Set        Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();        while (head != null) {            if (nodesSeen.contains(head)) {                return true;            } else {                nodesSeen.add(head);            }            head = head.next;        }        return false;    }    public boolean hasCycle(ListNode head) {// 标兵        if (head == null || head.next == null) {            return false;        }        ListNode slow = head;        ListNode fast = head.next;        while (slow != fast) {            if (fast == null || fast.next == null) {                return false;            }            slow = slow.next;            fast = fast.next.next;        }        return true;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def hasCycle(self, head): # Set        nodeset = set()        while head:            if head in nodeset:                return True            else:                nodeset.add(head)            head = head.next        return False    def hasCycle(self, head): # 标兵        fast = slow = head        while slow and fast and fast.next:            slow = slow.next            fast = fast.next.next            if slow is fast:                return True        return False</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第141题是简单题，<code>Set</code>的方法比较容易想到，<code>Set</code>也非常适合做重复检测的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Linked-List-Cycle&quot;&gt;&lt;a href=&quot;#Linked-List-Cycle&quot; class=&quot;headerlink&quot; title=&quot;Linked List Cycle&quot;&gt;&lt;/a&gt;Linked List Cycle
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第206题Reverse Linked List</title>
    <link href="https://wqdchn.github.io/leetcode-reverse-linked-list.html"/>
    <id>https://wqdchn.github.io/leetcode-reverse-linked-list.html</id>
    <published>2019-09-24T03:49:05.000Z</published>
    <updated>2019-11-08T11:56:22.149Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h4><p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a>反转单链表。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><p>我们需要三个指针，<code>prev</code>-&gt;<code>curr</code>-&gt;<code>next</code>，从头指针开始反转，令<code>curr</code>-&gt;<code>prev</code>，完成一个元素的反转之后，令其下一个元素为<code>curr</code>指针指向的对象，直到当前元素<code>curr</code>为空，可以使用遍历或递归的方式来实现。</p><table><thead><tr><th style="text-align:center">prev</th><th style="text-align:center">curr</th><th style="text-align:center">next</th><th style="text-align:center">…</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">…</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">…</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">…</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">…</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td><td style="text-align:center">…</td></tr></tbody></table><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseList(ListNode head) {// 遍历        ListNode re_head = null;        for (ListNode curr = head; curr != null; ){            ListNode temp = curr.next;            curr.next = re_head;            re_head = curr;            curr = temp;        }        return re_head;    }    public ListNode reverseList(ListNode head) {// 递归        if (head == null || head.next == null) return head;        ListNode re_head = reverseList(head.next);        head.next.next = head;        head.next = null;        return re_head;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reverseList(self, head):  # 遍历        re_head, curr = None, head        while curr:            curr.next, re_head, curr = re_head, curr, curr.next        return re_head    def reverseList(self, head: ListNode) -&gt; ListNode: # 递归        if head == None or head.next == None:            return head        temp = head.next        re_head = self.reverseList(temp)        head.next = None        temp.next = head        return re_head</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>LeetCode</code>题目的难度是变动的，这一题之前还是中等题，最近变成了简单题，可能是练习的人多了，<code>Accepted</code>高了，说明基础还是很重要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Reverse Linked List&quot;&gt;&lt;/a&gt;Reverse Lin
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第24题Swap Nodes in Pairs</title>
    <link href="https://wqdchn.github.io/leetcode-swap-nodes-in-pairs.html"/>
    <id>https://wqdchn.github.io/leetcode-swap-nodes-in-pairs.html</id>
    <published>2019-09-22T04:05:28.000Z</published>
    <updated>2019-11-08T11:56:31.473Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h4><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a>给定一个链表，交换两个相邻节点，注意，不能修改列表节点中的值，只能更改节点本身的顺序。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p></blockquote><p>链表的结点交换或反转没有什么特别的地方，就是一把梭。<code>LeeCode</code>已经给我们定义好了结点<code>Node</code>：一个指针，一个结点值，交换函数传入参数的是头指针。当结点数是偶数的时候，没有问题，当结点数是奇数的时候，最后一个结点的下一个结点是<code>Null</code>，就不能交换或反转。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode swapPairs(ListNode head) {        if (head == null) return null;        if (head.next == null) return head;        ListNode temp = head.next;        head.next = head.next.next;        temp.next = head;        head = temp;        head.next.next = swapPairs(head.next.next);        return head;           }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        pre, pre.next = self, head        while pre.next and pre.next.next:            a = pre.next            b = a.next            pre.next, b.next, a.next = b, a, b.next            pre = a        return  self.next</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第24题是中等题，逻辑很简单，但是编码上有一些细节，别把自己绕晕了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Swap-Nodes-in-Pairs&quot;&gt;&lt;a href=&quot;#Swap-Nodes-in-Pairs&quot; class=&quot;headerlink&quot; title=&quot;Swap Nodes in Pairs&quot;&gt;&lt;/a&gt;Swap Nodes 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第22题Generate Parentheses</title>
    <link href="https://wqdchn.github.io/leetcode-generate-parentheses.html"/>
    <id>https://wqdchn.github.io/leetcode-generate-parentheses.html</id>
    <published>2019-09-21T04:15:25.000Z</published>
    <updated>2019-11-08T11:55:40.041Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h4><p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">Generate Parentheses</a>给定一个正整数，生成有效括号的所有组合，这里只需要生成小括号即可。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>Input: n = 3<br>Output: [<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><p>可见，当<code>n</code>确定时，生成的解的长度是固定的<code>2n</code>，并且解的开头一定是左括号，如果是右括号则是无效的解，左括号与右括号的数量必定是一样的，都是<code>n</code>个，这些是分析题目要求得到的“先验知识”了，接下来开始<code>Code</code><del>贝叶斯推断bushi</del>。</p><p>怎么办呢，可以用递归或者说深度优先搜索的方法来遍历，每一个解看成一个长度<code>2n</code>的一维数组，我们往里面填充左括号和右括号，起始值都是<code>n</code>个，用掉一个就减去一个。如果当前还有左括号，就使用一个左括号，同时，如果右括号的数量比左括号多，则为左括号匹配一个右括号，直到两者都用完为止。</p><h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {  public List&lt;String&gt; generateParenthesis(int n) {    List&lt;String&gt; res = new ArrayList&lt;&gt;();    generate(&quot;&quot;, res, n, n);    return res;  }  public void generate(String sublist, List&lt;String&gt; res, int left, int right) {    if (left == 0 &amp;&amp; right == 0) {      res.add(sublist);      return;    }    if (left &gt; 0) {      generate(sublist + &quot;(&quot;, res, left - 1, right);    }    if (right &gt; left) {      generate(sublist + &quot;)&quot;, res, left, right - 1);    }  }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        def generate(p, left, right, parens=[]):            if left:                generate(p + &#39;(&#39;, left - 1, right)            if right &gt; left:                generate(p + &#39;)&#39;, left, right - 1)            if not right:                parens += p,            return parens        return generate(&#39;&#39;, n, n)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第22题是一个中等题，难度还不算非常大，递归的方法也非常简洁易懂，加油↖(^ω^)↗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Generate-Parentheses&quot;&gt;&lt;a href=&quot;#Generate-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;Generate Parentheses&quot;&gt;&lt;/a&gt;Generate
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="深度优先搜索" scheme="https://wqdchn.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第20题Valid Parentheses</title>
    <link href="https://wqdchn.github.io/leetcode-valid-parentheses.html"/>
    <id>https://wqdchn.github.io/leetcode-valid-parentheses.html</id>
    <published>2019-09-19T14:02:38.000Z</published>
    <updated>2019-11-08T11:56:45.059Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h4><p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a>的要求是匹配括号的合法性。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: “()”<br>Output: true</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: “()[]{}”<br>Output: true</p></blockquote><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h5><blockquote><p>Input: “(]”<br>Output: false</p></blockquote><p><del>解法明天再写，回去洗洗睡先。</del></p><p>方法是使用一个栈的数据结构来匹配括号，我们将每一个元素和三种括号分别进行匹配，如果是<code>“(”</code>那么就往栈里<code>push</code>进一个它的“解”也就是<code>“)”</code>，中括号和大括号也类似，也就是说我们匹配到一个左括号就往栈里<code>push</code>进一个“解”—右括号。</p><p>假设当前的括号序列是<code>“()[]{}”</code>，当匹配到第一个元素<code>“(”</code>的时候，栈里面就<code>push</code>进一个<code>“)”</code>，当匹配走到第二个元素<code>“)”</code>的时候，由于它不是待匹配的左括号，而是“解”，所以我们<code>pop</code>栈中的内容，刚好发现栈里面有一个<code>“)”</code>,于是将它<code>pop</code>出去，同理解决余下的元素，最后发现，栈是空的，且所有元素都匹配完了，说明没有非法的括号。如果中途栈就空了，而当前待匹配的不是左括号而是“解”—右括号，则说明已经无解了。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public boolean isValid(String s) {        if (s == null || s.length() == 0) return true;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (Character ch : s.toCharArray()) {            if (ch == &#39;(&#39;){                stack.push(&#39;)&#39;);            } else if (ch == &#39;[&#39;){                stack.push(&#39;]&#39;);            } else if (ch == &#39;{&#39;){                stack.push(&#39;}&#39;);            } else {                if (stack.isEmpty() || stack.pop() != ch){                    return false;                }            }        }        return stack.isEmpty();    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def isValid(self, s: str) -&gt; bool:        stack = []        paren_map = {&#39;)&#39;:&#39;(&#39;, &#39;]&#39;:&#39;[&#39;, &#39;}&#39;:&#39;{&#39;}        for c in s:            if c not in paren_map:                stack.append(c)            elif not stack or paren_map[c] != stack.pop():                return False        return not stack</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第20题是简单题，只要对栈这种数据结构稍微熟悉就能知道该怎么办，数据结构与算法的课程讲到栈这一节的时候也提到过括号匹配的问题<del>我猜大部分同学用的是严蔚民老师的那本经典教材</del>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Valid-Parentheses&quot;&gt;&lt;a href=&quot;#Valid-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;Valid Parentheses&quot;&gt;&lt;/a&gt;Valid Parentheses
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第15题Three Sum</title>
    <link href="https://wqdchn.github.io/leetcode-three-sum.html"/>
    <id>https://wqdchn.github.io/leetcode-three-sum.html</id>
    <published>2019-09-18T11:16:49.000Z</published>
    <updated>2019-11-08T11:56:34.442Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Three-Sum"><a href="#Three-Sum" class="headerlink" title="Three Sum"></a>Three Sum</h4><p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">Three Sum</a>和<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">TwoSum</a>属于类似的题目，<code>ThreeSum</code>要求是，给定一个数组和一个目标值，求得数组中<code>a</code>+<code>b</code>+<code>c</code>=<code>0</code>的三个数<code>a</code>，<code>b</code>，<code>c</code>，这里目标数定为了零。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Given array nums = [-1, 0, 1, 2, -1, -4]</p></blockquote><blockquote><p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><p>解法如下，首先对数组进行从小到大排序，假定当前这个数<code>nums[i]</code>为<code>a</code>，我们在后面的数中寻找<code>b</code>和<code>c</code>，使得<code>a</code>+<code>b</code>+<code>c</code>=<code>0</code>。记住，我们已经排序过了，所以可以从两头进行夹逼，遍历满足条件的<code>b</code>和<code>c</code>，当<code>a</code>+<code>b</code>+<code>c</code>&gt;<code>0</code>的时候，剩余数的末尾<code>nums[length-1]</code>向左走，当<code>a</code>+<code>b</code>+<code>c</code>&lt;<code>0</code>的时候，剩余数的开头<code>nums[i+1]</code>向右走，。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">class Solution {    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        Arrays.sort(nums);        for (int i = 0; i + 2 &lt; nums.length; i++) {            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {//一次循环过后要么找到一组解，要么无解                continue;//此处跳过重复解            }            int j = i + 1;            int k = nums.length - 1;            int target = -nums[i];            while (j &lt; k) {                if (nums[j] + nums[k] == target) {                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));                    j++;                    k--;                    while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++;                    while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--;                } else if (nums[j] + nums[k] &gt; target) {                    k--;                } else {                    j++;                }            }        }        return res;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def threeSum(self, nums):        if len(nums) &lt; 0: return []        nums.sort()        res = set()        for i, v in enumerate(nums[:-2]):            if i &gt;= 1 and v == nums[i-1]:                continue            d = {}            for x in nums[i+1:]:                if x not in d:                    d[-v-x] = 1                else:                    res.add((v, -v-x, x))        return list(map(list, res))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第15题是中等题，解法依然很挠头，一遍写不出系列，Keep Moving T_T</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Three-Sum&quot;&gt;&lt;a href=&quot;#Three-Sum&quot; class=&quot;headerlink&quot; title=&quot;Three Sum&quot;&gt;&lt;/a&gt;Three Sum&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcod
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="哈希表" scheme="https://wqdchn.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第7题Reverse Integer</title>
    <link href="https://wqdchn.github.io/leetcode-reverse-integer.html"/>
    <id>https://wqdchn.github.io/leetcode-reverse-integer.html</id>
    <published>2019-09-15T04:09:44.000Z</published>
    <updated>2019-11-08T11:56:18.930Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h4><p><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Reverse Integer</a>的题目要求很简单，给定32位有符号整数，返回该整数翻转后的结果，结果中零在第一位的省略零。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: 123<br>Output: 321</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: -123<br>Output: -321</p></blockquote><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h5><blockquote><p>Input: 120<br>Output: 21</p></blockquote><p>同样，考虑一个简单粗暴的方法，将整数转换成字符串，将字符串转换成数组，对数组做逆序操作。当然要先判断这个整数的正负，然后考虑翻转后有没有零。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是<code>Java</code>的代码：</p><pre><code class="Java">Class Solution{    public static int reverse(int n) {        if (n &gt; Integer.MAX_VALUE || n &lt; Integer.MIN_VALUE) {            return 0;        }        String s = String.valueOf(n);        if (n &lt; 0) {            s = s.substring(1, s.length());            char[] array = s.toCharArray();            String reverse = &quot;-&quot;;            for (int i = array.length - 1; i &gt;= 0; i--) {                reverse += array[i];            }            s = reverse;        } else {            char[] array = s.toCharArray();            String reverse = &quot;&quot;;            for (int i = array.length - 1; i &gt;= 0; i--) {                reverse += array[i];            }            while (reverse.length() &gt; 1 &amp;&amp; reverse.charAt(0) == &#39;0&#39;) {                reverse = reverse.substring(1, reverse.length());            }            s = reverse;        }        int i = 0;        try {            i = Integer.parseInt(s.toString().trim());        } catch (Exception e) {            return 0;        }        return i;    }}</code></pre><p>下面是<code>Python</code>的代码：</p><pre><code class="Python">class Solution:    def reverse(self, x: int) -&gt; int:        if x &gt;= 0:            res = int(str(x)[::-1])        else:            res = int(&#39;-&#39; + str(x)[:0:-1])        return res if -2147483648 &lt;= res &lt;= 2147483647 else 0</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第7题是简单题，<code>LeetCode</code>给出的标准解法有点挠头，先不管了<del>我好菜啊</del>。另外不得不说<code>Python</code>的内置函数真的太强大了T_T。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Reverse-Integer&quot;&gt;&lt;a href=&quot;#Reverse-Integer&quot; class=&quot;headerlink&quot; title=&quot;Reverse Integer&quot;&gt;&lt;/a&gt;Reverse Integer&lt;/h4&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://wqdchn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
