<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenQian Dong&#39;s Web</title>
  
  <subtitle>Coder,Java,Linux,Google Fans</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wqdchn.github.io/"/>
  <updated>2019-10-10T05:32:54.453Z</updated>
  <id>https://wqdchn.github.io/</id>
  
  <author>
    <name>WenQian Dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode第111题Minimum Depth of Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-minimum-depth-of-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-minimum-depth-of-binary-tree.html</id>
    <published>2019-10-10T05:14:13.000Z</published>
    <updated>2019-10-10T05:32:54.453Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h4><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a>求二叉树的最小深度。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5]<br>Output: 3</p></blockquote><p>二叉树的深度可以通过深度优先搜索和广度优先搜索两种方式来遍历，并记录树的层次。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    // dfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        int left = minDepth(root.left);        int right = minDepth(root.right);        return (left == 0 || right ==0) ? left + right + 1 : Math.min(left, right) + 1;    }    // bfs    public int minDepth(TreeNode root) {        if (root == null) return 0;        Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);        int depth = 1;        while (!q.isEmpty()){            int size = q.size();            while (size-- &gt; 0){                TreeNode node = q.poll();                if (node.left == null &amp;&amp; node.right == null){                   return depth;                }                if (node.left != null){                    q.offer(node.left);                }                if (node.right != null){                    q.offer(node.right);                }            }            depth++;        }        return depth;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # dfs    def minDepth(self, root: TreeNode):        if not root:            return 0        if not root.left and not root.right:            return 1        if root.left and not root.right:            return 1 + self.minDepth(root.left)        if root.right and not root.left:            return 1 + self.minDepth(root.right)        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))    # bfs    def minDepth(self, root):        if not root: return 0        q = collections.deque([(root, 1)])        while q:            curr, depth = q.popleft()            if not curr.left and not curr.right:                return depth            if curr.left:                q.append((curr.left, depth + 1))            if curr.right:                q.append((curr.right, depth + 1))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第111题是简单题，只需熟悉二叉树的深度优先搜索与广度优先搜索，并记录对应的层次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Minimum-Depth-of-Binary-Tree&quot;&gt;&lt;a href=&quot;#Minimum-Depth-of-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Minimum Depth of B
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="深度优先搜索" scheme="https://wqdchn.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="广度优先搜索" scheme="https://wqdchn.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第235题Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-search-tree.html</id>
    <published>2019-10-09T02:23:53.000Z</published>
    <updated>2019-10-09T03:17:41.008Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Search Tree</a>给定一个二叉<strong>搜索</strong>树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Lowest Common Ancestor of a Binary Search Tree Example1"></p><blockquote><p>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p></blockquote><p>这一题和236题<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>有些相似，二叉搜索树是二叉树的一种，所以236题的解法也适用于这题。特别的是，二叉搜索树中根节点的值大于左子树的节点值，小于右子树的节点值，这是可以利用的一个性质：</p><ul><li>我们记LCA(2,8) = 6，此时节点p和q是2和8，我们将节点值与根节点值6进行比较，发现p和q分别位于根节点左右两侧，此时根节点6是最近祖先。</li><li>我们记LCA(7,9) = 8，此时节点p和q是7和9，我们将节点值与根节点值6进行比较，发现p和q都大于根节点，都位于右子树，于是，我们进入右子树进行遍历，此时原来右子树的根节点8成为新的根节点，继续遍历比较。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        int parentVal = root.val;        int pVal = p.val;        int qVal = q.val;        if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {            return lowestCommonAncestor(root.right, p, q);        } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {            return lowestCommonAncestor(root.left, p, q);        } else {            return root;        }    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q):        if p.val &lt; root.val &gt; q.val:            return self.lowestCommonAncestor(root.left, p, q)        if p.val &gt; root.val &lt; q.val:            return  self.lowestCommonAncestor(root.right, p, q)        return  root</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第235题是简单题，利用二叉<strong>搜索</strong>树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Lowest-Common-Ancestor-of-a-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#Lowest-Common-Ancestor-of-a-Binary-Search-Tree&quot; class=&quot;h
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2019年国庆节</title>
    <link href="https://wqdchn.github.io/national-day-of-the-people-s-republic-of-china.html"/>
    <id>https://wqdchn.github.io/national-day-of-the-people-s-republic-of-china.html</id>
    <published>2019-10-04T12:24:51.000Z</published>
    <updated>2019-10-05T02:33:47.570Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="国庆·1949-2019"><a href="#国庆·1949-2019" class="headerlink" title="国庆·1949-2019"></a>国庆·1949-2019</h4><p>今年的国庆节似乎有些特别，从大面上来说，我感受到非常高涨的热情，无论是朋友圈还是微博，也许是这一年发生太多以往没有发生的事，让普通群众们了解到了周边生活之外的零零碎碎，激发起了内心朴素的那一份感情：希望这个国家好。当然，我也清楚地知道，恨不得这个国家立即从地球上消失的也大有人在，怎么说呢，求同存异吧，我认为对于普通人来说，只要过好手头的日子，做好自己的工作，爱护自己的家人朋友，就是最大的爱国。别的嘛，牢骚太盛防肠断，风物长宜放眼量。我相信未来会越来越好，从深渊回望，莫回头，莫回头。</p><h4 id="阅兵·游行·联欢"><a href="#阅兵·游行·联欢" class="headerlink" title="阅兵·游行·联欢"></a>阅兵·游行·联欢</h4><p>今年的国庆阅兵、群众游行、国庆联欢晚会三部曲都非常出乎我的意料，实在是太惊喜了，组织度这么高，组织能力这么强足以说明我国的体制在集中力量办大事这方面有着无与匹敌的优势，只要方向正确，中国人民总是能干出惊天动地的事业，这一点，从我中国人民解放军军史上就有许多明证。例如阅兵中给我印象最深刻的就是战旗方队，一百面英雄的旗帜，无数英勇的先烈们。其中有些部队本身可能出身于解放战争后期国民党方面的队伍，战斗力差，战斗意志弱，而起义、投诚、收编到了解放军中之后，仿佛脱胎换骨一般，这里面岂无值得深思的地方？</p><p>祝愿伟大祖国繁荣昌盛，期待建国一百周年，那时候的世界，又会是怎样一番天地呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;国庆·1949-2019&quot;&gt;&lt;a href=&quot;#国庆·1949-2019&quot; class=&quot;headerlink&quot; title=&quot;国庆·1949-2019&quot;&gt;&lt;/a&gt;国庆·1949-2019&lt;/h4&gt;&lt;p&gt;今年的国庆节似乎有些特别
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wqdchn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://wqdchn.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="时事" scheme="https://wqdchn.github.io/tags/%E6%97%B6%E4%BA%8B/"/>
    
      <category term="国庆" scheme="https://wqdchn.github.io/tags/%E5%9B%BD%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第236题Lowest Common Ancestor of a Binary Tree</title>
    <link href="https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-tree.html"/>
    <id>https://wqdchn.github.io/leetcode-lowest-common-ancestor-of-a-binary-tree.html</id>
    <published>2019-09-30T00:19:18.000Z</published>
    <updated>2019-10-09T02:31:23.294Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>给定一个二叉树，找到树中两个给定结点的最近公共祖先结点<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">LCA</a>。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="Lowest Common Ancestor of a Binary Tree Example1"></p><blockquote><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.</p></blockquote><p>如何寻找最近公共祖先呢，我们可以通过遍历目标结点q和p的路径，得到其中重合的最近的部分，这很直接，比较好理解。这里我们使用递归的方式来遍历，从根节点开始分别遍历左右子树，如果目标结点仅存在于左子树内，那么最近公共节点必然位于左子树内，如果目标结点同时存在于左右子树内，那么最近公共节点必然是根节点。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root == null || root == p || root == q) return root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        return left == null ? right : right == null ? left : root;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root, p, q)        if root in {None, p, q}:            return root        left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        return root if (left and right) else (left or right)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第236题是中等题，利用二叉树的性质，通过递归可以写出美感较强的代码，易于阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Lowest-Common-Ancestor-of-a-Binary-Tree&quot;&gt;&lt;a href=&quot;#Lowest-Common-Ancestor-of-a-Binary-Tree&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="树" scheme="https://wqdchn.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://wqdchn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第242题Valid Anagram</title>
    <link href="https://wqdchn.github.io/leetcode-valid-anagram.html"/>
    <id>https://wqdchn.github.io/leetcode-valid-anagram.html</id>
    <published>2019-09-28T23:50:14.000Z</published>
    <updated>2019-09-29T00:11:58.646Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h4><p><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">Valid Anagram</a>给出两个字符串s和t，查看字符串t是否是字符串s的异位词。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: s = “anagram”, t = “nagaram”<br>Output: true</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: s = “rat”, t = “car”<br>Output: false</p></blockquote><p>这一题很简单，只需要用哈希的方法来解决，我们使用一个一维数组，数组的长度是26，里面我们存放26个字母的计数，如果字符c同时存在与字符串s与字符串t中，则该字符在数组中+1再-1记为零，只要数组中存在不为零的元素，则字符串s和字符串t不是有效的异位词。</p><p>还可以使用字符数组排序的方法，如果字符串s和字符串t是有效异位词，那么两者包含的字符在唯一性上是相等的，排序后的序列也必定相等。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class Solution {    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) return false;        int[] counter = new int[26];        for (int i = 0; i &lt; s.length(); i++) {            counter[s.charAt(i) - &#39;a&#39;]++;            counter[t.charAt(i) - &#39;a&#39;]--;        }        for (int count : counter) {            if (count != 0) {                return false;            }        }        return true;    }    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) {            return false;        }        char[] str1 = s.toCharArray();        char[] str2 = t.toCharArray();        Arrays.sort(str1);        Arrays.sort(str2);        return Arrays.equals(str1, str2);    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        if len(s) != len(t): return False        count = collections.defaultdict(int)        for c in s:            count[c] += 1        for c in t:            count[c] -= 1            if count[c] &lt; 0:                return False        return True</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第242题是简单题，冲鸭！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Valid-Anagram&quot;&gt;&lt;a href=&quot;#Valid-Anagram&quot; class=&quot;headerlink&quot; title=&quot;Valid Anagram&quot;&gt;&lt;/a&gt;Valid Anagram&lt;/h4&gt;&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="哈希表" scheme="https://wqdchn.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第239题Sliding Window Maximum</title>
    <link href="https://wqdchn.github.io/leetcode-sliding-window-maximum.html"/>
    <id>https://wqdchn.github.io/leetcode-sliding-window-maximum.html</id>
    <published>2019-09-28T00:02:09.000Z</published>
    <updated>2019-09-28T03:12:04.289Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Sliding-Window-Maximum"><a href="#Sliding-Window-Maximum" class="headerlink" title="Sliding Window Maximum"></a>Sliding Window Maximum</h4><p><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a>，给定一个数组num，一个大小为k的滑动窗口，该窗口从数组的最左边移到最右边，得出窗口内的最大值。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3<br>Output: [3,3,5,5,6,7]<br>Explanation: </p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">Max</th></tr></thead><tbody><tr><td style="text-align:center"><strong>[1</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>-1]</strong></td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>-1</strong></td><td style="text-align:center"><strong>-3]</strong></td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center"><strong>[-1</strong></td><td style="text-align:center"><strong>-3</strong></td><td style="text-align:center"><strong>5]</strong></td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center"><strong>[-3</strong></td><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>3]</strong></td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center"><strong>[5</strong></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>6</strong>]</td><td style="text-align:center">7</td><td style="text-align:center"><strong>6</strong></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">-1</td><td style="text-align:center">-3</td><td style="text-align:center">5</td><td style="text-align:center"><strong>[3</strong></td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>7]</strong></td><td style="text-align:center"><strong>7</strong></td></tr></tbody></table><p>这一题和<a href="https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html">Kth Largest Element in a Stream</a>寻找一个整数流中第K大的元素非常相似，也可以使用队列来完成。这里使用一个双端队列，队列中存放当前窗口最大值的数组下标，每当滑动窗口的时候，就记录一次结果。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || k &lt;= 0) return new int[0];        int[] res = new int[nums.length - k + 1];//保存结果        ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;();//双端队列        int index = 0;        for (int i = 0; i &lt; nums.length; i++){            while (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){//越界                deque.poll();            }            while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]){                deque.pollLast();//从右向左剔除，确保最左是当前窗口最大值            }            deque.offer(i);//存放的是位置索引            if (i &gt;= k - 1){                res[index++] = nums[deque.peek()];            }        }        return res;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:            if not nums: return []        window , res = [], []        for i, x in enumerate(nums):            if i &gt;= k and window[0] &lt;= i - k:                window.pop(0)            while window and nums[window[-1]] &lt;= x:                window.pop()            window.append(i)            if i &gt;= k -1:                res.append(nums[window[0]])        return res</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第239题是难题，但是使用合适的数据结构和对应的逻辑，就能很好的完成，自带API真香。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Sliding-Window-Maximum&quot;&gt;&lt;a href=&quot;#Sliding-Window-Maximum&quot; class=&quot;headerlink&quot; title=&quot;Sliding Window Maximum&quot;&gt;&lt;/a&gt;Sl
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
      <category term="优先队列" scheme="https://wqdchn.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第703题Kth Largest Element in a Stream</title>
    <link href="https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html"/>
    <id>https://wqdchn.github.io/leetcode-kth-largest-element-in-a-stream.html</id>
    <published>2019-09-27T10:26:48.000Z</published>
    <updated>2019-09-28T03:11:47.592Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Kth-Largest-Element-in-a-Stream"><a href="#Kth-Largest-Element-in-a-Stream" class="headerlink" title="Kth Largest Element in a Stream"></a>Kth Largest Element in a Stream</h4><p><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">Kth Largest Element in a Stream</a>寻找一个整数流中第K大的元素，K是固定的，整数流包含一个构造函数add，每次往流中添加新元素时，就返回新的第K大的元素。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8</p></blockquote><p>这道题可以使用优先队列PriorityQueue来做，在Java中优先队列默认通过二叉小顶堆实现，我们可以令这个优先队列的长度为K，这个队列的头部就是整数流中第K大的元素，每当新的元素进来时，我们就把新的元素和队列头部元素（也就是堆顶）进行比较，如果新的元素比较大，则纳入新的元素，优先队列会自动维护小顶堆的性质，保证队列头部元素始终是我们需要的第K大的元素。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class KthLargest {       PriorityQueue&lt;Integer&gt; q;    int k;    public KthLargest(int k, int[] nums) {        this.k = k;        q = new PriorityQueue&lt;&gt;(k);        for (int n : nums){            add(n);        }           }    public int add(int val) {        if (q.size() &lt; k){            q.offer(val);        }else if (q.peek() &lt; val){            q.poll();            q.offer(val);        }        return q.peek();    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class KthLargest:    def __init__(self, k, nums):        self.pool = nums        self.k = k        heapq.heapify(self.pool)        while len(self.pool) &gt; k:            heapq.heappop(self.pool)    def add(self, val):        if len(self.pool) &lt; self.k:            heapq.heappush(self.pool, val)        elif val &gt; self.pool[0]:            heapq.heapreplace(self.pool, val)        return self.pool[0]</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第703题是简单题，学会利用已有的数据结构，加一点简单的逻辑，能做很多神奇的事，再也不要暴力循环了鸭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Kth-Largest-Element-in-a-Stream&quot;&gt;&lt;a href=&quot;#Kth-Largest-Element-in-a-Stream&quot; class=&quot;headerlink&quot; title=&quot;Kth Largest 
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
      <category term="优先队列" scheme="https://wqdchn.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第225题Implement Stack using Queues</title>
    <link href="https://wqdchn.github.io/leetcode-implement-stack-using-queues.html"/>
    <id>https://wqdchn.github.io/leetcode-implement-stack-using-queues.html</id>
    <published>2019-09-26T01:44:11.000Z</published>
    <updated>2019-09-28T03:11:43.646Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Implement-Stack-using-Queens"><a href="#Implement-Stack-using-Queens" class="headerlink" title="Implement Stack using Queens"></a>Implement Stack using Queens</h4><p><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">Implement Stack using Queens</a>用队列实现栈。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>MyStack stack = new MyStack();<br>stack.push(1);<br>stack.push(2);<br>stack.top();   // returns 2<br>stack.pop();   // returns 2<br>stack.empty(); // returns false</p></blockquote><p>栈的特性是先进后出，队列的特性是先进先出，我们要实现栈的三个操作，分别是push、pop、top，还有一个栈状态检查empty。类似用栈实现队列时，使用两个栈互相倒腾，这里用队列实现栈也可以使用两个队列来实现栈，燃鹅本文选择使用一个队列来实现栈，非炫技也，实有趣耳。</p><p>使用一个队列时，push操作很平常，就把元素压入队列中即可，即压入栈中。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table><p>执行pop操作时，由于栈是先进后出的，先前push入队的队列头部元素应该在栈底，而队列尾部元素是栈顶，也就是说，我们要pop的是队列尾部元素，那么怎么将尾部元素pop出去呢，很简单，我们让除了队列末尾元素之外的其他队列元素出队，那原来的队尾元素不就变成新的队首元素了吗，让这个新的队首元素出队就是栈的pop操作，而出队的其他元素则再依次入队，保证栈pop之后其他元素没有丢失。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><p>执行top操作时和pop类似，只不过我们返回队首元素即可，注意，由于这个队首元素是原来的队尾元素，所以我们在使用过它之后，要让它出队再入队，保证它依然处于队尾，也就是栈顶。</p><p>状态检查只需查看队列是否为空即可。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        q.offer(x);    }    /** Removes the element on top of the stack and returns that element. */    public int pop() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        return q.poll();    }    /** Get the top element. */    public int top() {        for (int i = 1; i &lt; q.size(); i++){            q.offer(q.poll());        }        int top = q.peek();        q.offer(q.poll());        return top;    }    /** Returns whether the stack is empty. */    public boolean empty() {        return q.isEmpty();    }}</code></pre><p>下面是相似的Java代码，请关注两者的区别：</p><pre><code class="Java">class MyStack {    Queue&lt;Integer&gt; q;    /** Initialize your data structure here. */    public MyStack() {        q = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        queue.add(x);        for (int i=1; i&lt;queue.size(); i++)            queue.add(queue.remove());    }    /** Removes the element on top of the stack and returns that element. */    public void pop() {        queue.remove();    }    /** Get the top element. */    public int top() {        return queue.peek();    }    /** Returns whether the stack is empty. */    public boolean empty() {        return queue.isEmpty();    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class MyStack:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.queue = []    def push(self, x: int) -&gt; None:        &quot;&quot;&quot;        Push element x onto stack.        &quot;&quot;&quot;        self.queue.append(x)    def pop(self) -&gt; int:        &quot;&quot;&quot;        Removes the element on top of the stack and returns that element.        &quot;&quot;&quot;        return self.queue.pop()    def top(self) -&gt; int:        &quot;&quot;&quot;        Get the top element.        &quot;&quot;&quot;        return self.queue[-1]    def empty(self) -&gt; bool:        &quot;&quot;&quot;        Returns whether the stack is empty.        &quot;&quot;&quot;        return self.queue == []</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第225题是简单题，用一个队列实现栈其实也不难，关键依然是理解先进先出和先进后出之间的关联。这里Python的逻辑和分析中有所区别，主要是Python的内置函数太强大了，完全不需要多余的操作。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Implement-Stack-using-Queens&quot;&gt;&lt;a href=&quot;#Implement-Stack-using-Queens&quot; class=&quot;headerlink&quot; title=&quot;Implement Stack us
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第232题Implement Queen using Stacks</title>
    <link href="https://wqdchn.github.io/leetcode-implement-queen-using-stacks.html"/>
    <id>https://wqdchn.github.io/leetcode-implement-queen-using-stacks.html</id>
    <published>2019-09-25T10:41:12.000Z</published>
    <updated>2019-09-28T03:11:35.492Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Implement-Queen-using-Stacks"><a href="#Implement-Queen-using-Stacks" class="headerlink" title="Implement Queen using Stacks"></a>Implement Queen using Stacks</h4><p><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">Implement Queen using Stacks</a>用栈实现一个队列。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // returns 1<br>queue.pop();   // returns 1<br>queue.empty(); // returns false</p></blockquote><p>队列的特性是先进先出，栈的特性是先进后出，我们要实现队列的三个操作，分别是push、pop、peek，还有一个队列状态检查empty。可以使用两个栈来实现，分别是input、output，两者的分工非常清楚：</p><ul><li>所有的push操作，进队列的元素通通丢到input栈中。</li><li>所有的pop、peek操作，出队列的元素通通在output栈中输出。</li><li>状态检查时，只需要检查两个栈是否都为空，如果是，则队列为空。</li></ul><p>需要注意的地方是，两个栈之间如何互相“倒腾”元素。例如我们push了4次得到一个队列[1，2，3，4]，然后pop一次弹出元素[1]，队列中剩下[2，3，4]，我们再往里push元素[5]，得到队列[2，3，4，5]。那么这个过程中，input栈与output栈之间需要“倒腾”一下，4次push很简单，元素通通压入了input栈，此时output栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr></tbody></table><p>当我们执行pop时，需要把input栈中的元素“倒腾”到output栈中，再从output栈中pop出栈顶元素，此时input栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">#</td><td style="text-align:center">4</td></tr></tbody></table><p>再往队列中push元素[5]时，需要把output栈中的元素“倒腾”到input栈中，再将新元素[5]push到栈顶，此时output栈为空。</p><table><thead><tr><th style="text-align:center">input</th><th style="text-align:center">#</th><th style="text-align:center">output</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">#</td><td style="text-align:center">null</td></tr></tbody></table><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class MyQueue {    Stack&lt;Integer&gt; input ;    Stack&lt;Integer&gt; output ;    /** Initialize your data structure here. */    public MyQueue() {        input = new Stack&lt;&gt;();        output = new Stack&lt;&gt;();    }    /** Push element x to the back of queue. */    public void push(int x) {        if (input.isEmpty()){            while (!output.isEmpty()){                input.push(output.pop());            }        }        input.push(x);    }    /** Removes the element from in front of queue and returns that element. */    public int pop() {        if (output.isEmpty()){            while (!input.isEmpty()){                output.push(input.pop());            }        }        return output.pop();    }    /** Get the front element. */    public int peek() {        if (output.isEmpty()){            while (!input.isEmpty()){                output.push(input.pop());            }        }        return output.peek();    }    /** Returns whether the queue is empty. */    public boolean empty() {        return input.isEmpty() &amp;&amp; output.isEmpty();    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class MyQueue:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.input = []        self.output = []    def push(self, x: int) -&gt; None:        &quot;&quot;&quot;        Push element x to the back of queue.        &quot;&quot;&quot;        if len(self.input) == 0:            while len(self.output) != 0:                self.input.append(self.output.pop())        self.input.append(x)    def pop(self) -&gt; int:        &quot;&quot;&quot;        Removes the element from in front of queue and returns that element.        &quot;&quot;&quot;        if len(self.output) == 0:            while len(self.input) != 0:                self.output.append(self.input.pop())        return self.output.pop()    def peek(self) -&gt; int:        &quot;&quot;&quot;        Get the front element.        &quot;&quot;&quot;        if len(self.output) == 0:            while len(self.input) != 0:                self.output.append(self.input.pop())        return self.output[-1]    def empty(self) -&gt; bool:        &quot;&quot;&quot;        Returns whether the queue is empty.        &quot;&quot;&quot;        return len(self.input) == 0 and len(self.output) == 0</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第232题是简单题，两个数据结构的特性也非常清楚，关键在于理清先进先出与先进后出两个特性之间的关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Implement-Queen-using-Stacks&quot;&gt;&lt;a href=&quot;#Implement-Queen-using-Stacks&quot; class=&quot;headerlink&quot; title=&quot;Implement Queen us
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第141题Linked List Cycle</title>
    <link href="https://wqdchn.github.io/leetcode-linked-list-cycle.html"/>
    <id>https://wqdchn.github.io/leetcode-linked-list-cycle.html</id>
    <published>2019-09-25T02:18:10.000Z</published>
    <updated>2019-09-28T03:11:52.797Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h4><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a>判断链表是否有环。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p></blockquote><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example"></p><p>方法有两种：</p><ul><li>一种是使用Set的数据结构来遍历整个链表，只要链表中存在环，那么Set中必定会出现重复值，通过这种重复的冲突就可以判断链表中有无环。</li><li>另一种方法是使用两个标兵来遍历，一个跑得比香港记者还要快，一个跑得比香港记者慢，如果链表中存在环，那么快的标兵必定会在跑完一圈之后追上慢的标兵，通过这种追赶也能判断链表中有无环。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */class Solution {    public boolean hasCycle(ListNode head) {// Set        Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();        while (head != null) {            if (nodesSeen.contains(head)) {                return true;            } else {                nodesSeen.add(head);            }            head = head.next;        }        return false;    }    public boolean hasCycle(ListNode head) {// 标兵        if (head == null || head.next == null) {            return false;        }        ListNode slow = head;        ListNode fast = head.next;        while (slow != fast) {            if (fast == null || fast.next == null) {                return false;            }            slow = slow.next;            fast = fast.next.next;        }        return true;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def hasCycle(self, head): # Set        nodeset = set()        while head:            if head in nodeset:                return True            else:                nodeset.add(head)            head = head.next        return False    def hasCycle(self, head): # 标兵        fast = slow = head        while slow and fast and fast.next:            slow = slow.next            fast = fast.next.next            if slow is fast:                return True        return False</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第141题是简单题，Set的方法比较容易想到，Set也非常适合做重复检测的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Linked-List-Cycle&quot;&gt;&lt;a href=&quot;#Linked-List-Cycle&quot; class=&quot;headerlink&quot; title=&quot;Linked List Cycle&quot;&gt;&lt;/a&gt;Linked List Cycle
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第206题Reverse Linked List</title>
    <link href="https://wqdchn.github.io/leetcode-reverse-linked-list.html"/>
    <id>https://wqdchn.github.io/leetcode-reverse-linked-list.html</id>
    <published>2019-09-24T03:49:05.000Z</published>
    <updated>2019-09-28T03:12:01.180Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h4><p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a>反转单链表。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><p>我们需要三个指针，prev-&gt;curr-&gt;next，从头指针开始反转，令curr-&gt;prev，完成一个元素的反转之后，令其下一个元素为curr指针指向的对象，直到当前元素curr为空，可以使用遍历或递归的方式来实现。</p><table><thead><tr><th style="text-align:center">prev</th><th style="text-align:center">curr</th><th style="text-align:center">next</th><th style="text-align:center">…</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">…</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">…</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">…</td><td style="text-align:center">5</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">…</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">null</td><td style="text-align:center">…</td></tr></tbody></table><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java 的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseList(ListNode head) {// 遍历        ListNode re_head = null;        for (ListNode curr = head; curr != null; ){            ListNode temp = curr.next;            curr.next = re_head;            re_head = curr;            curr = temp;        }        return re_head;    }    public ListNode reverseList(ListNode head) {// 递归        if (head == null || head.next == null) return head;        ListNode re_head = reverseList(head.next);        head.next.next = head;        head.next = null;        return re_head;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reverseList(self, head):  # 遍历        re_head, curr = None, head        while curr:            curr.next, re_head, curr = re_head, curr, curr.next        return re_head    def reverseList(self, head: ListNode) -&gt; ListNode: # 递归        if head == None or head.next == None:            return head        temp = head.next        re_head = self.reverseList(temp)        head.next = None        temp.next = head        return re_head</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>LeetCode题目的难度是变动的，这一题之前还是中等题，最近变成了简单题，可能是练习的人多了，Accepted高了，说明基础还是很重要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Reverse Linked List&quot;&gt;&lt;/a&gt;Reverse Lin
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第24题Swap Nodes in Pairs</title>
    <link href="https://wqdchn.github.io/leetcode-swap-nodes-in-pairs.html"/>
    <id>https://wqdchn.github.io/leetcode-swap-nodes-in-pairs.html</id>
    <published>2019-09-22T04:05:28.000Z</published>
    <updated>2019-09-28T03:12:11.818Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h4><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a>给定一个链表，交换两个相邻节点，注意，不能修改列表节点中的值，只能更改节点本身的顺序。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p></blockquote><p>链表的结点交换或反转没有什么特别的地方，就是一把梭。LeeCode已经给我们定义好了结点Node：一个指针，一个结点值，交换函数传入参数的是头指针。当结点数是偶数的时候，没有问题，当结点数是奇数的时候，最后一个结点的下一个结点是Null，就不能交换或反转。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode swapPairs(ListNode head) {        if (head == null) return null;        if (head.next == null) return head;        ListNode temp = head.next;        head.next = head.next.next;        temp.next = head;        head = temp;        head.next.next = swapPairs(head.next.next);        return head;           }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        pre, pre.next = self, head        while pre.next and pre.next.next:            a = pre.next            b = a.next            pre.next, b.next, a.next = b, a, b.next            pre = a        return  self.next</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第24题是中等题，逻辑很简单，但是编码上有一些细节，别把自己绕晕了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Swap-Nodes-in-Pairs&quot;&gt;&lt;a href=&quot;#Swap-Nodes-in-Pairs&quot; class=&quot;headerlink&quot; title=&quot;Swap Nodes in Pairs&quot;&gt;&lt;/a&gt;Swap Nodes 
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第22题Generate Parentheses</title>
    <link href="https://wqdchn.github.io/leetcode-generate-parentheses.html"/>
    <id>https://wqdchn.github.io/leetcode-generate-parentheses.html</id>
    <published>2019-09-21T04:15:25.000Z</published>
    <updated>2019-09-28T03:11:28.711Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h4><p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">Generate Parentheses</a>给定一个正整数，生成有效括号的所有组合，这里只需要生成小括号即可。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><blockquote><p>Input: n = 3<br>Output: [<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><p>可见，当n确定时，生成的解的长度是固定的2n，并且解的开头一定是左括号，如果是右括号则是无效的解，左括号与右括号的数量必定是一样的，都是n个，这些是分析题目要求得到的“先验知识”了，接下来开始Code<del>贝叶斯推断bushi</del>。</p><p>怎么办呢，可以用递归或者说深度优先搜索的方法来遍历，每一个解看成一个长度2n的一维数组，我们往里面填充左括号和右括号，起始值都是n个，用掉一个就减去一个。如果当前还有左括号，就使用一个左括号，同时，如果右括号的数量比左括号多，则为左括号匹配一个右括号，直到两者都用完为止。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class Solution {  public List&lt;String&gt; generateParenthesis(int n) {    List&lt;String&gt; res = new ArrayList&lt;&gt;();    generate(&quot;&quot;, res, n, n);    return res;  }  public void generate(String sublist, List&lt;String&gt; res, int left, int right) {    if (left == 0 &amp;&amp; right == 0) {      res.add(sublist);      return;    }    if (left &gt; 0) {      generate(sublist + &quot;(&quot;, res, left - 1, right);    }    if (right &gt; left) {      generate(sublist + &quot;)&quot;, res, left, right - 1);    }  }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        def generate(p, left, right, parens=[]):            if left:                generate(p + &#39;(&#39;, left - 1, right)            if right &gt; left:                generate(p + &#39;)&#39;, left, right - 1)            if not right:                parens += p,            return parens        return generate(&#39;&#39;, n, n)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第22题是一个中等题，难度还不算非常大，递归的方法也非常简洁易懂，加油↖(^ω^)↗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Generate-Parentheses&quot;&gt;&lt;a href=&quot;#Generate-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;Generate Parentheses&quot;&gt;&lt;/a&gt;Generate
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="深度优先搜索" scheme="https://wqdchn.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第20题Valid Parentheses</title>
    <link href="https://wqdchn.github.io/leetcode-valid-parentheses.html"/>
    <id>https://wqdchn.github.io/leetcode-valid-parentheses.html</id>
    <published>2019-09-19T14:02:38.000Z</published>
    <updated>2019-09-28T03:12:37.357Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h4><p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a>的要求是匹配括号的合法性。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: “()”<br>Output: true</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: “()[]{}”<br>Output: true</p></blockquote><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h5><blockquote><p>Input: “(]”<br>Output: false</p></blockquote><p><del>解法明天再写，回去洗洗睡先。</del></p><p>方法是使用一个栈的数据结构来匹配括号，我们将每一个元素和三种括号分别进行匹配，如果是“(”那么就往栈里push进一个它的“解”也就是“)”，中括号和大括号也类似，也就是说我们匹配到一个左括号就往栈里push进一个“解”—右括号。</p><p>假设当前的括号序列是“()[]{}”，当匹配到第一个元素“(”的时候，栈里面就push进一个“)”，当匹配走到第二个元素“)”的时候，由于它不是待匹配的左括号，而是“解”，所以我们pop栈中的内容，刚好发现栈里面有一个“)”,于是将它pop出去，同理解决余下的元素，最后发现，栈是空的，且所有元素都匹配完了，说明没有非法的括号。如果中途栈就空了，而当前待匹配的不是左括号而是“解”—右括号，则说明已经无解了。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class Solution {    public boolean isValid(String s) {        if (s == null || s.length() == 0) return true;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (Character ch : s.toCharArray()) {            if (ch == &#39;(&#39;){                stack.push(&#39;)&#39;);            } else if (ch == &#39;[&#39;){                stack.push(&#39;]&#39;);            } else if (ch == &#39;{&#39;){                stack.push(&#39;}&#39;);            } else {                if (stack.isEmpty() || stack.pop() != ch){                    return false;                }            }        }        return stack.isEmpty();    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class Solution:    def isValid(self, s: str) -&gt; bool:        stack = []        paren_map = {&#39;)&#39;:&#39;(&#39;, &#39;]&#39;:&#39;[&#39;, &#39;}&#39;:&#39;{&#39;}        for c in s:            if c not in paren_map:                stack.append(c)            elif not stack or paren_map[c] != stack.pop():                return False        return not stack</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第20题是简单题，只要对栈这种数据结构稍微熟悉就能知道该怎么办，数据结构与算法的课程讲到栈这一节的时候也提到过括号匹配的问题<del>我猜大部分同学用的是严蔚民老师的那本经典教材</del>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Valid-Parentheses&quot;&gt;&lt;a href=&quot;#Valid-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;Valid Parentheses&quot;&gt;&lt;/a&gt;Valid Parentheses
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="堆栈与队列" scheme="https://wqdchn.github.io/tags/%E5%A0%86%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第15题Three Sum</title>
    <link href="https://wqdchn.github.io/leetcode-three-sum.html"/>
    <id>https://wqdchn.github.io/leetcode-three-sum.html</id>
    <published>2019-09-18T11:16:49.000Z</published>
    <updated>2019-09-28T03:12:16.435Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Three-Sum"><a href="#Three-Sum" class="headerlink" title="Three Sum"></a>Three Sum</h4><p><a href="https://leetcode.com/problems/three-sum/" target="_blank" rel="noopener">Three Sum</a>和<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">TwoSum</a>属于类似的题目，ThreeSum要求是，给定一个数组和一个目标值，求得数组中a+b+c=0的三个数a,b,c，这里目标数定为了零。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Given array nums = [-1, 0, 1, 2, -1, -4]</p></blockquote><blockquote><p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><p>解法如下，首先对数组进行从小到大排序，假定当前这个数nums[i]为a，我们在后面的数中寻找b和c，使得a+b+c=0。记住，我们已经排序过了，所以可以从两头进行夹逼，遍历满足条件的b和c，当a+b+c&gt;0的时候，剩余数的末尾nums[length-1]向左走，当a+b+c&lt;0的时候，剩余数的开头nums[i+1]向右走，。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class Solution {    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        Arrays.sort(nums);        for (int i = 0; i + 2 &lt; nums.length; i++) {            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {//一次循环过后要么找到一组解，要么无解                continue;//此处跳过重复解            }            int j = i + 1;            int k = nums.length - 1;            int target = -nums[i];            while (j &lt; k) {                if (nums[j] + nums[k] == target) {                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));                    j++;                    k--;                    while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++;                    while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--;                } else if (nums[j] + nums[k] &gt; target) {                    k--;                } else {                    j++;                }            }        }        return res;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class Solution:    def threeSum(self, nums):        if len(nums) &lt; 0: return []        nums.sort()        res = set()        for i, v in enumerate(nums[:-2]):            if i &gt;= 1 and v == nums[i-1]:                continue            d = {}            for x in nums[i+1:]:                if x not in d:                    d[-v-x] = 1                else:                    res.add((v, -v-x, x))        return list(map(list, res))</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第15题是中等题，解法依然很挠头，一遍写不出系列，Keep Moving T_T</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Three-Sum&quot;&gt;&lt;a href=&quot;#Three-Sum&quot; class=&quot;headerlink&quot; title=&quot;Three Sum&quot;&gt;&lt;/a&gt;Three Sum&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcod
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="哈希表" scheme="https://wqdchn.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第7题Reverse Integer</title>
    <link href="https://wqdchn.github.io/leetcode-reverse-integer.html"/>
    <id>https://wqdchn.github.io/leetcode-reverse-integer.html</id>
    <published>2019-09-15T04:09:44.000Z</published>
    <updated>2019-09-28T03:11:57.343Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h4><p><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Reverse Integer</a>的题目要求很简单，给定32位有符号整数，返回该整数翻转后的结果，结果中零在第一位的省略零。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: 123<br>Output: 321</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: -123<br>Output: -321</p></blockquote><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h5><blockquote><p>Input: 120<br>Output: 21</p></blockquote><p>同样，考虑一个简单粗暴的方法，将整数转换成字符串，将字符串转换成数组，对数组做逆序操作。当然要先判断这个整数的正负，然后考虑翻转后有没有零。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">Class Solution{    public static int reverse(int n) {        if (n &gt; Integer.MAX_VALUE || n &lt; Integer.MIN_VALUE) {            return 0;        }        String s = String.valueOf(n);        if (n &lt; 0) {            s = s.substring(1, s.length());            char[] array = s.toCharArray();            String reverse = &quot;-&quot;;            for (int i = array.length - 1; i &gt;= 0; i--) {                reverse += array[i];            }            s = reverse;        } else {            char[] array = s.toCharArray();            String reverse = &quot;&quot;;            for (int i = array.length - 1; i &gt;= 0; i--) {                reverse += array[i];            }            while (reverse.length() &gt; 1 &amp;&amp; reverse.charAt(0) == &#39;0&#39;) {                reverse = reverse.substring(1, reverse.length());            }            s = reverse;        }        int i = 0;        try {            i = Integer.parseInt(s.toString().trim());        } catch (Exception e) {            return 0;        }        return i;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class Solution:    def reverse(self, x: int) -&gt; int:        if x &gt;= 0:            res = int(str(x)[::-1])        else:            res = int(&#39;-&#39; + str(x)[:0:-1])        return res if -2147483648 &lt;= res &lt;= 2147483647 else 0</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第7题是简单题，LeetCode给出的标准解法有点挠头，先不管了<del>我好菜啊</del>。另外不得不说Python的内置函数真的太强大了T_T。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Reverse-Integer&quot;&gt;&lt;a href=&quot;#Reverse-Integer&quot; class=&quot;headerlink&quot; title=&quot;Reverse Integer&quot;&gt;&lt;/a&gt;Reverse Integer&lt;/h4&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数组与链表" scheme="https://wqdchn.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第1题Two Sum</title>
    <link href="https://wqdchn.github.io/leetcode-two-sum.html"/>
    <id>https://wqdchn.github.io/leetcode-two-sum.html</id>
    <published>2019-09-12T01:54:13.000Z</published>
    <updated>2019-09-28T03:12:21.679Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h4><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a>的题目要求是，给定一个数组和一个目标值，求得数组中两数num1和num2相加等于目标值target的两个数的下标。解法有两种，一是暴力法，一个个比较过来；二是哈希，把数组存在map里，存放的过程中只要发现map里面存有num1对应的目标解num2=target-num1，则返回下标即可。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>下面是Java的代码：</p><pre><code class="Java">class Solution {    public int[] twoSum(int[] nums,int target){        int[] result = new int[2];        for (int i = 0; i &lt; nums.length; i++){            for (int j = i + 1;j &lt; nums.length; j++){                if(nums[i] + nums[j] == target){                    result[0] = i;                    result[1] = j;                }            }        }        return result;    }}</code></pre><pre><code class="Java">class Solution {    public int[] twoSum(int[] nums,int target){        int[] result = new int[2];        Map&lt;Integer,Integer&gt; mp = new HashMap&lt;Integer, Integer&gt;();        for (int i  = 0; i &lt; nums.length; i++){            if(mp.containsKey(target - nums[i])){                result[0] = mp.get(target - nums[i]);                result[1] = i;                return  result;            }            mp.put(nums[i],i);        }        return result;    }}</code></pre><p>下面是Python的代码：</p><pre><code class="Python">class Solution:    def twoSum(self, nums, target: int):        mp = {}        for i, x in enumerate(nums):            if x in mp:                return mp[x], i            else:                mp[target - x] = i        return -1</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第1题是简单题，迈出了第一步，以后也不要停下噢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Two-Sum&quot;&gt;&lt;a href=&quot;#Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;Two Sum&quot;&gt;&lt;/a&gt;Two Sum&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/pr
      
    
    </summary>
    
      <category term="学习一个" scheme="https://wqdchn.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA/"/>
    
    
      <category term="LeetCode" scheme="https://wqdchn.github.io/tags/LeetCode/"/>
    
      <category term="编程" scheme="https://wqdchn.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="哈希表" scheme="https://wqdchn.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>西恩刀塔与Ti9</title>
    <link href="https://wqdchn.github.io/cn-dota-worst-dota.html"/>
    <id>https://wqdchn.github.io/cn-dota-worst-dota.html</id>
    <published>2019-08-26T02:26:29.000Z</published>
    <updated>2019-08-26T02:39:05.645Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="不浪能输？？？"><a href="#不浪能输？？？" class="headerlink" title="不浪能输？？？"></a>不浪能输？？？</h4><p>我就是在棺材里，也要发出声音，西恩刀塔亡了。</p><p>昨天的比赛看得很难受，LGD的韧性还是差了一截，一碾二翻三被碾，强行上演了一出经典剧情，能说什么呢。再看李逵和OG争冠军的比赛，不得不承认非常精彩，换成LGD去打，在那种局面下不一定绷的住，或者说很难绷的住，OG最终夺得了冠军，实至名归「硬实力」。</p><p>希望我们的队伍能好好磨练吧，无论是英雄池还是体系还是对版本的理解，多希望他们赢啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;不浪能输？？？&quot;&gt;&lt;a href=&quot;#不浪能输？？？&quot; class=&quot;headerlink&quot; title=&quot;不浪能输？？？&quot;&gt;&lt;/a&gt;不浪能输？？？&lt;/h4&gt;&lt;p&gt;我就是在棺材里，也要发出声音，西恩刀塔亡了。&lt;/p&gt;
&lt;p&gt;昨天
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wqdchn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://wqdchn.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="成长" scheme="https://wqdchn.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="老物" scheme="https://wqdchn.github.io/tags/%E8%80%81%E7%89%A9/"/>
    
      <category term="游戏" scheme="https://wqdchn.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>夏日</title>
    <link href="https://wqdchn.github.io/summer-day.html"/>
    <id>https://wqdchn.github.io/summer-day.html</id>
    <published>2019-08-06T11:12:14.000Z</published>
    <updated>2019-08-06T12:03:28.191Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="夏天的风物"><a href="#夏天的风物" class="headerlink" title="夏天的风物"></a>夏天的风物</h4><p>喜欢夏天，热烈的风，热烈的阳光，那天看到夕阳的余晖，想着这大概是我学生生涯最后一个夏天了吧，一时竟有些伤感。四月份的时候非常期待夏天的杨梅，但是这个夏天的杨梅没有给我特别的欢喜，端午节回家吃的猛了，以至于一晚上红着眼睛没有睡好。真像个什么都没吃过的小孩，喜欢的时候一定要吃干抹净。</p><p>夏天还有什么呢，我好像没有那么喜欢西瓜，大概是因为外公种过西瓜，小时候只记得吃，长大了却容易想起外公，又害怕掉眼泪，就不怎么吃西瓜了。</p><p>夏天最有意思的还是小伙伴，无论是抓鱼、打牌、捉迷藏，还是玩什么，一群人玩的满头大汗，欢喜的异常，这段时光无忧无虑，没有烦恼，除了偶尔埋怨一下太阳太毒，好像没有别的不满意的地方。</p><p>现在好像没有简单的快乐了，每一天和以前一样平淡，但是快乐却没有以前那样容易了。我又在说什么奇怪的话。</p><p>这个夏天，希望会有好运，是一个快乐的夏天。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;夏天的风物&quot;&gt;&lt;a href=&quot;#夏天的风物&quot; class=&quot;headerlink&quot; title=&quot;夏天的风物&quot;&gt;&lt;/a&gt;夏天的风物&lt;/h4&gt;&lt;p&gt;喜欢夏天，热烈的风，热烈的阳光，那天看到夕阳的余晖，想着这大概是我学生生涯最后一
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wqdchn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://wqdchn.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>工作996生病ICU</title>
    <link href="https://wqdchn.github.io/996-icu.html"/>
    <id>https://wqdchn.github.io/996-icu.html</id>
    <published>2019-04-13T02:45:22.000Z</published>
    <updated>2019-06-22T06:06:38.817Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="996ICU"><a href="#996ICU" class="headerlink" title="996ICU"></a>996ICU</h4><p>之前关于996ICU的讨论已经非常引人注目，996ICU的Github仓库已经有了21万的Star，这两天马云和刘强东又有相关的表态，更是引起新的议论。所谓的「996」就是每天早上9点到岗，工作到晚上9点，每周工作6天的一种工作制，显然，这是违反《劳动法》的，但是由于特殊的国情，这种违法现象非常的普遍。</p><p>996ICU的背后确实很复杂，企业和社会之间的博弈，老板和员工之间的博弈，员工之间的博弈，员工自身精神与肉体之间的博弈，但是归结到底还是「钱」的问题。</p><p>我想如果能给到相应的薪酬水平，大部分人是愿意接受996的，因为大部分人都是普通人，是被生活中的柴米油盐围绕着、被房车压迫着的普通人，大家都太需要钱了，尽管我还是认为996是一种不健康的行业生态。从这种层面上来说，工作只是「谋生」的手段，什么改变世界，创造未来对于大部分人都太遥远而缥缈了。</p><p>而当资本家们拿出这套「996才是拼搏」的说辞的时候，似乎有很多人愿意捧着，我不觉得这部分人他们是不明白背后的故事，只是现实不得不低头罢了吧。以我浅薄的看法，我觉得这也不要紧，为了家庭嘛，但是如果因此长起志气为资本家冲锋陷阵去和同僚们斗起法来博一个幸进，恐怕是有点扭曲了。</p><p>同样的，我看到一些让我唏嘘的言论，比如某些科研工作者，居然说「996居然能引起热议，我们科研民工都是XXX的」之类的话，如果是单纯的调侃，我觉得也已经到了边界，同样是被剥削，为什么要因为剥削的程度不同分起等级来仿佛要论个高下呢？书都读到狗肚子里了吗？</p><p>我相信老板们也有很多苦衷，员工们也有很多苦衷，那么和解的方式应该是法律，这是人类社会有关契约最大的公约数吧，所有人都要遵守法律，这样想好像又太幼稚了，如果《劳动法》真的在所有时候管用，也不会出现996ICU这个词了，法律只能保护大多数人，不能保护所有人，同样的只能在大多数时候保护大多数人，不能在所有时候保护所有人，这个思想好像有点危险，还有点歪楼了，嘿嘿。</p><p>另外就是，未来一段时间走上社会的大部分都是独生子女，家庭结构实在太单薄了，如果他们一人倒下了，背后跟着受罪的是两家年老的父母以及一个新生的家庭，这也是996ICU最恐怖的后果。</p><h4 id="政治课本背后的话"><a href="#政治课本背后的话" class="headerlink" title="政治课本背后的话"></a>政治课本背后的话</h4><p>作为资本家，他只是人格化的资本。他的灵魂就是资本的灵魂。而资本只有一种生活本能，这就是增值自身，获取剩余价值，用自己的不变部分即生产资料尽可能多的吮吸剩余劳动。资本是死劳动，它像吸血鬼一样，只有吮吸活劳动才有生命。</p><p>马克思的剥削理论指出，资本主义剥削是一种典型的市场剥削，这种剥削的存在依赖一定意义上自由、自愿的而非强迫的交换，“自由”的概念包括两种含义：一种是“积极的自由”即实在自由，另一种是“消极的自由”即形式自由。</p><p>实在自由是劳动者的自我实现，是作为自主权的自由，它意味着目标的积极能力；而形式自由则是一种意识形态幻觉，它包括作为消费者的自由、作为生产者的自由以及劳动者在劳动市场中的自由，这种形式是表面现象，而且是骗人是表面现象，罗马的奴隶是由锁链，雇佣工人则由看不见的线系在自己的所有者手里。</p><p>工人在自愿、平等交换的面纱下被迫地、不平等地出卖劳动力。</p><p>高中、大学的政治课堂上还是教了一些有用的东西的吧，书本上那些工人和资本家斗争的历史文字是生动的，直到今天依然没有过时，人类社会有时候还挺可笑的。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><blockquote><p><a href="https://996.icu/#/zh_CN" target="_blank" rel="noopener">996.ICU</a><br><a href="https://github.com/996icu/996.ICU" target="_blank" rel="noopener">996ICU的Github仓库</a><br><a href="http://www.cctb.net/llyj/llgc/foreignmarx/201402/t20140224_301628.htm" target="_blank" rel="noopener">剥削是合乎正义的吗</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;996ICU&quot;&gt;&lt;a href=&quot;#996ICU&quot; class=&quot;headerlink&quot; title=&quot;996ICU&quot;&gt;&lt;/a&gt;996ICU&lt;/h4&gt;&lt;p&gt;之前关于996ICU的讨论已经非常引人注目，996ICU的Github仓
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wqdchn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://wqdchn.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="时事" scheme="https://wqdchn.github.io/tags/%E6%97%B6%E4%BA%8B/"/>
    
  </entry>
  
</feed>
